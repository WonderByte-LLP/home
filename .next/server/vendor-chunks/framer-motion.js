"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/framer-motion";
exports.ids = ["vendor-chunks/framer-motion"];
exports.modules = {

/***/ "(ssr)/./node_modules/framer-motion/dist/cjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/framer-motion/dist/cjs/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar heyListen = __webpack_require__(/*! hey-listen */ \"(ssr)/./node_modules/hey-listen/dist/hey-listen.es.js\");\nvar styleValueTypes = __webpack_require__(/*! style-value-types */ \"(ssr)/./node_modules/style-value-types/dist/valueTypes.cjs.js\");\nvar popmotion = __webpack_require__(/*! popmotion */ \"(ssr)/./node_modules/popmotion/dist/popmotion.cjs.js\");\nvar sync = __webpack_require__(/*! framesync */ \"(ssr)/./node_modules/framesync/dist/framesync.cjs.js\");\nvar dom = __webpack_require__(/*! @motionone/dom */ \"(ssr)/./node_modules/@motionone/dom/dist/index.es.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/ _interopNamespace(React);\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/ _interopDefaultLegacy(sync);\n/**\n * Browser-safe usage of process\n */ var defaultEnvironment = \"production\";\nvar env = typeof process === \"undefined\" || process.env === undefined ? defaultEnvironment : \"development\" || 0;\nvar createDefinition = function(propNames) {\n    return {\n        isEnabled: function(props) {\n            return propNames.some(function(name) {\n                return !!props[name];\n            });\n        }\n    };\n};\nvar featureDefinitions = {\n    measureLayout: createDefinition([\n        \"layout\",\n        \"layoutId\",\n        \"drag\"\n    ]),\n    animation: createDefinition([\n        \"animate\",\n        \"exit\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"whileFocus\",\n        \"whileDrag\",\n        \"whileInView\"\n    ]),\n    exit: createDefinition([\n        \"exit\"\n    ]),\n    drag: createDefinition([\n        \"drag\",\n        \"dragControls\"\n    ]),\n    focus: createDefinition([\n        \"whileFocus\"\n    ]),\n    hover: createDefinition([\n        \"whileHover\",\n        \"onHoverStart\",\n        \"onHoverEnd\"\n    ]),\n    tap: createDefinition([\n        \"whileTap\",\n        \"onTap\",\n        \"onTapStart\",\n        \"onTapCancel\"\n    ]),\n    pan: createDefinition([\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\"\n    ]),\n    inView: createDefinition([\n        \"whileInView\",\n        \"onViewportEnter\",\n        \"onViewportLeave\"\n    ])\n};\nfunction loadFeatures(features) {\n    for(var key in features){\n        if (features[key] === null) continue;\n        if (key === \"projectionNodeConstructor\") {\n            featureDefinitions.projectionNodeConstructor = features[key];\n        } else {\n            featureDefinitions[key].Component = features[key];\n        }\n    }\n}\nvar LazyContext = React.createContext({\n    strict: false\n});\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */ function useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = React.useContext(LazyContext);\n    if (!visualElement) return null;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */ if (env !== \"production\" && preloadedFeatures && lazyContext.strict) {\n        heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for(var i = 0; i < numFeatures; i++){\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */ if (isEnabled(props) && Component) {\n            features.push(React__namespace.createElement(Component, tslib.__assign({\n                key: name_1\n            }, props, {\n                visualElement: visualElement\n            })));\n        }\n    }\n    return features;\n}\n/**\n * @public\n */ var MotionConfigContext = React.createContext({\n    transformPagePoint: function(p) {\n        return p;\n    },\n    isStatic: false,\n    reducedMotion: \"never\"\n});\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n    return React.useContext(MotionContext).visualElement;\n}\n/**\n * @public\n */ var PresenceContext = React.createContext(null);\nvar isBrowser = typeof document !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion = {\n    current: null\n};\nvar hasDetected = false;\nfunction initPrefersReducedMotion() {\n    hasDetected = true;\n    if (!isBrowser) return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function() {\n            return prefersReducedMotion.current = motionMediaQuery_1.matches;\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    } else {\n        prefersReducedMotion.current = false;\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */ function useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */ !hasDetected && initPrefersReducedMotion();\n    var _a = tslib.__read(React.useState(prefersReducedMotion.current), 1), shouldReduceMotion = _a[0];\n    /**\n     * TODO See if people miss automatically updating shouldReduceMotion setting\n     */ return shouldReduceMotion;\n}\nfunction useReducedMotionConfig() {\n    var reducedMotionPreference = useReducedMotion();\n    var reducedMotion = React.useContext(MotionConfigContext).reducedMotion;\n    if (reducedMotion === \"never\") {\n        return false;\n    } else if (reducedMotion === \"always\") {\n        return true;\n    } else {\n        return reducedMotionPreference;\n    }\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var lazyContext = React.useContext(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = React.useContext(PresenceContext);\n    var shouldReduceMotion = useReducedMotionConfig();\n    var visualElementRef = React.useRef(undefined);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */ if (!createVisualElement) createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: props,\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n            shouldReduceMotion: shouldReduceMotion\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function() {\n        visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n    });\n    React.useEffect(function() {\n        var _a;\n        (_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function() {\n        return function() {\n            return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount();\n        };\n    }, []);\n    return visualElement;\n}\nfunction isRefObject(ref) {\n    return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */ function useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(function(instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance ? visualElement.mount(instance) : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            } else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */ [\n        visualElement\n    ]);\n}\n/**\n * Decides if the supplied variable is an array of variant labels\n */ function isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */ function isVariantLabel(v) {\n    return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */ function getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function(value, key) {\n        return current[key] = value.get();\n    });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */ function getVelocity$1(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function(value, key) {\n        return velocity[key] = value.getVelocity();\n    });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) {\n        currentValues = {};\n    }\n    if (currentVelocity === void 0) {\n        currentVelocity = {};\n    }\n    /**\n     * If the variant definition is a function, resolve.\n     */ if (typeof definition === \"function\") {\n        definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */ if (typeof definition === \"string\") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */ if (typeof definition === \"function\") {\n        definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n    }\n    return definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\nfunction useCreateMotionContext(props) {\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return React.useMemo(function() {\n        return {\n            initial: initial,\n            animate: animate\n        };\n    }, [\n        variantLabelsAsDependency(initial),\n        variantLabelsAsDependency(animate)\n    ]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */ function useConstant(init) {\n    var ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */ var globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */ hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */ hasEverUpdated: false\n};\nvar id$1 = 1;\nfunction useProjectionId() {\n    return useConstant(function() {\n        if (globalProjectionState.hasEverUpdated) {\n            return id$1++;\n        }\n    });\n}\nvar LayoutGroupContext = React.createContext({});\n/**\n * Internal, exported only for usage in Framer\n */ var SwitchLayoutGroupContext = React.createContext({});\nfunction useProjection(projectionId, _a, visualElement, ProjectionNodeConstructor) {\n    var _b;\n    var layoutId = _a.layoutId, layout = _a.layout, drag = _a.drag, dragConstraints = _a.dragConstraints, layoutScroll = _a.layoutScroll;\n    var initialPromotionConfig = React.useContext(SwitchLayoutGroupContext);\n    if (!ProjectionNodeConstructor || !visualElement || (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection)) {\n        return;\n    }\n    visualElement.projection = new ProjectionNodeConstructor(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);\n    visualElement.projection.setOptions({\n        layoutId: layoutId,\n        layout: layout,\n        alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: visualElement,\n        scheduleRender: function() {\n            return visualElement.scheduleRender();\n        },\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */ animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialPromotionConfig,\n        layoutScroll: layoutScroll\n    });\n}\nvar VisualElementHandler = /** @class */ function(_super) {\n    tslib.__extends(VisualElementHandler, _super);\n    function VisualElementHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Update visual element props as soon as we know this update is going to be commited.\n     */ VisualElementHandler.prototype.getSnapshotBeforeUpdate = function() {\n        this.updateProps();\n        return null;\n    };\n    VisualElementHandler.prototype.componentDidUpdate = function() {};\n    VisualElementHandler.prototype.updateProps = function() {\n        var _a = this.props, visualElement = _a.visualElement, props = _a.props;\n        if (visualElement) visualElement.setProps(props);\n    };\n    VisualElementHandler.prototype.render = function() {\n        return this.props.children;\n    };\n    return VisualElementHandler;\n}(React__default[\"default\"].Component);\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */ function createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        var layoutId = useLayoutId(props);\n        props = tslib.__assign(tslib.__assign({}, props), {\n            layoutId: layoutId\n        });\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */ var config = React.useContext(MotionConfigContext);\n        var features = null;\n        var context = useCreateMotionContext(props);\n        /**\n         * Create a unique projection ID for this component. If a new component is added\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\n         * us to measure it as soon as any layout effect flushes pending layout animations.\n         *\n         * Performance note: It'd be better not to have to search the DOM for these elements.\n         * For newly-entering components it could be enough to only correct treeScale, in which\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\n         * shared element transitions however. Perhaps for those we could revert to a root node\n         * that gets forceRendered and layout animations are triggered on its layout effect.\n         */ var projectionId = config.isStatic ? undefined : useProjectionId();\n        /**\n         *\n         */ var visualState = useVisualState(props, config.isStatic);\n        if (!config.isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */ context.visualElement = useVisualElement(Component, visualState, tslib.__assign(tslib.__assign({}, config), props), createVisualElement);\n            useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             */ features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */ return React__namespace.createElement(VisualElementHandler, {\n            visualElement: context.visualElement,\n            props: tslib.__assign(tslib.__assign({}, config), props)\n        }, features, React__namespace.createElement(MotionContext.Provider, {\n            value: context\n        }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement)));\n    }\n    return React.forwardRef(MotionComponent);\n}\nfunction useLayoutId(_a) {\n    var _b;\n    var layoutId = _a.layoutId;\n    var layoutGroupId = (_b = React.useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\n    return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */ function createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) {\n            customMotionComponentConfig = {};\n        }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    if (typeof Proxy === \"undefined\") {\n        return custom;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */ var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */ get: function(_target, key) {\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */ if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        }\n    });\n}\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */ var lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\"\n];\nfunction isSVGComponent(Component) {\n    if (/**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */ typeof Component !== \"string\" || /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */ Component.includes(\"-\")) {\n        return false;\n    } else if (/**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */ lowercaseSVGElements.indexOf(Component) > -1 || /**\n         * If it contains a capital letter, it's an SVG component\n         */ /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */ var transformAxes = [\n    \"\",\n    \"X\",\n    \"Y\",\n    \"Z\"\n];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */ var order = [\n    \"translate\",\n    \"scale\",\n    \"rotate\",\n    \"skew\"\n];\n/**\n * Generate a list of every possible transform key.\n */ var transformProps = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\"\n];\norder.forEach(function(operationKey) {\n    return transformAxes.forEach(function(axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */ function sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */ var transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */ var transformOriginProps = new Set([\n    \"originX\",\n    \"originY\",\n    \"originZ\"\n]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\nvar isMotionValue = function(value) {\n    return Boolean(value !== null && typeof value === \"object\" && value.getVelocity);\n};\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */ function buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we're going to build into.\n    var transformString = \"\";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for(var i = 0; i < numTransformKeys; i++){\n        var key = transformKeys[i];\n        transformString += \"\".concat(translateAlias[key] || key, \"(\").concat(transform[key], \") \");\n        if (key === \"z\") transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    } else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    } else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */ function buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return \"\".concat(originX, \" \").concat(originY, \" \").concat(originZ);\n}\n/**\n * Returns true if the provided key is a CSS variable\n */ function isCSSVariable$1(key) {\n    return key.startsWith(\"--\");\n}\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */ var getValueAsType = function(value, type) {\n    return type && typeof value === \"number\" ? type.transform(value) : value;\n};\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), {\n    transform: Math.round\n});\nvar numberValueTypes = {\n    // Border props\n    borderWidth: styleValueTypes.px,\n    borderTopWidth: styleValueTypes.px,\n    borderRightWidth: styleValueTypes.px,\n    borderBottomWidth: styleValueTypes.px,\n    borderLeftWidth: styleValueTypes.px,\n    borderRadius: styleValueTypes.px,\n    radius: styleValueTypes.px,\n    borderTopLeftRadius: styleValueTypes.px,\n    borderTopRightRadius: styleValueTypes.px,\n    borderBottomRightRadius: styleValueTypes.px,\n    borderBottomLeftRadius: styleValueTypes.px,\n    // Positioning props\n    width: styleValueTypes.px,\n    maxWidth: styleValueTypes.px,\n    height: styleValueTypes.px,\n    maxHeight: styleValueTypes.px,\n    size: styleValueTypes.px,\n    top: styleValueTypes.px,\n    right: styleValueTypes.px,\n    bottom: styleValueTypes.px,\n    left: styleValueTypes.px,\n    // Spacing props\n    padding: styleValueTypes.px,\n    paddingTop: styleValueTypes.px,\n    paddingRight: styleValueTypes.px,\n    paddingBottom: styleValueTypes.px,\n    paddingLeft: styleValueTypes.px,\n    margin: styleValueTypes.px,\n    marginTop: styleValueTypes.px,\n    marginRight: styleValueTypes.px,\n    marginBottom: styleValueTypes.px,\n    marginLeft: styleValueTypes.px,\n    // Transform props\n    rotate: styleValueTypes.degrees,\n    rotateX: styleValueTypes.degrees,\n    rotateY: styleValueTypes.degrees,\n    rotateZ: styleValueTypes.degrees,\n    scale: styleValueTypes.scale,\n    scaleX: styleValueTypes.scale,\n    scaleY: styleValueTypes.scale,\n    scaleZ: styleValueTypes.scale,\n    skew: styleValueTypes.degrees,\n    skewX: styleValueTypes.degrees,\n    skewY: styleValueTypes.degrees,\n    distance: styleValueTypes.px,\n    translateX: styleValueTypes.px,\n    translateY: styleValueTypes.px,\n    translateZ: styleValueTypes.px,\n    x: styleValueTypes.px,\n    y: styleValueTypes.px,\n    z: styleValueTypes.px,\n    perspective: styleValueTypes.px,\n    transformPerspective: styleValueTypes.px,\n    opacity: styleValueTypes.alpha,\n    originX: styleValueTypes.progressPercentage,\n    originY: styleValueTypes.progressPercentage,\n    originZ: styleValueTypes.px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: styleValueTypes.alpha,\n    strokeOpacity: styleValueTypes.alpha,\n    numOctaves: int\n};\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */ for(var key in latestValues){\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */ if (isCSSVariable$1(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone) continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0)) transformIsNone = false;\n        } else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        } else {\n            style[key] = valueAsType;\n        }\n    }\n    if (hasTransform) {\n        style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    } else if (transformTemplate) {\n        style.transform = transformTemplate({}, \"\");\n    } else if (!latestValues.transform && style.transform) {\n        style.transform = \"none\";\n    }\n    if (hasTransformOrigin) {\n        style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n}\nvar createHtmlRenderState = function() {\n    return {\n        style: {},\n        transform: {},\n        transformKeys: [],\n        transformOrigin: {},\n        vars: {}\n    };\n};\nfunction copyRawValuesOnly(target, source, props) {\n    for(var key in source){\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return React.useMemo(function() {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, {\n            enableHardwareAcceleration: !isStatic\n        }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return tslib.__assign(tslib.__assign({}, vars), style);\n    }, [\n        visualState\n    ]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */ copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag) && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction = props.drag === true ? \"none\" : \"pan-\".concat(props.drag === \"x\" ? \"y\" : \"x\");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */ var validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"layout\",\n    \"layoutId\",\n    \"layoutDependency\",\n    \"onLayoutAnimationStart\",\n    \"onLayoutAnimationComplete\",\n    \"onLayoutMeasure\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"dragSnapToOrigin\",\n    \"_dragX\",\n    \"_dragY\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"whileDrag\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"whileFocus\",\n    \"whileTap\",\n    \"whileHover\",\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"viewport\",\n    \"layoutScroll\"\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */ function isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\nvar shouldForward = function(key) {\n    return !isValidMotionProp(key);\n};\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp) return;\n    // Explicitly filter our events\n    shouldForward = function(key) {\n        return key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n    };\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */ try {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */ loadExternalIsValidProp((__webpack_require__(/*! @emotion/is-prop-valid */ \"(ssr)/./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\")[\"default\"]));\n} catch (_a) {\n// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for(var key in props){\n        if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners\n        props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\" ? origin : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */ function calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return \"\".concat(pxOriginX, \" \").concat(pxOriginY);\n}\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */ function buildSVGPath(attrs, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) {\n        spacing = 1;\n    }\n    if (offset === void 0) {\n        offset = 0;\n    }\n    if (useDashCase === void 0) {\n        useDashCase = true;\n    }\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = styleValueTypes.px.transform(-offset);\n    // Build the dash array\n    var pathLength = styleValueTypes.px.transform(length);\n    var pathSpacing = styleValueTypes.px.transform(spacing);\n    attrs[keys.array] = \"\".concat(pathLength, \" \").concat(pathSpacing);\n}\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */ function buildSVGAttrs(state, _a, options, transformTemplate) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\n        \"attrX\",\n        \"attrY\",\n        \"originX\",\n        \"originY\",\n        \"pathLength\",\n        \"pathSpacing\",\n        \"pathOffset\"\n    ]);\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */ if (attrs.transform) {\n        if (dimensions) style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined) attrs.x = attrX;\n    if (attrY !== undefined) attrs.y = attrY;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\nvar createSvgRenderState = function() {\n    return tslib.__assign(tslib.__assign({}, createHtmlRenderState()), {\n        attrs: {}\n    });\n};\nfunction useSVGProps(props, visualState) {\n    var visualProps = React.useMemo(function() {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, {\n            enableHardwareAcceleration: false\n        }, props.transformTemplate);\n        return tslib.__assign(tslib.__assign({}, state.attrs), {\n            style: tslib.__assign({}, state.style)\n        });\n    }, [\n        visualState\n    ]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) {\n        forwardMotionProps = false;\n    }\n    var useRender = function(Component, props, projectionId, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), {\n            ref: ref\n        });\n        if (projectionId) {\n            elementProps[\"data-projection-id\"] = projectionId;\n        }\n        return React.createElement(Component, elementProps);\n    };\n    return useRender;\n}\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */ var camelToDash = function(str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\nfunction renderHTML(element, _a, styleProp, projection) {\n    var style = _a.style, vars = _a.vars;\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for(var key in vars){\n        element.style.setProperty(key, vars[key]);\n    }\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */ var camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\"\n]);\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for(var key in renderState.attrs){\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\nfunction scrapeMotionValuesFromProps$1(props) {\n    var style = props.style;\n    var newValues = {};\n    for(var key in style){\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\nfunction scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps$1(props);\n    for(var key in props){\n        if (isMotionValue(props[key])) {\n            var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\nvar isKeyframesTarget = function(v) {\n    return Array.isArray(v);\n};\nvar isCustomValue = function(v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function(v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */ function resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState()\n    };\n    if (onMount) {\n        state.mount = function(instance) {\n            return onMount(props, instance, state);\n        };\n    }\n    return state;\n}\nvar makeUseVisualState = function(config) {\n    return function(props, isStatic) {\n        var context = React.useContext(MotionContext);\n        var presenceContext = React.useContext(PresenceContext);\n        return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function() {\n            return makeState(config, props, context, presenceContext);\n        });\n    };\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for(var key in motionValues){\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : initial = context.initial;\n        animate !== null && animate !== void 0 ? animate : animate = context.animate;\n    }\n    var initialAnimationIsBlocked = blockInitialAnimation || initial === false;\n    var variantToSet = initialAnimationIsBlocked ? animate : initial;\n    if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [\n            variantToSet\n        ];\n        list.forEach(function(definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved) return;\n            var transitionEnd = resolved.transitionEnd;\n            resolved.transition;\n            var target = tslib.__rest(resolved, [\n                \"transitionEnd\",\n                \"transition\"\n            ]);\n            for(var key in target){\n                var valueTarget = target[key];\n                if (Array.isArray(valueTarget)) {\n                    /**\n                     * Take final keyframe if the initial animation is blocked because\n                     * we want to initialise at the end of that blocked animation.\n                     */ var index = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;\n                    valueTarget = valueTarget[index];\n                }\n                if (valueTarget !== null) {\n                    values[key] = valueTarget;\n                }\n            }\n            for(var key in transitionEnd)values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function(props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n            } catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0\n                };\n            }\n            buildSVGAttrs(renderState, latestValues, {\n                enableHardwareAcceleration: false\n            }, props.transformTemplate);\n            renderSVG(instance, renderState);\n        }\n    })\n};\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState\n    })\n};\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n    return tslib.__assign(tslib.__assign({}, baseConfig), {\n        preloadedFeatures: preloadedFeatures,\n        useRender: createUseRender(forwardMotionProps),\n        createVisualElement: createVisualElement,\n        projectionNodeConstructor: projectionNodeConstructor,\n        Component: Component\n    });\n}\nexports.AnimationType = void 0;\n(function(AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"InView\"] = \"whileInView\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(exports.AnimationType || (exports.AnimationType = {}));\nfunction addDomEvent(target, eventName, handler, options) {\n    if (options === void 0) {\n        options = {\n            passive: true\n        };\n    }\n    target.addEventListener(eventName, handler, options);\n    return function() {\n        return target.removeEventListener(eventName, handler);\n    };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */ function useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(function() {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [\n        ref,\n        eventName,\n        handler,\n        options\n    ]);\n}\n/**\n *\n * @param props\n * @param ref\n * @internal\n */ function useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function() {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Focus, true);\n    };\n    var onBlur = function() {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */ function filterPrimaryPointer(eventHandler) {\n    return function(event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = {\n    pageX: 0,\n    pageY: 0\n};\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) {\n        pointType = \"page\";\n    }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"]\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) {\n        pointType = \"page\";\n    }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"]\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) {\n        pointType = \"page\";\n    }\n    return {\n        point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n    };\n}\nvar wrapHandler = function(handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) {\n        shouldFilterPrimaryPointer = false;\n    }\n    var listener = function(event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function() {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function() {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function() {\n    return isBrowser && window.onmousedown === null;\n};\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    } else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    } else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction createLock(name) {\n    var lock = null;\n    return function() {\n        var openLock = function() {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    } else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    } else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function() {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        } else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1) openHorizontal_1();\n            if (openVertical_1) openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return true;\n    openGestureLock();\n    return false;\n}\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function(event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive()) return;\n        /**\n         * Ensure we trigger animations before firing event callback\n         */ (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Hover, isActive);\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : undefined, {\n        passive: !onHoverStart\n    });\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : undefined, {\n        passive: !onHoverEnd\n    });\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */ var isNodeOrChild = function(parent, child) {\n    if (!child) {\n        return false;\n    } else if (parent === child) {\n        return true;\n    } else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\nfunction useUnmountEffect(callback) {\n    return React.useEffect(function() {\n        return function() {\n            return callback();\n        };\n    }, []);\n}\n/**\n * @param handlers -\n * @internal\n */ function useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = React.useRef(false);\n    var cancelPointerEndListeners = React.useRef(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */ var eventOptions = {\n        passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n    };\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd()) return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */ !isNodeOrChild(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd()) return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current) return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n        /**\n         * Ensure we trigger animations before firing event callback\n         */ (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Tap, true);\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined, eventOptions);\n    useUnmountEffect(removePointerEndListener);\n}\nvar warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message)) return;\n    console.warn(message);\n    if (element) console.warn(element);\n    warned.add(message);\n}\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */ var observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */ var observers = new WeakMap();\nvar fireObserverCallback = function(entry) {\n    var _a;\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nvar fireAllObserverCallbacks = function(entries) {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n    var root = _a.root, options = tslib.__rest(_a, [\n        \"root\"\n    ]);\n    var lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */ if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    var rootObservers = observers.get(lookupRoot);\n    var key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */ if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, tslib.__assign({\n            root: root\n        }, options));\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    var rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return function() {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\nfunction useViewport(_a) {\n    var visualElement = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;\n    var state = React.useRef({\n        hasEnteredView: false,\n        isInView: false\n    });\n    var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n    if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n    var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n    useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n    some: 0,\n    all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? \"some\" : _b, once = _a.once;\n    React.useEffect(function() {\n        if (!shouldObserve) return;\n        var options = {\n            root: root === null || root === void 0 ? void 0 : root.current,\n            rootMargin: rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n        };\n        var intersectionCallback = function(entry) {\n            var _a;\n            var isIntersecting = entry.isIntersecting;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */ if (state.isInView === isIntersecting) return;\n            state.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */ if (once && !isIntersecting && state.hasEnteredView) {\n                return;\n            } else if (isIntersecting) {\n                state.hasEnteredView = true;\n            }\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.InView, isIntersecting);\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */ var props = visualElement.getProps();\n            var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n            callback === null || callback === void 0 ? void 0 : callback(entry);\n        };\n        return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n    }, [\n        shouldObserve,\n        root,\n        rootMargin,\n        amount\n    ]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */ function useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var _b = _a.fallback, fallback = _b === void 0 ? true : _b;\n    React.useEffect(function() {\n        if (!shouldObserve || !fallback) return;\n        if (env !== \"production\") {\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n        }\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won't have flushed for the first time and there's certain logic in\n         * there that behaves differently on the initial animation.\n         *\n         * This hook should be quite rarely called so setting this in an rAF\n         * is preferred to changing the behaviour of the animation state.\n         */ requestAnimationFrame(function() {\n            var _a;\n            state.hasEnteredView = true;\n            var onViewportEnter = visualElement.getProps().onViewportEnter;\n            onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.InView, true);\n        });\n    }, [\n        shouldObserve\n    ]);\n}\nvar makeRenderlessComponent = function(hook) {\n    return function(props) {\n        hook(props);\n        return null;\n    };\n};\nvar gestureAnimations = {\n    inView: makeRenderlessComponent(useViewport),\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture)\n};\nvar counter = 0;\nvar incrementId = function() {\n    return counter++;\n};\nvar useId = function() {\n    return useConstant(incrementId);\n};\n/**\n * Ideally we'd use the following code to support React 18 optionally.\n * But this fairly fails in Webpack (otherwise treeshaking wouldn't work at all).\n * Need to come up with a different way of figuring this out.\n */ // export const useId = (React as any).useId\n//     ? (React as any).useId\n//     : () => useConstant(incrementId)\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */ function usePresence() {\n    var context = React.useContext(PresenceContext);\n    if (context === null) return [\n        true,\n        null\n    ];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useId when released in React\n    var id = useId();\n    React.useEffect(function() {\n        return register(id);\n    }, []);\n    var safeToRemove = function() {\n        return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n    };\n    return !isPresent && onExitComplete ? [\n        false,\n        safeToRemove\n    ] : [\n        true\n    ];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */ function useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev)) return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length) return false;\n    for(var i = 0; i < prevLength; i++){\n        if (prev[i] !== next[i]) return false;\n    }\n    return true;\n}\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */ var secondsToMilliseconds = function(seconds) {\n    return seconds * 1000;\n};\nvar easingLookup = {\n    linear: popmotion.linear,\n    easeIn: popmotion.easeIn,\n    easeInOut: popmotion.easeInOut,\n    easeOut: popmotion.easeOut,\n    circIn: popmotion.circIn,\n    circInOut: popmotion.circInOut,\n    circOut: popmotion.circOut,\n    backIn: popmotion.backIn,\n    backInOut: popmotion.backInOut,\n    backOut: popmotion.backOut,\n    anticipate: popmotion.anticipate,\n    bounceIn: popmotion.bounceIn,\n    bounceInOut: popmotion.bounceInOut,\n    bounceOut: popmotion.bounceOut\n};\nvar easingDefinitionToFunction = function(definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return popmotion.cubicBezier(x1, y1, x2, y2);\n    } else if (typeof definition === \"string\") {\n        // Else lookup from table\n        heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\".concat(definition, \"'\"));\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function(ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */ var isAnimatable = function(key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\") return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value)) return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n    styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n    !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\nvar underDampedSpring = function() {\n    return {\n        type: \"spring\",\n        stiffness: 500,\n        damping: 25,\n        restSpeed: 10\n    };\n};\nvar criticallyDampedSpring = function(to) {\n    return {\n        type: \"spring\",\n        stiffness: 550,\n        damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n        restSpeed: 10\n    };\n};\nvar linearTween = function() {\n    return {\n        type: \"keyframes\",\n        ease: \"linear\",\n        duration: 0.3\n    };\n};\nvar keyframes = function(values) {\n    return {\n        type: \"keyframes\",\n        duration: 0.8,\n        values: values\n    };\n};\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring\n};\nvar getDefaultTransition = function(valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    } else {\n        transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return tslib.__assign({\n        to: to\n    }, transitionFactory(to));\n};\n/**\n * A map of default value types for common values\n */ var defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), {\n    // Color props\n    color: styleValueTypes.color,\n    backgroundColor: styleValueTypes.color,\n    outlineColor: styleValueTypes.color,\n    fill: styleValueTypes.color,\n    stroke: styleValueTypes.color,\n    // Border props\n    borderColor: styleValueTypes.color,\n    borderTopColor: styleValueTypes.color,\n    borderRightColor: styleValueTypes.color,\n    borderBottomColor: styleValueTypes.color,\n    borderLeftColor: styleValueTypes.color,\n    filter: styleValueTypes.filter,\n    WebkitFilter: styleValueTypes.filter\n});\n/**\n * Gets the default ValueType for the provided value key\n */ var getDefaultValueType = function(key) {\n    return defaultValueTypes[key];\n};\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== styleValueTypes.filter) defaultValueType = styleValueTypes.complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\nvar instantAnimationState = {\n    current: false\n};\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */ function isTransitionDefined(_a) {\n    _a.when;\n    _a.delay;\n    _a.delayChildren;\n    _a.staggerChildren;\n    _a.staggerDirection;\n    _a.repeat;\n    _a.repeatType;\n    _a.repeatDelay;\n    _a.from;\n    var transition = tslib.__rest(_a, [\n        \"when\",\n        \"delay\",\n        \"delayChildren\",\n        \"staggerChildren\",\n        \"staggerDirection\",\n        \"repeat\",\n        \"repeatType\",\n        \"repeatDelay\",\n        \"from\"\n    ]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */ function convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\n        \"ease\",\n        \"times\",\n        \"yoyo\",\n        \"flip\",\n        \"loop\"\n    ]);\n    var options = tslib.__assign({}, transition);\n    if (times) options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */ if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */ if (ease) {\n        options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */ if (transition.type === \"tween\") options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */ if (yoyo || loop || flip) {\n        heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        } else if (loop) {\n            options.repeatType = \"loop\";\n        } else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */ if (transition.type !== \"spring\") options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */ function getDelayFromTransition(transition, key) {\n    var _a, _b;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = tslib.__spreadArray([], tslib.__read(options.to), false);\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */ if (!isTransitionDefined(transition)) {\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */ function getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */ origin = getAnimatableNone(key, target);\n    } else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \".concat(key, ' from \"').concat(origin, '\" to \"').concat(target, '\". ').concat(origin, \" is not an animatable value - to enable this animation set \").concat(origin, \" to a value animatable to \").concat(target, \" via the `style` property.\"));\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function(v) {\n                return value.set(v);\n            }\n        };\n        return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition)) : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n            onUpdate: function(v) {\n                var _a;\n                options.onUpdate(v);\n                (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n            },\n            onComplete: function() {\n                var _a;\n                options.onComplete();\n                (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n            }\n        }));\n    }\n    function set() {\n        var _a, _b;\n        var finalTarget = resolveFinalValueInKeyframes(target);\n        value.set(finalTarget);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, finalTarget);\n        (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);\n        return {\n            stop: function() {}\n        };\n    }\n    return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n    return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */ function startAnimation(key, value, target, transition) {\n    if (transition === void 0) {\n        transition = {};\n    }\n    if (instantAnimationState.current) {\n        transition = {\n            type: false\n        };\n    }\n    return value.start(function(onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function() {\n            return controls = animation();\n        };\n        if (delay) {\n            delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n        } else {\n            start();\n        }\n        return function() {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */ var isNumericalString = function(v) {\n    return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */ var isZeroValueString = function(v) {\n    return /^0[^.\\s]+$/.test(v);\n};\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem(_a, fromIndex, toIndex) {\n    var _b = tslib.__read(_a), arr = _b.slice(0);\n    var startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        var endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        var _c = tslib.__read(arr.splice(fromIndex, 1), 1), item = _c[0];\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\nvar SubscriptionManager = /** @class */ function() {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function(handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function() {\n            return removeItem(_this.subscriptions, handler);\n        };\n    };\n    SubscriptionManager.prototype.notify = function(a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions) return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */ this.subscriptions[0](a, b, c);\n        } else {\n            for(var i = 0; i < numSubscriptions; i++){\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */ var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function() {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function() {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}();\nvar isFloat = function(value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */ var MotionValue = /** @class */ function() {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */ function MotionValue(init) {\n        var _this = this;\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */ this.version = \"6.5.1\";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */ this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */ this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */ this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */ this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */ this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */ this.canTrackVelocity = false;\n        this.updateAndNotify = function(v, render) {\n            if (render === void 0) {\n                render = true;\n            }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync__default[\"default\"].postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */ this.scheduleVelocityCheck = function() {\n            return sync__default[\"default\"].postRender(_this.velocityCheck);\n        };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */ this.velocityCheck = function(_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @privateRemarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */ MotionValue.prototype.onChange = function(subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function() {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */ MotionValue.prototype.onRenderRequest = function(subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */ MotionValue.prototype.attach = function(passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */ MotionValue.prototype.set = function(v, render) {\n        if (render === void 0) {\n            render = true;\n        }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        } else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */ MotionValue.prototype.get = function() {\n        return this.current;\n    };\n    /**\n     * @public\n     */ MotionValue.prototype.getPrevious = function() {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */ MotionValue.prototype.getVelocity = function() {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity ? popmotion.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */ MotionValue.prototype.start = function(animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function(resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function() {\n            return _this.clearAnimation();\n        });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */ MotionValue.prototype.stop = function() {\n        if (this.stopAnimation) this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */ MotionValue.prototype.isAnimating = function() {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function() {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */ MotionValue.prototype.destroy = function() {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}();\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n/**\n * Tests a provided value against a ValueType\n */ var testValueType = function(v) {\n    return function(type) {\n        return type.test(v);\n    };\n};\n/**\n * ValueType for \"auto\"\n */ var auto = {\n    test: function(v) {\n        return v === \"auto\";\n    },\n    parse: function(v) {\n        return v;\n    }\n};\n/**\n * A list of value types commonly used for dimensions\n */ var dimensionValueTypes = [\n    styleValueTypes.number,\n    styleValueTypes.px,\n    styleValueTypes.percent,\n    styleValueTypes.degrees,\n    styleValueTypes.vw,\n    styleValueTypes.vh,\n    auto\n];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */ var findDimensionValueType = function(v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */ var valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes), false), [\n    styleValueTypes.color,\n    styleValueTypes.complex\n], false);\n/**\n * Tests a value against the list of ValueTypes\n */ var findValueType = function(v) {\n    return valueTypes.find(testValueType(v));\n};\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */ function setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    } else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;\n    _a.transition;\n    var target = tslib.__rest(_a, [\n        \"transitionEnd\",\n        \"transition\"\n    ]);\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n    for(var key in target){\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels), false).reverse();\n    reversedLabels.forEach(function(key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    } else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [\n            definition\n        ]);\n    } else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function(key) {\n        return !visualElement.hasValue(key);\n    });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n    for(var i = 0; i < numNewValues; i++){\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */ if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */ if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */ if (value === undefined || value === null) continue;\n        if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        } else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition) return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for(var key in target){\n        origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    visualElement.notifyAnimationStart(definition);\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function(variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    } else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    } else {\n        var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function() {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) {\n        options = {};\n    }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */ var getAnimation = resolved ? function() {\n        return animateTarget(visualElement, resolved, options);\n    } : function() {\n        return Promise.resolve();\n    };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */ var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {\n        if (forwardDelay === void 0) {\n            forwardDelay = 0;\n        }\n        var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n    } : function() {\n        return Promise.resolve();\n    };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */ var when = transition.when;\n    if (when) {\n        var _c = tslib.__read(when === \"beforeChildren\" ? [\n            getAnimation,\n            getChildAnimations\n        ] : [\n            getChildAnimations,\n            getAnimation\n        ], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    } else {\n        return Promise.all([\n            getAnimation(),\n            getChildAnimations(options.delay)\n        ]);\n    }\n}\n/**\n * @internal\n */ function animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\n        \"transition\",\n        \"transitionEnd\"\n    ]);\n    if (transitionOverride) transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for(var key in target){\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n            continue;\n        }\n        var valueTransition = tslib.__assign({\n            delay: delay\n        }, transition);\n        /**\n         * Make animation instant if this is a transform prop and we should reduce motion.\n         */ if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n            valueTransition = tslib.__assign(tslib.__assign({}, valueTransition), {\n                type: false,\n                delay: 0\n            });\n        }\n        var animation = startAnimation(key, value, valueTarget, valueTransition);\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function() {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) {\n        delayChildren = 0;\n    }\n    if (staggerChildren === void 0) {\n        staggerChildren = 0;\n    }\n    if (staggerDirection === void 0) {\n        staggerDirection = 1;\n    }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function(i) {\n        if (i === void 0) {\n            i = 0;\n        }\n        return i * staggerChildren;\n    } : function(i) {\n        if (i === void 0) {\n            i = 0;\n        }\n        return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), {\n            delay: delayChildren + generateStaggerDuration(i)\n        })).then(function() {\n            return child.notifyAnimationComplete(variant);\n        }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function(value) {\n        return value.stop();\n    });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */ function shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nvar variantPriorityOrder = [\n    exports.AnimationType.Animate,\n    exports.AnimationType.InView,\n    exports.AnimationType.Focus,\n    exports.AnimationType.Hover,\n    exports.AnimationType.Tap,\n    exports.AnimationType.Drag,\n    exports.AnimationType.Exit\n];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder), false).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function(animations) {\n        return Promise.all(animations.map(function(_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */ var buildResolvedTypeValues = function(acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition;\n            var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\n                \"transition\",\n                \"transitionEnd\"\n            ]);\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */ function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */ function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */ var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */ var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */ var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */ var removedVariantIndex = Infinity;\n        var _loop_1 = function(i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */ var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false) removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */ var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */ if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */ typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (// If it isn't active and hasn't *just* been set as inactive\n            !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n            !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n            isAnimationControls(prop) || typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */ var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            var shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n            type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n            i > removedVariantIndex && propIsVariant;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */ var definitionList = Array.isArray(prop) ? prop : [\n                prop\n            ];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */ var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false) resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */ var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function(key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for(var key in allKeys){\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key)) continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */ if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */ if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev) || variantDidChange) {\n                            markToAnimate(key);\n                        } else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */ typeState.protectedKeys[key] = true;\n                        }\n                    } else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    } else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                } else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */ markToAnimate(key);\n                } else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */ typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */ typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */ if (typeState.isActive) {\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */ if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function(animation) {\n                    return {\n                        animation: animation,\n                        options: tslib.__assign({\n                            type: type\n                        }, options)\n                    };\n                })), false));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */ for(var i = 0; i < numAnimationTypes; i++){\n            _loop_1(i);\n        }\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */ if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function(key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({\n                animation: fallbackAnimation_1\n            });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */ function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive) return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {\n            var _a;\n            return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n        });\n        state[type].isActive = isActive;\n        var animations = animateChanges(options, type);\n        for(var key in state){\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function() {\n            return state;\n        }\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    } else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) {\n        isActive = false;\n    }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {}\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {}, _a[exports.AnimationType.Animate] = createTypeState(true), _a[exports.AnimationType.InView] = createTypeState(), _a[exports.AnimationType.Hover] = createTypeState(), _a[exports.AnimationType.Tap] = createTypeState(), _a[exports.AnimationType.Drag] = createTypeState(), _a[exports.AnimationType.Focus] = createTypeState(), _a[exports.AnimationType.Exit] = createTypeState(), _a;\n}\nvar animations = {\n    animation: makeRenderlessComponent(function(_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */ visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */ if (isAnimationControls(animate)) {\n            React.useEffect(function() {\n                return animate.subscribe(visualElement);\n            }, [\n                animate\n            ]);\n        }\n    }),\n    exit: makeRenderlessComponent(function(props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n        var presenceContext = React.useContext(PresenceContext);\n        React.useEffect(function() {\n            var _a, _b;\n            visualElement.isPresent = isPresent;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Exit, !isPresent, {\n                custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom\n            });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));\n        }, [\n            isPresent\n        ]);\n    })\n};\n/**\n * @internal\n */ var PanSession = /** @class */ function() {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */ this.startEvent = null;\n        /**\n         * @internal\n         */ this.lastMoveEvent = null;\n        /**\n         * @internal\n         */ this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */ this.handlers = {};\n        this.updatePoint = function() {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = popmotion.distance(info.offset, {\n                x: 0,\n                y: 0\n            }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold) return;\n            var point = info.point;\n            var timestamp = sync.getFrameData().timestamp;\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), {\n                timestamp: timestamp\n            }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function(event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync__default[\"default\"].update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function(event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1) return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = sync.getFrameData().timestamp;\n        this.history = [\n            tslib.__assign(tslib.__assign({}, point), {\n                timestamp: timestamp\n            })\n        ];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function(handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function() {\n        this.removeListeners && this.removeListeners();\n        sync.cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}();\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? {\n        point: transformPagePoint(info.point)\n    } : info;\n}\nfunction subtractPoint(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1)\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while(i >= 0){\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) {\n        target = 0;\n    }\n    if (maxDistance === void 0) {\n        maxDistance = 0.01;\n    }\n    return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) {\n        origin = 0.5;\n    }\n    delta.origin = origin;\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001) || isNaN(delta.scale)) delta.scale = 1;\n    delta.translate = popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate) || isNaN(delta.translate)) delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n    calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */ function applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n    } else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */ function calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */ function calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */ function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n        _a = tslib.__read([\n            max,\n            min\n        ], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */ function calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */ function calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n    } else if (sourceLength > targetLength) {\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n    }\n    return popmotion.clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */ function rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */ function resolveDragElastic(dragElastic) {\n    if (dragElastic === void 0) {\n        dragElastic = defaultElastic;\n    }\n    if (dragElastic === false) {\n        dragElastic = 0;\n    } else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel)\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\nvar createAxisDelta = function() {\n    return {\n        translate: 0,\n        scale: 1,\n        origin: 0,\n        originPoint: 0\n    };\n};\nvar createDelta = function() {\n    return {\n        x: createAxisDelta(),\n        y: createAxisDelta()\n    };\n};\nvar createAxis = function() {\n    return {\n        min: 0,\n        max: 0\n    };\n};\nvar createBox = function() {\n    return {\n        x: createAxis(),\n        y: createAxis()\n    };\n};\nfunction eachAxis(callback) {\n    return [\n        callback(\"x\"),\n        callback(\"y\")\n    ];\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */ function convertBoundingBoxToBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: {\n            min: left,\n            max: right\n        },\n        y: {\n            min: top,\n            max: bottom\n        }\n    };\n}\nfunction convertBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        right: x.max,\n        bottom: y.max,\n        left: x.min\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */ function transformBoxPoints(point, transformPoint) {\n    if (!transformPoint) return point;\n    var topLeft = transformPoint({\n        x: point.left,\n        y: point.top\n    });\n    var bottomRight = transformPoint({\n        x: point.right,\n        y: point.bottom\n    });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n    };\n}\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale(_a) {\n    var scale = _a.scale, scaleX = _a.scaleX, scaleY = _a.scaleY;\n    return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n    return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction hasTranslate(value) {\n    return value && value !== \"0%\";\n}\n/**\n * Scales a point based on a factor and an originPoint\n */ function scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */ function applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */ function applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (scale === void 0) {\n        scale = 1;\n    }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */ function applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */ function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\n    var _a, _b;\n    if (isSharedTransition === void 0) {\n        isSharedTransition = false;\n    }\n    var treeLength = treePath.length;\n    if (!treeLength) return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for(var i = 0; i < treeLength; i++){\n        node = treePath[i];\n        delta = node.projectionDelta;\n        if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === \"contents\") continue;\n        if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.x,\n                y: -node.scroll.y\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */ function transformAxis(axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */ var xKeys$1 = [\n    \"x\",\n    \"scaleX\",\n    \"originX\"\n];\nvar yKeys$1 = [\n    \"y\",\n    \"scaleY\",\n    \"originY\"\n];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */ function transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys$1);\n    transformAxis(box.y, transform, yKeys$1);\n}\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    var viewportBox = measureViewportBox(element, transformPagePoint);\n    var scroll = rootProjectionNode.scroll;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.x);\n        translateAxis(viewportBox.y, scroll.y);\n    }\n    return viewportBox;\n}\nvar elementDragControls = new WeakMap();\n/**\n *\n */ // let latestPointerEvent: AnyPointerEvent\nvar VisualElementDragControls = /** @class */ function() {\n    function VisualElementDragControls(visualElement) {\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = {\n            x: 0,\n            y: 0\n        };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */ this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */ this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    VisualElementDragControls.prototype.start = function(originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;\n        /**\n         * Don't start dragging if this component is exiting\n         */ if (this.visualElement.isPresent === false) return;\n        var onSessionStart = function(event) {\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopAnimation();\n            if (snapToCursor) {\n                _this.snapToCursor(extractEventInfo(event, \"page\").point);\n            }\n        };\n        var onStart = function(event, info) {\n            var _a;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _b = _this.getProps(), drag = _b.drag, dragPropagation = _b.dragPropagation, onDragStart = _b.onDragStart;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock) _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock) return;\n            }\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            _this.resolveConstraints();\n            if (_this.visualElement.projection) {\n                _this.visualElement.projection.isAnimationBlocked = true;\n                _this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */ eachAxis(function(axis) {\n                var _a, _b;\n                var current = _this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */ if (styleValueTypes.percent.test(current)) {\n                    var measuredAxis = (_b = (_a = _this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];\n                    if (measuredAxis) {\n                        var length_1 = calcLength(measuredAxis);\n                        current = length_1 * (parseFloat(current) / 100);\n                    }\n                }\n                _this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n            (_a = _this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(exports.AnimationType.Drag, true);\n        };\n        var onMove = function(event, info) {\n            // latestPointerEvent = event\n            var _a = _this.getProps(), dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock, onDirectionLock = _a.onDirectionLock, onDrag = _a.onDrag;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock) return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */ _this.visualElement.syncRender();\n            /**\n             * This must fire after the syncRender call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */ onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n        };\n        var onSessionEnd = function(event, info) {\n            return _this.stop(event, info);\n        };\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint()\n        });\n    };\n    VisualElementDragControls.prototype.stop = function(event, info) {\n        var isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging) return;\n        var velocity = info.velocity;\n        this.startAnimation(velocity);\n        var onDragEnd = this.getProps().onDragEnd;\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n    };\n    VisualElementDragControls.prototype.cancel = function() {\n        var _a, _b;\n        this.isDragging = false;\n        if (this.visualElement.projection) {\n            this.visualElement.projection.isAnimationBlocked = false;\n        }\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = undefined;\n        var dragPropagation = this.getProps().dragPropagation;\n        if (!dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(exports.AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.updateAxis = function(axis, _point, offset) {\n        var drag = this.getProps().drag;\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;\n        var axisValue = this.getAxisMotionValue(axis);\n        var next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    };\n    VisualElementDragControls.prototype.resolveConstraints = function() {\n        var _this = this;\n        var _a = this.getProps(), dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = (this.visualElement.projection || {}).layout;\n        var prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        } else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);\n            } else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */ if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function(axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function() {\n        var _a = this.getProps(), constraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints;\n        if (!constraints || !isRefObject(constraints)) return false;\n        var constraintsElement = constraints.current;\n        heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        var projection = this.visualElement.projection;\n        // TODO\n        if (!projection || !projection.layout) return false;\n        var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */ if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.startAnimation = function(velocity) {\n        var _this = this;\n        var _a = this.getProps(), drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, dragSnapToOrigin = _a.dragSnapToOrigin, onDragTransitionEnd = _a.onDragTransitionEnd;\n        var constraints = this.constraints || {};\n        var momentumAnimations = eachAxis(function(axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            if (dragSnapToOrigin) transition = {\n                min: 0,\n                max: 0\n            };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */ var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = tslib.__assign(tslib.__assign({\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10\n            }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function(axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.stopAnimation = function() {\n        var _this = this;\n        eachAxis(function(axis) {\n            return _this.getAxisMotionValue(axis).stop();\n        });\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */ VisualElementDragControls.prototype.getAxisMotionValue = function(axis) {\n        var _a, _b;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        var externalMotionValue = this.visualElement.getProps()[dragKey];\n        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function(point) {\n        var _this = this;\n        eachAxis(function(axis) {\n            var drag = _this.getProps().drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection)) return;\n            var projection = _this.visualElement.projection;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                var _a = projection.layout.actual[axis], min = _a.min, max = _a.max;\n                axisValue.set(point[axis] - popmotion.mix(min, max, 0.5));\n            }\n        });\n    };\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */ VisualElementDragControls.prototype.scalePositionWithinConstraints = function() {\n        var _this = this;\n        var _a;\n        var _b = this.getProps(), drag = _b.drag, dragConstraints = _b.dragConstraints;\n        var projection = this.visualElement.projection;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */ this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */ var boxProgress = {\n            x: 0,\n            y: 0\n        };\n        eachAxis(function(axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({\n                    min: latest,\n                    max: latest\n                }, _this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */ var transformTemplate = this.visualElement.getProps().transformTemplate;\n        this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n        (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */ eachAxis(function(axis) {\n            if (!shouldDrag(axis, drag, null)) return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */ var axisValue = _this.getAxisMotionValue(axis);\n            var _a = _this.constraints[axis], min = _a.min, max = _a.max;\n            axisValue.set(popmotion.mix(min, max, boxProgress[axis]));\n        });\n    };\n    VisualElementDragControls.prototype.addListeners = function() {\n        var _this = this;\n        var _a;\n        elementDragControls.set(this.visualElement, this);\n        var element = this.visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */ var stopPointerListener = addPointerEvent(element, \"pointerdown\", function(event) {\n            var _a = _this.getProps(), drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        var measureDragConstraints = function() {\n            var dragConstraints = _this.getProps().dragConstraints;\n            if (isRefObject(dragConstraints)) {\n                _this.constraints = _this.resolveRefConstraints();\n            }\n        };\n        var projection = this.visualElement.projection;\n        var stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n            projection.updateLayout();\n        }\n        measureDragConstraints();\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */ var stopResizeListener = addDomEvent(window, \"resize\", function() {\n            return _this.scalePositionWithinConstraints();\n        });\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */ projection.addEventListener(\"didUpdate\", function(_a) {\n            var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged;\n            if (_this.isDragging && hasLayoutChanged) {\n                eachAxis(function(axis) {\n                    var motionValue = _this.getAxisMotionValue(axis);\n                    if (!motionValue) return;\n                    _this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                _this.visualElement.syncRender();\n            }\n        });\n        return function() {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n        };\n    };\n    VisualElementDragControls.prototype.getProps = function() {\n        var props = this.visualElement.getProps();\n        var _a = props.drag, drag = _a === void 0 ? false : _a, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e = props.dragElastic, dragElastic = _e === void 0 ? defaultElastic : _e, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;\n        return tslib.__assign(tslib.__assign({}, props), {\n            drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum\n        });\n    };\n    return VisualElementDragControls;\n}();\nfunction shouldDrag(direction, drag, currentDirection) {\n    return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */ function getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) {\n        lockThreshold = 10;\n    }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    } else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */ function useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var dragControls = useConstant(function() {\n        return new VisualElementDragControls(visualElement);\n    });\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    React.useEffect(function() {\n        return groupDragControls && groupDragControls.subscribe(dragControls);\n    }, [\n        dragControls,\n        groupDragControls\n    ]);\n    // Apply the event listeners to the element\n    React.useEffect(function() {\n        return dragControls.addListeners();\n    }, [\n        dragControls\n    ]);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @privateRemarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */ function usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = React.useRef(null);\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function(event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        }\n    };\n    React.useEffect(function() {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint\n        });\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function() {\n        return panSession.current && panSession.current.end();\n    });\n}\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag)\n};\nvar names = [\n    \"LayoutMeasure\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutUpdate\",\n    \"ViewportBoxUpdate\",\n    \"Update\",\n    \"Render\",\n    \"AnimationComplete\",\n    \"LayoutAnimationComplete\",\n    \"AnimationStart\",\n    \"LayoutAnimationStart\",\n    \"SetAxisTarget\",\n    \"Unmount\"\n];\nfunction createLifecycles() {\n    var managers = names.map(function() {\n        return new SubscriptionManager();\n    });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function() {\n            return managers.forEach(function(manager) {\n                return manager.clear();\n            });\n        },\n        updatePropListeners: function(props) {\n            names.forEach(function(name) {\n                var _a;\n                var on = \"on\" + name;\n                var propListener = props[on];\n                // Unsubscribe existing subscription\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                // Add new subscription\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        }\n    };\n    managers.forEach(function(manager, i) {\n        lifecycles[\"on\" + names[i]] = function(handler) {\n            return manager.add(handler);\n        };\n        lifecycles[\"notify\" + names[i]] = function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args), false));\n        };\n    });\n    return lifecycles;\n}\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for(var key in next){\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */ element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */ if (true) {\n                warnOnce(nextValue.version === \"6.5.1\", \"Attempting to mix Framer Motion versions \".concat(nextValue.version, \" with 6.5.1 may not work as expected.\"));\n            }\n        } else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping to a new motion value, create a new motion value\n             * from that\n             */ element.addValue(key, motionValue(nextValue));\n        } else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */ if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            } else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for(var key in prev){\n        if (next[key] === undefined) element.removeValue(key);\n    }\n    return next;\n}\nvar visualElement = function(_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function(_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState, shouldReduceMotion = _a.shouldReduceMotion;\n        if (options === void 0) {\n            options = {};\n        }\n        var isMounted = false;\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */ var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender\n         */ var lifecycles = createLifecycles();\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */ var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */ var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */ var prevMotionValues = {};\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */ var baseTarget = tslib.__assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */ var removeFromVariantTree;\n        /**\n         * Render the element with the latest styles outside of the React\n         * render lifecycle\n         */ function render() {\n            if (!instance || !isMounted) return;\n            triggerBuild();\n            renderInstance(instance, renderState, props.style, element.projection);\n        }\n        function triggerBuild() {\n            build(element, renderState, latestValues, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        /**\n         *\n         */ function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function(latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync__default[\"default\"].update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function() {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */ var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for(var key in initialMotionValues){\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */ var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = tslib.__assign(tslib.__assign({\n            treeType: treeType,\n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */ current: null,\n            /**\n             * The depth of this visual element within the visual element tree.\n             */ depth: parent ? parent.depth + 1 : 0,\n            parent: parent,\n            children: new Set(),\n            /**\n             *\n             */ presenceId: presenceId,\n            shouldReduceMotion: shouldReduceMotion,\n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */ variantChildren: isVariantNode ? new Set() : undefined,\n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by the projection tree, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */ isVisible: undefined,\n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */ manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */ blockInitialAnimation: blockInitialAnimation,\n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */ isMounted: function() {\n                return Boolean(instance);\n            },\n            mount: function(newInstance) {\n                isMounted = true;\n                instance = element.current = newInstance;\n                if (element.projection) {\n                    element.projection.mount(newInstance);\n                }\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                values.forEach(function(value, key) {\n                    return bindToMotionValue(key, value);\n                });\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n                element.setProps(props);\n            },\n            /**\n             *\n             */ unmount: function() {\n                var _a;\n                (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n                sync.cancelSync.update(update);\n                sync.cancelSync.render(render);\n                valueSubscriptions.forEach(function(remove) {\n                    return remove();\n                });\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                lifecycles.clearAllListeners();\n                instance = undefined;\n                isMounted = false;\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */ addVariantChild: function(child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function() {\n                        return closestVariantNode.variantChildren.delete(child);\n                    };\n                }\n            },\n            sortNodePosition: function(other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */ if (!sortNodePosition || treeType !== other.treeType) return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            },\n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */ getClosestVariantNode: function() {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            },\n            /**\n             * Expose the latest layoutId prop.\n             */ getLayoutId: function() {\n                return props.layoutId;\n            },\n            /**\n             * Returns the current instance.\n             */ getInstance: function() {\n                return instance;\n            },\n            /**\n             * Get/set the latest static values.\n             */ getStaticValue: function(key) {\n                return latestValues[key];\n            },\n            setStaticValue: function(key, value) {\n                return latestValues[key] = value;\n            },\n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */ getLatestValues: function() {\n                return latestValues;\n            },\n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */ setVisibility: function(visibility) {\n                if (element.isVisible === visibility) return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */ makeTargetAnimatable: function(target, canMutate) {\n                if (canMutate === void 0) {\n                    canMutate = true;\n                }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */ measureViewportBox: function() {\n                return measureViewportBox(instance, props);\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */ addValue: function(key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key)) element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */ removeValue: function(key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            },\n            /**\n             * Check whether we have a motion value for this key\n             */ hasValue: function(key) {\n                return values.has(key);\n            },\n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */ getValue: function(key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            },\n            /**\n             * Iterate over our motion values.\n             */ forEachValue: function(callback) {\n                return values.forEach(callback);\n            },\n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */ readValue: function(key) {\n                var _a;\n                return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n            },\n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */ setBaseTarget: function(key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */ getBaseTarget: function(key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target)) return target;\n                }\n                return baseTarget[key];\n            }\n        }, lifecycles), {\n            /**\n             * Build the renderer state based on the latest visual state.\n             */ build: function() {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */ scheduleRender: function() {\n                sync__default[\"default\"].render(render, false, true);\n            },\n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */ syncRender: render,\n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */ setProps: function(newProps) {\n                if (newProps.transformTemplate || props.transformTemplate) {\n                    element.scheduleRender();\n                }\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            },\n            getProps: function() {\n                return props;\n            },\n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */ getVariant: function(name) {\n                var _a;\n                return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n            },\n            /**\n             * Returns the defined default transition on this component.\n             */ getDefaultTransition: function() {\n                return props.transition;\n            },\n            getTransformPagePoint: function() {\n                return props.transformPagePoint;\n            },\n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */ getVariantContext: function(startAtParent) {\n                if (startAtParent === void 0) {\n                    startAtParent = false;\n                }\n                if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for(var i = 0; i < numVariantProps; i++){\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            }\n        });\n        return element;\n    };\n};\nvar variantProps = tslib.__spreadArray([\n    \"initial\"\n], tslib.__read(variantPriorityOrder), false);\nvar numVariantProps = variantProps.length;\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */ var cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match) return [\n        , \n    ];\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\n    return [\n        token,\n        fallback\n    ];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) {\n        depth = 1;\n    }\n    heyListen.invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property \"'.concat(current, '\". This may indicate a circular fallback dependency.'));\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token) return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    } else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    } else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */ function resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = tslib.__rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof Element)) return {\n        target: target,\n        transitionEnd: transitionEnd\n    };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = tslib.__assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function(value) {\n        var current = value.get();\n        if (!isCSSVariable(current)) return;\n        var resolved = getVariableValue(current, element);\n        if (resolved) value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for(var key in target){\n        var current = target[key];\n        if (!isCSSVariable(current)) continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved) continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;\n    }\n    return {\n        target: target,\n        transitionEnd: transitionEnd\n    };\n}\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\"\n]);\nvar isPositionalKey = function(key) {\n    return positionalKeys.has(key);\n};\nvar hasPositionalKey = function(target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function(value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function(v) {\n    return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function(matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function(pos2, pos3) {\n    return function(_bbox, _a) {\n        var transform = _a.transform;\n        if (transform === \"none\" || !transform) return 0;\n        var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n        if (matrix3d) {\n            return getPosFromMatrix(matrix3d[1], pos3);\n        } else {\n            var matrix = transform.match(/^matrix\\((.+)\\)$/);\n            if (matrix) {\n                return getPosFromMatrix(matrix[1], pos2);\n            } else {\n                return 0;\n            }\n        }\n    };\n};\nvar transformKeys = new Set([\n    \"x\",\n    \"y\",\n    \"z\"\n]);\nvar nonTranslationalTransformKeys = transformProps.filter(function(key) {\n    return !transformKeys.has(key);\n});\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function(key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([\n                key,\n                value.get()\n            ]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length) visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function(_a, _b) {\n        var x = _a.x;\n        var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? \"0\" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? \"0\" : _d;\n        return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n    },\n    height: function(_a, _b) {\n        var y = _a.y;\n        var _c = _b.paddingTop, paddingTop = _c === void 0 ? \"0\" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? \"0\" : _d;\n        return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n    },\n    top: function(_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function(_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function(_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function(_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function(target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display;\n    var origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */ changedKeys.forEach(function(key) {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function(key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function(visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) {\n        origin = {};\n    }\n    if (transitionEnd === void 0) {\n        transitionEnd = {};\n    }\n    target = tslib.__assign({}, target);\n    transitionEnd = tslib.__assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function(key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key)) return;\n        var from = origin[key];\n        var fromType = findDimensionValueType(from);\n        var to = target[key];\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            var fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for(var i = fromIndex; i < numKeyframes; i++){\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    heyListen.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n                } else {\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        } else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                } else if (Array.isArray(to) && toType === styleValueTypes.px) {\n                    target[key] = to.map(parseFloat);\n                }\n            } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                } else {\n                    target[key] = fromType.transform(to);\n                }\n            } else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var scrollY_1 = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function(_a) {\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        // Restore scroll position\n        if (scrollY_1 !== null) window.scrollTo({\n            top: scrollY_1\n        });\n        return {\n            target: convertedTarget,\n            transitionEnd: transitionEnd\n        };\n    } else {\n        return {\n            target: target,\n            transitionEnd: transitionEnd\n        };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */ function unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n        target: target,\n        transitionEnd: transitionEnd\n    };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */ var parseDomVariant = function(visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function(domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        } else {\n            var computedStyle = getComputedStyle$1(domElement);\n            return (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n        }\n    },\n    sortNodePosition: function(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */ return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function(props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function(element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return measureViewportBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */ resetTransform: function(element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function(instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function(key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */ makeTargetAnimatable: function(element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) {\n            isMounted = true;\n        }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\n            \"transition\",\n            \"transitionEnd\"\n        ]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */ if (transformValues) {\n            if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n            if (target) target = transformValues(target);\n            if (origin) origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return tslib.__assign({\n            transition: transition,\n            transitionEnd: transitionEnd\n        }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    build: function(element, renderState, latestValues, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n        }\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), {\n    getBaseTarget: function(props, key) {\n        return props[key];\n    },\n    readValueFromInstance: function(domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function(_element, renderState, latestValues, options, props) {\n        buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderSVG\n}));\nvar createDomVisualElement = function(Component, options) {\n    return isSVGComponent(Component) ? svgVisualElement(options, {\n        enableHardwareAcceleration: false\n    }) : htmlVisualElement(options, {\n        enableHardwareAcceleration: true\n    });\n};\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min) return 0;\n    return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */ var correctBorderRadius = {\n    correct: function(latest, node) {\n        if (!node.target) return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */ if (typeof latest === \"string\") {\n            if (styleValueTypes.px.test(latest)) {\n                latest = parseFloat(latest);\n            } else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */ var x = pixelsToPercent(latest, node.target.x);\n        var y = pixelsToPercent(latest, node.target.y);\n        return \"\".concat(x, \"% \").concat(y, \"%\");\n    }\n};\nvar varToken = \"_$css\";\nvar correctBoxShadow = {\n    correct: function(latest, _a) {\n        var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;\n        var original = latest;\n        /**\n         * We need to first strip and store CSS variables from the string.\n         */ var containsCSSVariables = latest.includes(\"var(\");\n        var cssVariables = [];\n        if (containsCSSVariables) {\n            latest = latest.replace(cssVariableRegex, function(match) {\n                cssVariables.push(match);\n                return varToken;\n            });\n        }\n        var shadow = styleValueTypes.complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5) return original;\n        var template = styleValueTypes.complex.createTransformer(latest);\n        var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        var xScale = projectionDelta.x.scale * treeScale.x;\n        var yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */ var averageScale = popmotion.mix(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n        var output = template(shadow);\n        if (containsCSSVariables) {\n            var i_1 = 0;\n            output = output.replace(varToken, function() {\n                var cssVariable = cssVariables[i_1];\n                i_1++;\n                return cssVariable;\n            });\n        }\n        return output;\n    }\n};\nvar MeasureLayoutWithContext = /** @class */ function(_super) {\n    tslib.__extends(MeasureLayoutWithContext, _super);\n    function MeasureLayoutWithContext() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */ MeasureLayoutWithContext.prototype.componentDidMount = function() {\n        var _this = this;\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, switchLayoutGroup = _a.switchLayoutGroup, layoutId = _a.layoutId;\n        var projection = visualElement.projection;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.add(projection);\n            if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", function() {\n                _this.safeToRemove();\n            });\n            projection.setOptions(tslib.__assign(tslib.__assign({}, projection.options), {\n                onExitComplete: function() {\n                    return _this.safeToRemove();\n                }\n            }));\n        }\n        globalProjectionState.hasEverUpdated = true;\n    };\n    MeasureLayoutWithContext.prototype.getSnapshotBeforeUpdate = function(prevProps) {\n        var _this = this;\n        var _a = this.props, layoutDependency = _a.layoutDependency, visualElement = _a.visualElement, drag = _a.drag, isPresent = _a.isPresent;\n        var projection = visualElement.projection;\n        if (!projection) return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */ projection.isPresent = isPresent;\n        if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n            projection.willUpdate();\n        } else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            } else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */ sync__default[\"default\"].postRender(function() {\n                    var _a;\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n                        _this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    };\n    MeasureLayoutWithContext.prototype.componentDidUpdate = function() {\n        var projection = this.props.visualElement.projection;\n        if (projection) {\n            projection.root.didUpdate();\n            if (!projection.currentAnimation && projection.isLead()) {\n                this.safeToRemove();\n            }\n        }\n    };\n    MeasureLayoutWithContext.prototype.componentWillUnmount = function() {\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, promoteContext = _a.switchLayoutGroup;\n        var projection = visualElement.projection;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n        }\n    };\n    MeasureLayoutWithContext.prototype.safeToRemove = function() {\n        var safeToRemove = this.props.safeToRemove;\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n    };\n    MeasureLayoutWithContext.prototype.render = function() {\n        return null;\n    };\n    return MeasureLayoutWithContext;\n}(React__default[\"default\"].Component);\nfunction MeasureLayout(props) {\n    var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n    var layoutGroup = React.useContext(LayoutGroupContext);\n    return React__default[\"default\"].createElement(MeasureLayoutWithContext, tslib.__assign({}, props, {\n        layoutGroup: layoutGroup,\n        switchLayoutGroup: React.useContext(SwitchLayoutGroupContext),\n        isPresent: isPresent,\n        safeToRemove: safeToRemove\n    }));\n}\nvar defaultScaleCorrectors = {\n    borderRadius: tslib.__assign(tslib.__assign({}, correctBorderRadius), {\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\"\n        ]\n    }),\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow\n};\nvar layoutFeatures = {\n    measureLayout: MeasureLayout\n};\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */ function animate(from, to, transition) {\n    if (transition === void 0) {\n        transition = {};\n    }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function() {\n            return value.stop();\n        },\n        isAnimating: function() {\n            return value.isAnimating();\n        }\n    };\n}\nvar borders = [\n    \"TopLeft\",\n    \"TopRight\",\n    \"BottomLeft\",\n    \"BottomRight\"\n];\nvar numBorders = borders.length;\nvar asNumber = function(value) {\n    return typeof value === \"string\" ? parseFloat(value) : value;\n};\nvar isPx = function(value) {\n    return typeof value === \"number\" || styleValueTypes.px.test(value);\n};\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    var _a, _b, _c, _d;\n    if (shouldCrossfadeOpacity) {\n        target.opacity = popmotion.mix(0, // (follow?.opacity as number) ?? 0,\n        // TODO Reinstate this if only child\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n        target.opacityExit = popmotion.mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n    } else if (isOnlyMember) {\n        target.opacity = popmotion.mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */ for(var i = 0; i < numBorders; i++){\n        var borderLabel = \"border\".concat(borders[i], \"Radius\");\n        var followRadius = getRadius(follow, borderLabel);\n        var leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined) continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(popmotion.mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (styleValueTypes.percent.test(leadRadius) || styleValueTypes.percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        } else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */ if (follow.rotate || lead.rotate) {\n        target.rotate = popmotion.mix(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n    return function(p) {\n        // Could replace ifs with clamp\n        if (p < min) return 0;\n        if (p > max) return 1;\n        return easing(popmotion.progress(min, max, p));\n    };\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */ function copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */ function removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */ function removeAxisDelta(axis, translate, scale, origin, boxScale, originAxis, sourceAxis) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (scale === void 0) {\n        scale = 1;\n    }\n    if (origin === void 0) {\n        origin = 0.5;\n    }\n    if (originAxis === void 0) {\n        originAxis = axis;\n    }\n    if (sourceAxis === void 0) {\n        sourceAxis = axis;\n    }\n    if (styleValueTypes.percent.test(translate)) {\n        translate = parseFloat(translate);\n        var relativeProgress = popmotion.mix(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\") return;\n    var originPoint = popmotion.mix(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis) originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */ function removeAxisTransforms(axis, transforms, _a, origin, sourceAxis) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */ var xKeys = [\n    \"x\",\n    \"scaleX\",\n    \"originX\"\n];\nvar yKeys = [\n    \"y\",\n    \"scaleY\",\n    \"originY\"\n];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */ function removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a, b) {\n    return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;\n}\nvar NodeStack = /** @class */ function() {\n    function NodeStack() {\n        this.members = [];\n    }\n    NodeStack.prototype.add = function(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    };\n    NodeStack.prototype.remove = function(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            var prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    };\n    NodeStack.prototype.relegate = function(node) {\n        var indexOfNode = this.members.findIndex(function(member) {\n            return node === member;\n        });\n        if (indexOfNode === 0) return false;\n        /**\n         * Find the next projection node that is present\n         */ var prevLead;\n        for(var i = indexOfNode; i >= 0; i--){\n            var member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        } else {\n            return false;\n        }\n    };\n    NodeStack.prototype.promote = function(node, preserveFollowOpacity) {\n        var _a;\n        var prevLead = this.lead;\n        if (node === prevLead) return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n                node.snapshot.isShared = true;\n            }\n            if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            var crossfade = node.options.crossfade;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n        /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */ }\n    };\n    NodeStack.prototype.exitAnimationComplete = function() {\n        this.members.forEach(function(node) {\n            var _a, _b, _c, _d, _e;\n            (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n        });\n    };\n    NodeStack.prototype.scheduleRender = function() {\n        this.members.forEach(function(node) {\n            node.instance && node.scheduleRender(false);\n        });\n    };\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */ NodeStack.prototype.removeLeadSnapshot = function() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    };\n    return NodeStack;\n}();\nvar identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */ var xTranslate = delta.x.translate / treeScale.x;\n    var yTranslate = delta.y.translate / treeScale.y;\n    var transform = \"translate3d(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px, 0) \");\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */ transform += \"scale(\".concat(1 / treeScale.x, \", \").concat(1 / treeScale.y, \") \");\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate) transform += \"rotate(\".concat(rotate, \"deg) \");\n        if (rotateX) transform += \"rotateX(\".concat(rotateX, \"deg) \");\n        if (rotateY) transform += \"rotateY(\".concat(rotateY, \"deg) \");\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */ var elementScaleX = delta.x.scale * treeScale.x;\n    var elementScaleY = delta.y.scale * treeScale.y;\n    transform += \"scale(\".concat(elementScaleX, \", \").concat(elementScaleY, \")\");\n    return transform === identityProjection ? \"none\" : transform;\n}\nvar compareByDepth = function(a, b) {\n    return a.depth - b.depth;\n};\nvar FlatTree = /** @class */ function() {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}();\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */ var animationTarget = 1000;\nfunction createProjectionNode(_a) {\n    var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, checkIsScrollRoot = _a.checkIsScrollRoot, resetTransform = _a.resetTransform;\n    return /** @class */ function() {\n        function ProjectionNode(id, latestValues, parent) {\n            var _this = this;\n            if (latestValues === void 0) {\n                latestValues = {};\n            }\n            if (parent === void 0) {\n                parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();\n            }\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */ this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */ this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */ this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */ this.isLayoutDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */ this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */ this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */ this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */ this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */ this.shouldResetTransform = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to actually\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */ this.treeScale = {\n                x: 1,\n                y: 1\n            };\n            /**\n             *\n             */ this.eventHandlers = new Map();\n            // Note: Currently only running on root node\n            this.potentialNodes = new Map();\n            this.checkUpdateFailed = function() {\n                if (_this.isUpdating) {\n                    _this.isUpdating = false;\n                    _this.clearAllSnapshots();\n                }\n            };\n            this.updateProjection = function() {\n                _this.nodes.forEach(resolveTargetDelta);\n                _this.nodes.forEach(calcProjection);\n            };\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */ // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.id = id;\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path), false), [\n                parent\n            ], false) : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            id && this.root.registerPotentialNode(id, this);\n            for(var i = 0; i < this.path.length; i++){\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this) this.nodes = new FlatTree();\n        }\n        ProjectionNode.prototype.addEventListener = function(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        };\n        ProjectionNode.prototype.notifyListeners = function(name) {\n            var args = [];\n            for(var _i = 1; _i < arguments.length; _i++){\n                args[_i - 1] = arguments[_i];\n            }\n            var subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, tslib.__spreadArray([], tslib.__read(args), false));\n        };\n        ProjectionNode.prototype.hasListeners = function(name) {\n            return this.eventHandlers.has(name);\n        };\n        ProjectionNode.prototype.registerPotentialNode = function(id, node) {\n            this.potentialNodes.set(id, node);\n        };\n        /**\n         * Lifecycles\n         */ ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {\n            var _this = this;\n            var _a;\n            if (isLayoutDirty === void 0) {\n                isLayoutDirty = false;\n            }\n            if (this.instance) return;\n            this.isSVG = instance instanceof SVGElement && instance.tagName !== \"svg\";\n            this.instance = instance;\n            var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement = _b.visualElement;\n            if (visualElement && !visualElement.getInstance()) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n            this.id && this.root.potentialNodes.delete(this.id);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                var unblockTimeout_1;\n                var resizeUnblockUpdate_1 = function() {\n                    return _this.root.updateBlockedByResize = false;\n                };\n                attachResizeListener(instance, function() {\n                    _this.root.updateBlockedByResize = true;\n                    clearTimeout(unblockTimeout_1);\n                    unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        _this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false && visualElement && (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", function(_a) {\n                    var _b, _c, _d, _e, _f;\n                    var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged, hasRelativeTargetChanged = _a.hasRelativeTargetChanged, newLayout = _a.layout;\n                    if (_this.isTreeAnimationBlocked()) {\n                        _this.target = undefined;\n                        _this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    var layoutTransition = (_c = (_b = _this.options.transition) !== null && _b !== void 0 ? _b : visualElement.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;\n                    var _g = visualElement.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */ var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */ var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {\n                        if (_this.resumeFrom) {\n                            _this.resumingFrom = _this.resumeFrom;\n                            _this.resumingFrom.resumingFrom = undefined;\n                        }\n                        _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        var animationOptions = tslib.__assign(tslib.__assign({}, getValueTransition(layoutTransition, \"layout\")), {\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete\n                        });\n                        if (visualElement.shouldReduceMotion) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        _this.startAnimation(animationOptions);\n                    } else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */ if (!hasLayoutChanged && _this.animationProgress === 0) {\n                            _this.finishAnimation();\n                        }\n                        _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));\n                    }\n                    _this.targetLayout = newLayout;\n                });\n            }\n        };\n        ProjectionNode.prototype.unmount = function() {\n            var _a, _b;\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n            (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n            this.instance = undefined;\n            sync.cancelSync.preRender(this.updateProjection);\n        };\n        // only on the root\n        ProjectionNode.prototype.blockUpdate = function() {\n            this.updateManuallyBlocked = true;\n        };\n        ProjectionNode.prototype.unblockUpdate = function() {\n            this.updateManuallyBlocked = false;\n        };\n        ProjectionNode.prototype.isUpdateBlocked = function() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        };\n        ProjectionNode.prototype.isTreeAnimationBlocked = function() {\n            var _a;\n            return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;\n        };\n        // Note: currently only running on root node\n        ProjectionNode.prototype.startUpdate = function() {\n            var _a;\n            if (this.isUpdateBlocked()) return;\n            this.isUpdating = true;\n            (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n        };\n        ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {\n            var _a, _b, _c;\n            if (shouldNotifyListeners === void 0) {\n                shouldNotifyListeners = true;\n            }\n            if (this.root.isUpdateBlocked()) {\n                (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n                return;\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty) return;\n            this.isLayoutDirty = true;\n            for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                node.shouldResetTransform = true;\n                /**\n                 * TODO: Check we haven't updated the scroll\n                 * since the last didUpdate\n                 */ node.updateScroll();\n            }\n            var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;\n            if (layoutId === undefined && !layout) return;\n            var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n            this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        };\n        // Note: Currently only running on root node\n        ProjectionNode.prototype.didUpdate = function() {\n            var updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) return;\n            this.isUpdating = false;\n            /**\n             * Search for and mount newly-added projection elements.\n             *\n             * TODO: Every time a new component is rendered we could search up the tree for\n             * the closest mounted node and query from there rather than document.\n             */ if (this.potentialNodes.size) {\n                this.potentialNodes.forEach(mountNodeEarly);\n                this.potentialNodes.clear();\n            }\n            /**\n             * Write\n             */ this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */ // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */ // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            // Flush any scheduled updates\n            sync.flushSync.update();\n            sync.flushSync.preRender();\n            sync.flushSync.render();\n        };\n        ProjectionNode.prototype.clearAllSnapshots = function() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        };\n        ProjectionNode.prototype.scheduleUpdateProjection = function() {\n            sync__default[\"default\"].preRender(this.updateProjection, false, true);\n        };\n        ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {\n            var _this = this;\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */ sync__default[\"default\"].postRender(function() {\n                if (_this.isLayoutDirty) {\n                    _this.root.didUpdate();\n                } else {\n                    _this.root.checkUpdateFailed();\n                }\n            });\n        };\n        /**\n         * Update measurements\n         */ ProjectionNode.prototype.updateSnapshot = function() {\n            if (this.snapshot || !this.instance) return;\n            var measured = this.measure();\n            var layout = this.removeTransform(this.removeElementScroll(measured));\n            roundBox(layout);\n            this.snapshot = {\n                measured: measured,\n                layout: layout,\n                latestValues: {}\n            };\n        };\n        ProjectionNode.prototype.updateLayout = function() {\n            var _a;\n            if (!this.instance) return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */ if (this.resumeFrom && !this.resumeFrom.instance) {\n                for(var i = 0; i < this.path.length; i++){\n                    var node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            var measured = this.measure();\n            roundBox(measured);\n            var prevLayout = this.layout;\n            this.layout = {\n                measured: measured,\n                actual: this.removeElementScroll(measured)\n            };\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.actual);\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);\n        };\n        ProjectionNode.prototype.updateScroll = function() {\n            if (this.options.layoutScroll && this.instance) {\n                this.isScrollRoot = checkIsScrollRoot(this.instance);\n                this.scroll = measureScroll(this.instance);\n            }\n        };\n        ProjectionNode.prototype.resetTransform = function() {\n            var _a;\n            if (!resetTransform) return;\n            var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n            var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, \"\");\n            var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        };\n        ProjectionNode.prototype.measure = function() {\n            var visualElement = this.options.visualElement;\n            if (!visualElement) return createBox();\n            var box = visualElement.measureViewportBox();\n            // Remove viewport scroll to give page-relative coordinates\n            var scroll = this.root.scroll;\n            if (scroll) {\n                translateAxis(box.x, scroll.x);\n                translateAxis(box.y, scroll.y);\n            }\n            return box;\n        };\n        ProjectionNode.prototype.removeElementScroll = function(box) {\n            var boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */ for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;\n                if (node !== this.root && scroll_1 && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */ if (isScrollRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                        var rootScroll = this.root.scroll;\n                        /**\n                         * Undo the application of page scroll that was originally added\n                         * to the measured bounding box.\n                         */ if (rootScroll) {\n                            translateAxis(boxWithoutScroll.x, -rootScroll.x);\n                            translateAxis(boxWithoutScroll.y, -rootScroll.y);\n                        }\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll_1.x);\n                    translateAxis(boxWithoutScroll.y, scroll_1.y);\n                }\n            }\n            return boxWithoutScroll;\n        };\n        ProjectionNode.prototype.applyTransform = function(box, transformOnly) {\n            if (transformOnly === void 0) {\n                transformOnly = false;\n            }\n            var withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.x,\n                        y: -node.scroll.y\n                    });\n                }\n                if (!hasTransform(node.latestValues)) continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        };\n        ProjectionNode.prototype.removeTransform = function(box) {\n            var _a;\n            var boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for(var i = 0; i < this.path.length; i++){\n                var node = this.path[i];\n                if (!node.instance) continue;\n                if (!hasTransform(node.latestValues)) continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                var sourceBox = createBox();\n                var nodeBox = node.measure();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        };\n        /**\n         *\n         */ ProjectionNode.prototype.setTargetDelta = function(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n        };\n        ProjectionNode.prototype.setOptions = function(options) {\n            var _a;\n            this.options = tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), options), {\n                crossfade: (_a = options.crossfade) !== null && _a !== void 0 ? _a : true\n            });\n        };\n        ProjectionNode.prototype.clearMeasurements = function() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        };\n        /**\n         * Frame calculations\n         */ ProjectionNode.prototype.resolveTargetDelta = function() {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */ if (!this.layout || !(layout || layoutId)) return;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */ // TODO If this is unsuccessful this currently happens every frame\n            if (!this.targetDelta && !this.relativeTarget) {\n                // TODO: This is a semi-repetition of further down this function, make DRY\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && this.relativeParent.layout) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */ if (!this.relativeTarget && !this.targetDelta) return;\n            /**\n             * Lazy-init target data structure\n             */ if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */ if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n            /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */ } else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.actual);\n                } else {\n                    copyBoxInto(this.target, this.layout.actual);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            } else {\n                /**\n                 * If no target, use own layout as target\n                 */ copyBoxInto(this.target, this.layout.actual);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */ if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n        };\n        ProjectionNode.prototype.getClosestProjectingParent = function() {\n            if (!this.parent || hasTransform(this.parent.latestValues)) return undefined;\n            if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {\n                return this.parent;\n            } else {\n                return this.parent.getClosestProjectingParent();\n            }\n        };\n        ProjectionNode.prototype.calcProjection = function() {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */ this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId)) return;\n            var lead = this.getLead();\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */ copyBoxInto(this.layoutCorrected, this.layout.actual);\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */ applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n            var target = lead.target;\n            if (!target) return;\n            if (!this.projectionDelta) {\n                this.projectionDelta = createDelta();\n                this.projectionDeltaWithTransform = createDelta();\n            }\n            var prevTreeScaleX = this.treeScale.x;\n            var prevTreeScaleY = this.treeScale.y;\n            var prevProjectionTransform = this.projectionTransform;\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */ calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n            if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n        };\n        ProjectionNode.prototype.hide = function() {\n            this.isVisible = false;\n        // TODO: Schedule render\n        };\n        ProjectionNode.prototype.show = function() {\n            this.isVisible = true;\n        // TODO: Schedule render\n        };\n        ProjectionNode.prototype.scheduleRender = function(notifyAll) {\n            var _a, _b, _c;\n            if (notifyAll === void 0) {\n                notifyAll = true;\n            }\n            (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n            notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        };\n        ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {\n            var _this = this;\n            var _a;\n            if (hasOnlyRelativeTargetChanged === void 0) {\n                hasOnlyRelativeTargetChanged = false;\n            }\n            var snapshot = this.snapshot;\n            var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n            var mixedValues = tslib.__assign({}, this.latestValues);\n            var targetDelta = createDelta();\n            this.relativeTarget = this.relativeTargetOrigin = undefined;\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            var relativeLayout = createBox();\n            var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n            var isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n            var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            this.mixTargetDelta = function(latest) {\n                var _a;\n                var progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                _this.setTargetDelta(targetDelta);\n                if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a = _this.relativeParent) === null || _a === void 0 ? void 0 : _a.layout)) {\n                    calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);\n                    mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress);\n                }\n                if (isSharedLayoutAnimation) {\n                    _this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                _this.root.scheduleUpdateProjection();\n                _this.scheduleRender();\n                _this.animationProgress = progress;\n            };\n            this.mixTargetDelta(0);\n        };\n        ProjectionNode.prototype.startAnimation = function(options) {\n            var _this = this;\n            var _a, _b;\n            this.notifyListeners(\"animationStart\");\n            (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            if (this.resumingFrom) {\n                (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n            }\n            if (this.pendingAnimation) {\n                sync.cancelSync.update(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */ this.pendingAnimation = sync__default[\"default\"].update(function() {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                _this.currentAnimation = animate(0, animationTarget, tslib.__assign(tslib.__assign({}, options), {\n                    onUpdate: function(latest) {\n                        var _a;\n                        _this.mixTargetDelta(latest);\n                        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, latest);\n                    },\n                    onComplete: function() {\n                        var _a;\n                        (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options);\n                        _this.completeAnimation();\n                    }\n                }));\n                if (_this.resumingFrom) {\n                    _this.resumingFrom.currentAnimation = _this.currentAnimation;\n                }\n                _this.pendingAnimation = undefined;\n            });\n        };\n        ProjectionNode.prototype.completeAnimation = function() {\n            var _a;\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n            this.resumingFrom = this.currentAnimation = this.animationValues = undefined;\n            this.notifyListeners(\"animationComplete\");\n        };\n        ProjectionNode.prototype.finishAnimation = function() {\n            var _a;\n            if (this.currentAnimation) {\n                (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        };\n        ProjectionNode.prototype.applyTransformsToTarget = function() {\n            var _a = this.getLead(), targetWithTransforms = _a.targetWithTransforms, target = _a.target, layout = _a.layout, latestValues = _a.latestValues;\n            if (!targetWithTransforms || !target || !layout) return;\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */ transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its actual layout\n             * into the desired bounding box.\n             */ calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        };\n        ProjectionNode.prototype.registerSharedNode = function(layoutId, node) {\n            var _a, _b, _c;\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            var stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            node.promote({\n                transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n                preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)\n            });\n        };\n        ProjectionNode.prototype.isLead = function() {\n            var stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        };\n        ProjectionNode.prototype.getLead = function() {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        };\n        ProjectionNode.prototype.getPrevLead = function() {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        };\n        ProjectionNode.prototype.getStack = function() {\n            var layoutId = this.options.layoutId;\n            if (layoutId) return this.root.sharedNodes.get(layoutId);\n        };\n        ProjectionNode.prototype.promote = function(_a) {\n            var _b = _a === void 0 ? {} : _a, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;\n            var stack = this.getStack();\n            if (stack) stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition) this.setOptions({\n                transition: transition\n            });\n        };\n        ProjectionNode.prototype.relegate = function() {\n            var stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            } else {\n                return false;\n            }\n        };\n        ProjectionNode.prototype.resetRotation = function() {\n            var visualElement = this.options.visualElement;\n            if (!visualElement) return;\n            // If there's no detected rotation values, we can early return without a forced render.\n            var hasRotate = false;\n            // Keep a record of all the values we've reset\n            var resetValues = {};\n            // Check the rotate value of all axes and reset to 0\n            for(var i = 0; i < transformAxes.length; i++){\n                var axis = transformAxes[i];\n                var key = \"rotate\" + axis;\n                // If this rotation doesn't exist as a motion value, then we don't\n                // need to reset it\n                if (!visualElement.getStaticValue(key)) {\n                    continue;\n                }\n                hasRotate = true;\n                // Record the rotation and then temporarily set it to 0\n                resetValues[key] = visualElement.getStaticValue(key);\n                visualElement.setStaticValue(key, 0);\n            }\n            // If there's no rotation values, we don't need to do any more.\n            if (!hasRotate) return;\n            // Force a render of this element to apply the transform with all rotations\n            // set to 0.\n            visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n            // Put back all the values we reset\n            for(var key in resetValues){\n                visualElement.setStaticValue(key, resetValues[key]);\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        };\n        ProjectionNode.prototype.getProjectionStyles = function(styleProp) {\n            var _a, _b, _c, _d, _e, _f;\n            if (styleProp === void 0) {\n                styleProp = {};\n            }\n            // TODO: Return lifecycle-persistent object\n            var styles = {};\n            if (!this.instance || this.isSVG) return styles;\n            if (!this.isVisible) {\n                return {\n                    visibility: \"hidden\"\n                };\n            } else {\n                styles.visibility = \"\";\n            }\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n                return styles;\n            }\n            var lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                var emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;\n                    emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            var valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            var _g = this.projectionDelta, x = _g.x, y = _g.y;\n            styles.transformOrigin = \"\".concat(x.origin * 100, \"% \").concat(y.origin * 100, \"% 0\");\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */ styles.opacity = lead === this ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n            } else {\n                /**\n                 * Or we're not animating at all, set the lead component to its actual\n                 * opacity and other components to hidden.\n                 */ styles.opacity = lead === this ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : \"\" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;\n            }\n            /**\n             * Apply scale correction\n             */ for(var key in scaleCorrectors){\n                if (valuesToRender[key] === undefined) continue;\n                var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;\n                var corrected = correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for(var i = 0; i < num; i++){\n                        styles[applyTo[i]] = corrected;\n                    }\n                } else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */ if (this.options.layoutId) {\n                styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || \"\" : \"none\";\n            }\n            return styles;\n        };\n        ProjectionNode.prototype.clearSnapshot = function() {\n            this.resumeFrom = this.snapshot = undefined;\n        };\n        // Only run on root\n        ProjectionNode.prototype.resetTree = function() {\n            this.root.nodes.forEach(function(node) {\n                var _a;\n                return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        };\n        return ProjectionNode;\n    }();\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a, _b, _c, _d;\n    var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;\n    if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n        var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (node.options.animationType === \"size\") {\n            eachAxis(function(axis) {\n                var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];\n                var length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout_1[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        } else if (node.options.animationType === \"position\") {\n            eachAxis(function(axis) {\n                var axisSnapshot = snapshot.isShared ? snapshot.measured[axis] : snapshot.layout[axis];\n                var length = calcLength(layout_1[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        var layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout_1, snapshot.layout);\n        var visualDelta = createDelta();\n        if (snapshot.isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);\n        } else {\n            calcBoxDelta(visualDelta, layout_1, snapshot.layout);\n        }\n        var hasLayoutChanged = !isDeltaZero(layoutDelta);\n        var hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            node.relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */ if (node.relativeParent && !node.relativeParent.resumeFrom) {\n                var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;\n                if (parentSnapshot && parentLayout) {\n                    var relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);\n                    var relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);\n                    if (!boxEquals(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout: layout_1,\n            snapshot: snapshot,\n            delta: visualDelta,\n            layoutDelta: layoutDelta,\n            hasLayoutChanged: hasLayoutChanged,\n            hasRelativeTargetChanged: hasRelativeTargetChanged\n        });\n    } else if (node.isLead()) {\n        (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */ node.options.transition = undefined;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n    var visualElement = node.options.visualElement;\n    if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notifyBeforeLayoutMeasure();\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetRotation(node) {\n    node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = popmotion.mix(delta.translate, 0, p);\n    output.scale = popmotion.mix(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = popmotion.mix(from.min, to.min, p);\n    output.max = popmotion.mix(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return node.animationValues && node.animationValues.opacityExit !== undefined;\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [\n        0.4,\n        0,\n        0.1,\n        1\n    ]\n};\nfunction mountNodeEarly(node, id) {\n    /**\n     * Rather than searching the DOM from document we can search the\n     * path for the deepest mounted ancestor and search from there\n     */ var searchNode = node.root;\n    for(var i = node.path.length - 1; i >= 0; i--){\n        if (Boolean(node.path[i].instance)) {\n            searchNode = node.path[i];\n            break;\n        }\n    }\n    var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n    var element = searchElement.querySelector('[data-projection-id=\"'.concat(id, '\"]'));\n    if (element) node.mount(element, true);\n}\nfunction roundAxis(axis) {\n    axis.min = Math.round(axis.min);\n    axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nvar DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: function(ref, notify) {\n        return addDomEvent(ref, \"resize\", notify);\n    },\n    measureScroll: function() {\n        return {\n            x: document.documentElement.scrollLeft || document.body.scrollLeft,\n            y: document.documentElement.scrollTop || document.body.scrollTop\n        };\n    },\n    checkIsScrollRoot: function() {\n        return true;\n    }\n});\nvar rootProjectionNode = {\n    current: undefined\n};\nvar HTMLProjectionNode = createProjectionNode({\n    measureScroll: function(instance) {\n        return {\n            x: instance.scrollLeft,\n            y: instance.scrollTop\n        };\n    },\n    defaultParent: function() {\n        if (!rootProjectionNode.current) {\n            var documentNode = new DocumentProjectionNode(0, {});\n            documentNode.mount(window);\n            documentNode.setOptions({\n                layoutScroll: true\n            });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: function(instance, value) {\n        instance.style.transform = value !== null && value !== void 0 ? value : \"none\";\n    },\n    checkIsScrollRoot: function(instance) {\n        return Boolean(window.getComputedStyle(instance).position === \"fixed\");\n    }\n});\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutFeatures);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */ var motion = /*@__PURE__*/ createMotionProxy(function(Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */ function createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, {\n        forwardMotionProps: false\n    }, featureBundle, createDomVisualElement, HTMLProjectionNode));\n}\n/**\n * @public\n */ var m = createMotionProxy(createDomMotionConfig);\nfunction useIsMounted() {\n    var isMounted = React.useRef(false);\n    useIsomorphicLayoutEffect(function() {\n        isMounted.current = true;\n        return function() {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\nfunction useForceUpdate() {\n    var isMounted = useIsMounted();\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    var forceRender = React.useCallback(function() {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [\n        forcedRenderCount\n    ]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */ var deferredForceRender = React.useCallback(function() {\n        return sync__default[\"default\"].postRender(forceRender);\n    }, [\n        forceRender\n    ]);\n    return [\n        deferredForceRender,\n        forcedRenderCount\n    ];\n}\nvar PresenceChild = function(_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useId();\n    var context = React.useMemo(function() {\n        return {\n            id: id,\n            initial: initial,\n            isPresent: isPresent,\n            custom: custom,\n            onExitComplete: function(childId) {\n                var e_1, _a;\n                presenceChildren.set(childId, true);\n                try {\n                    for(var _b = tslib.__values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()){\n                        var isComplete = _c.value;\n                        if (!isComplete) return; // can stop searching when any is incomplete\n                    }\n                } catch (e_1_1) {\n                    e_1 = {\n                        error: e_1_1\n                    };\n                } finally{\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    } finally{\n                        if (e_1) throw e_1.error;\n                    }\n                }\n                onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n            },\n            register: function(childId) {\n                presenceChildren.set(childId, false);\n                return function() {\n                    return presenceChildren.delete(childId);\n                };\n            }\n        };\n    }, /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */ presenceAffectsLayout ? undefined : [\n        isPresent\n    ]);\n    React.useMemo(function() {\n        presenceChildren.forEach(function(_, key) {\n            return presenceChildren.set(key, false);\n        });\n    }, [\n        isPresent\n    ]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */ React__namespace.useEffect(function() {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [\n        isPresent\n    ]);\n    return React__namespace.createElement(PresenceContext.Provider, {\n        value: context\n    }, children);\n};\nfunction newChildrenMap() {\n    return new Map();\n}\nvar getChildKey = function(child) {\n    return child.key || \"\";\n};\nfunction updateChildLookup(children, allChildren) {\n    children.forEach(function(child) {\n        var key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, function(child) {\n        if (React.isValidElement(child)) filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */ var AnimatePresence = function(_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = tslib.__read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = React.useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = React.useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = React.useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = React.useRef(true);\n    useIsomorphicLayoutEffect(function() {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function() {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return React__namespace.createElement(React__namespace.Fragment, null, childrenToRender.map(function(child) {\n            return React__namespace.createElement(PresenceChild, {\n                key: getChildKey(child),\n                isPresent: true,\n                initial: initial ? undefined : false,\n                presenceAffectsLayout: presenceAffectsLayout\n            }, child);\n        }));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = tslib.__spreadArray([], tslib.__read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for(var i = 0; i < numPresent; i++){\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function(key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1) return;\n        var child = allChildren.get(key);\n        if (!child) return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function() {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function(presentChild) {\n                return presentChild.key === key;\n            });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false) return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, {\n            key: getChildKey(child),\n            isPresent: false,\n            onExitComplete: onExit,\n            custom: custom,\n            presenceAffectsLayout: presenceAffectsLayout\n        }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function(child) {\n        var key = child.key;\n        return exiting.has(key) ? child : React__namespace.createElement(PresenceChild, {\n            key: getChildKey(child),\n            isPresent: true,\n            presenceAffectsLayout: presenceAffectsLayout\n        }, child);\n    });\n    if (env !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return React__namespace.createElement(React__namespace.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {\n        return React.cloneElement(child);\n    }));\n};\n/**\n * @deprecated\n */ var DeprecatedLayoutGroupContext = React.createContext(null);\nvar notify = function(node) {\n    return !node.isLayoutDirty && node.willUpdate(false);\n};\nfunction nodeGroup() {\n    var nodes = new Set();\n    var subscriptions = new WeakMap();\n    var dirtyAll = function() {\n        return nodes.forEach(notify);\n    };\n    return {\n        add: function(node) {\n            nodes.add(node);\n            subscriptions.set(node, node.addEventListener(\"willUpdate\", dirtyAll));\n        },\n        remove: function(node) {\n            var _a;\n            nodes.delete(node);\n            (_a = subscriptions.get(node)) === null || _a === void 0 ? void 0 : _a();\n            subscriptions.delete(node);\n            dirtyAll();\n        },\n        dirty: dirtyAll\n    };\n}\nvar shouldInheritGroup = function(inherit) {\n    return inherit === true;\n};\nvar shouldInheritId = function(inherit) {\n    return shouldInheritGroup(inherit === true) || inherit === \"id\";\n};\nvar LayoutGroup = function(_a) {\n    var _b, _c;\n    var children = _a.children, id = _a.id, inheritId = _a.inheritId, _d = _a.inherit, inherit = _d === void 0 ? true : _d;\n    // Maintain backwards-compatibility with inheritId until 7.0\n    if (inheritId !== undefined) inherit = inheritId;\n    var layoutGroupContext = React.useContext(LayoutGroupContext);\n    var deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);\n    var _e = tslib.__read(useForceUpdate(), 2), forceRender = _e[0], key = _e[1];\n    var context = React.useRef(null);\n    var upstreamId = (_b = layoutGroupContext.id) !== null && _b !== void 0 ? _b : deprecatedLayoutGroupContext;\n    if (context.current === null) {\n        if (shouldInheritId(inherit) && upstreamId) {\n            id = id ? upstreamId + \"-\" + id : upstreamId;\n        }\n        context.current = {\n            id: id,\n            group: shouldInheritGroup(inherit) ? (_c = layoutGroupContext === null || layoutGroupContext === void 0 ? void 0 : layoutGroupContext.group) !== null && _c !== void 0 ? _c : nodeGroup() : nodeGroup()\n        };\n    }\n    var memoizedContext = React.useMemo(function() {\n        return tslib.__assign(tslib.__assign({}, context.current), {\n            forceRender: forceRender\n        });\n    }, [\n        key\n    ]);\n    return React__namespace.createElement(LayoutGroupContext.Provider, {\n        value: memoizedContext\n    }, children);\n};\nvar id = 0;\nvar AnimateSharedLayout = function(_a) {\n    var children = _a.children;\n    React__namespace.useEffect(function() {\n        heyListen.warning(false, \"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations\");\n    }, []);\n    return React__namespace.createElement(LayoutGroup, {\n        id: useConstant(function() {\n            return \"asl-\".concat(id++);\n        })\n    }, children);\n};\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */ function MotionConfig(_a) {\n    var children = _a.children, isValidProp = _a.isValidProp, config = tslib.__rest(_a, [\n        \"children\",\n        \"isValidProp\"\n    ]);\n    isValidProp && loadExternalIsValidProp(isValidProp);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */ config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */ config.isStatic = useConstant(function() {\n        return config.isStatic;\n    });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */ var context = React.useMemo(function() {\n        return config;\n    }, [\n        JSON.stringify(config.transition),\n        config.transformPagePoint,\n        config.reducedMotion\n    ]);\n    return React__namespace.createElement(MotionConfigContext.Provider, {\n        value: context\n    }, children);\n}\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */ function LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */ if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\n            \"renderer\"\n        ]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(function() {\n        if (isLazyBundle(features)) {\n            features().then(function(_a) {\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\n                    \"renderer\"\n                ]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return React__namespace.createElement(LazyContext.Provider, {\n        value: {\n            renderer: loadedRenderer.current,\n            strict: strict\n        }\n    }, children);\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\nvar ReorderContext = React.createContext(null);\nfunction checkReorder(order, value, offset, velocity) {\n    if (!velocity) return order;\n    var index = order.findIndex(function(item) {\n        return item.value === value;\n    });\n    if (index === -1) return order;\n    var nextOffset = velocity > 0 ? 1 : -1;\n    var nextItem = order[index + nextOffset];\n    if (!nextItem) return order;\n    var item = order[index];\n    var nextLayout = nextItem.layout;\n    var nextItemCenter = popmotion.mix(nextLayout.min, nextLayout.max, 0.5);\n    if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {\n        return moveItem(order, index, index + nextOffset);\n    }\n    return order;\n}\nfunction ReorderGroup(_a, externalRef) {\n    var children = _a.children, _b = _a.as, as = _b === void 0 ? \"ul\" : _b, _c = _a.axis, axis = _c === void 0 ? \"y\" : _c, onReorder = _a.onReorder, values = _a.values, props = tslib.__rest(_a, [\n        \"children\",\n        \"as\",\n        \"axis\",\n        \"onReorder\",\n        \"values\"\n    ]);\n    var Component = useConstant(function() {\n        return motion(as);\n    });\n    var order = [];\n    var isReordering = React.useRef(false);\n    heyListen.invariant(Boolean(values), \"Reorder.Group must be provided a values prop\");\n    var context = {\n        axis: axis,\n        registerItem: function(value, layout) {\n            /**\n             * Ensure entries can't add themselves more than once\n             */ if (layout && order.findIndex(function(entry) {\n                return value === entry.value;\n            }) === -1) {\n                order.push({\n                    value: value,\n                    layout: layout[axis]\n                });\n                order.sort(compareMin);\n            }\n        },\n        updateOrder: function(id, offset, velocity) {\n            if (isReordering.current) return;\n            var newOrder = checkReorder(order, id, offset, velocity);\n            if (order !== newOrder) {\n                isReordering.current = true;\n                onReorder(newOrder.map(getValue).filter(function(value) {\n                    return values.indexOf(value) !== -1;\n                }));\n            }\n        }\n    };\n    React.useEffect(function() {\n        isReordering.current = false;\n    });\n    return React__namespace.createElement(Component, tslib.__assign({}, props, {\n        ref: externalRef\n    }), React__namespace.createElement(ReorderContext.Provider, {\n        value: context\n    }, children));\n}\nvar Group = React.forwardRef(ReorderGroup);\nfunction getValue(item) {\n    return item.value;\n}\nfunction compareMin(a, b) {\n    return a.layout.min - b.layout.min;\n}\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */ function useMotionValue(initial) {\n    var value = useConstant(function() {\n        return motionValue(initial);\n    });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */ var isStatic = React.useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\n        React.useEffect(function() {\n            return value.onChange(setLatest_1);\n        }, []);\n    }\n    return value;\n}\nvar isCustomValueType = function(v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function(v) {\n    return isCustomValueType(v) ? v.mix : undefined;\n};\nfunction transform() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({\n        mixer: getMixer(outputRange[0])\n    }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\nfunction useOnChange(value, callback) {\n    useIsomorphicLayoutEffect(function() {\n        if (isMotionValue(value)) return value.onChange(callback);\n    }, [\n        callback\n    ]);\n}\nfunction useMultiOnChange(values, handler) {\n    useIsomorphicLayoutEffect(function() {\n        var subscriptions = values.map(function(value) {\n            return value.onChange(handler);\n        });\n        return function() {\n            return subscriptions.forEach(function(unsubscribe) {\n                return unsubscribe();\n            });\n        };\n    });\n}\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */ var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */ var updateValue = function() {\n        return value.set(combineValues());\n    };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */ updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */ useMultiOnChange(values, function() {\n        return sync__default[\"default\"].update(updateValue, false, true);\n    });\n    return value;\n}\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([\n        input\n    ], function(_a) {\n        var _b = tslib.__read(_a, 1), latest = _b[0];\n        return transformer(latest);\n    });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function() {\n        return [];\n    });\n    return useCombineMotionValues(values, function() {\n        latest.length = 0;\n        var numValues = values.length;\n        for(var i = 0; i < numValues; i++){\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\nfunction useDefaultMotionValue(value, defaultValue) {\n    if (defaultValue === void 0) {\n        defaultValue = 0;\n    }\n    return isMotionValue(value) ? value : useMotionValue(defaultValue);\n}\nfunction ReorderItem(_a, externalRef) {\n    var children = _a.children, style = _a.style, value = _a.value, _b = _a.as, as = _b === void 0 ? \"li\" : _b, onDrag = _a.onDrag, _c = _a.layout, layout = _c === void 0 ? true : _c, props = tslib.__rest(_a, [\n        \"children\",\n        \"style\",\n        \"value\",\n        \"as\",\n        \"onDrag\",\n        \"layout\"\n    ]);\n    var Component = useConstant(function() {\n        return motion(as);\n    });\n    var context = React.useContext(ReorderContext);\n    var point = {\n        x: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.x),\n        y: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.y)\n    };\n    var zIndex = useTransform([\n        point.x,\n        point.y\n    ], function(_a) {\n        var _b = tslib.__read(_a, 2), latestX = _b[0], latestY = _b[1];\n        return latestX || latestY ? 1 : \"unset\";\n    });\n    var measuredLayout = React.useRef(null);\n    heyListen.invariant(Boolean(context), \"Reorder.Item must be a child of Reorder.Group\");\n    var _d = context, axis = _d.axis, registerItem = _d.registerItem, updateOrder = _d.updateOrder;\n    React.useEffect(function() {\n        registerItem(value, measuredLayout.current);\n    }, [\n        context\n    ]);\n    return React__namespace.createElement(Component, tslib.__assign({\n        drag: axis\n    }, props, {\n        dragSnapToOrigin: true,\n        style: tslib.__assign(tslib.__assign({}, style), {\n            x: point.x,\n            y: point.y,\n            zIndex: zIndex\n        }),\n        layout: layout,\n        onDrag: function(event, gesturePoint) {\n            var velocity = gesturePoint.velocity;\n            velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);\n            onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, gesturePoint);\n        },\n        onLayoutMeasure: function(measured) {\n            measuredLayout.current = measured;\n        },\n        ref: externalRef\n    }), children);\n}\nvar Item = React.forwardRef(ReorderItem);\nvar Reorder = {\n    Group: Group,\n    Item: Item\n};\n/**\n * @public\n */ var domAnimation = tslib.__assign(tslib.__assign({\n    renderer: createDomVisualElement\n}, animations), gestureAnimations);\n/**\n * @public\n */ var domMax = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutFeatures), {\n    projectionNodeConstructor: HTMLProjectionNode\n});\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */ function useMotionTemplate(fragments) {\n    var values = [];\n    for(var _i = 1; _i < arguments.length; _i++){\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */ var numFragments = fragments.length;\n    function buildValue() {\n        var output = \"\";\n        for(var i = 0; i < numFragments; i++){\n            output += fragments[i];\n            var value = values[i];\n            if (value) output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */ function useSpring(source, config) {\n    if (config === void 0) {\n        config = {};\n    }\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var activeSpringAnimation = React.useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    React.useMemo(function() {\n        return value.attach(function(v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */ if (isStatic) return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({\n                from: value.get(),\n                to: v,\n                velocity: value.getVelocity()\n            }, config), {\n                onUpdate: set\n            }));\n            return value.get();\n        });\n    }, [\n        JSON.stringify(config)\n    ]);\n    useOnChange(source, function(v) {\n        return value.set(parseFloat(v));\n    });\n    return value;\n}\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */ function useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    React.useEffect(function() {\n        return value.velocityUpdateSubscribers.add(function(newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [\n        value\n    ]);\n    return velocity;\n}\nvar createScrollMotionValues = function() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0)\n    };\n};\nfunction useScroll(_a) {\n    if (_a === void 0) {\n        _a = {};\n    }\n    var container = _a.container, target = _a.target, options = tslib.__rest(_a, [\n        \"container\",\n        \"target\"\n    ]);\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function() {\n        return dom.scroll(function(_a) {\n            var x = _a.x, y = _a.y;\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, tslib.__assign(tslib.__assign({}, options), {\n            container: (container === null || container === void 0 ? void 0 : container.current) || undefined,\n            target: (target === null || target === void 0 ? void 0 : target.current) || undefined\n        }));\n    }, []);\n    return values;\n}\nfunction useElementScroll(ref) {\n    warnOnce(false, \"useElementScroll is deprecated. Convert to useScroll({ container: ref }).\");\n    return useScroll({\n        container: ref\n    });\n}\nfunction useViewportScroll() {\n    warnOnce(false, \"useViewportScroll is deprecated. Convert to useScroll().\");\n    return useScroll();\n}\nvar getCurrentTime = typeof performance !== \"undefined\" ? function() {\n    return performance.now();\n} : function() {\n    return Date.now();\n};\nfunction useAnimationFrame(callback) {\n    var initialTimestamp = useConstant(getCurrentTime);\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    React.useEffect(function() {\n        if (isStatic) return;\n        var provideTimeSinceStart = function(_a) {\n            var timestamp = _a.timestamp;\n            callback(timestamp - initialTimestamp);\n        };\n        sync__default[\"default\"].update(provideTimeSinceStart, true);\n        return function() {\n            return sync.cancelSync.update(provideTimeSinceStart);\n        };\n    }, [\n        callback\n    ]);\n}\nfunction useTime() {\n    var time = useMotionValue(0);\n    useAnimationFrame(function(t) {\n        return time.set(t);\n    });\n    return time;\n}\n/**\n * @public\n */ function animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */ var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */ var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */ var subscribers = new Set();\n    var controls = {\n        subscribe: function(visualElement) {\n            subscribers.add(visualElement);\n            return function() {\n                return void subscribers.delete(visualElement);\n            };\n        },\n        start: function(definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */ if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function(visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride\n                    }));\n                });\n                return Promise.all(animations_1);\n            } else {\n                return new Promise(function(resolve) {\n                    pendingAnimations.push({\n                        animation: [\n                            definition,\n                            transitionOverride\n                        ],\n                        resolve: resolve\n                    });\n                });\n            }\n        },\n        set: function(definition) {\n            heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function(visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function() {\n            subscribers.forEach(function(visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function() {\n            hasMounted = true;\n            pendingAnimations.forEach(function(_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation), false)).then(resolve);\n            });\n            return function() {\n                hasMounted = false;\n                controls.stop();\n            };\n        }\n    };\n    return controls;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */ function useAnimationControls() {\n    var controls = useConstant(animationControls);\n    React.useEffect(controls.mount, []);\n    return controls;\n}\nvar useAnimation = useAnimationControls;\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */ function useCycle() {\n    var items = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        items[_i] = arguments[_i];\n    }\n    var index = React.useRef(0);\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    var runCycle = React.useCallback(function(next) {\n        index.current = typeof next !== \"number\" ? popmotion.wrap(0, items.length, index.current + 1) : next;\n        setItem(items[index.current]);\n    }, tslib.__spreadArray([\n        items.length\n    ], tslib.__read(items), false));\n    return [\n        item,\n        runCycle\n    ];\n}\nfunction useInView(ref, _a) {\n    var _b = _a === void 0 ? {} : _a, root = _b.root, margin = _b.margin, amount = _b.amount, _c = _b.once, once = _c === void 0 ? false : _c;\n    var _d = tslib.__read(React.useState(false), 2), isInView = _d[0], setInView = _d[1];\n    React.useEffect(function() {\n        var _a;\n        if (!ref.current || once && isInView) return;\n        var onEnter = function() {\n            setInView(true);\n            return once ? undefined : function() {\n                return setInView(false);\n            };\n        };\n        var options = {\n            root: (_a = root === null || root === void 0 ? void 0 : root.current) !== null && _a !== void 0 ? _a : undefined,\n            margin: margin,\n            amount: amount === \"some\" ? \"any\" : amount\n        };\n        return dom.inView(ref.current, onEnter, options);\n    }, [\n        root,\n        ref,\n        margin,\n        once\n    ]);\n    return isInView;\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */ var DragControls = /** @class */ function() {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */ DragControls.prototype.subscribe = function(controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function() {\n            return _this.componentControls.delete(controls);\n        };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */ DragControls.prototype.start = function(event, options) {\n        this.componentControls.forEach(function(controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    return DragControls;\n}();\nvar createDragControls = function() {\n    return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */ function useDragControls() {\n    return useConstant(createDragControls);\n}\nfunction useInstantLayoutTransition() {\n    return startTransition;\n}\nfunction startTransition(cb) {\n    if (!rootProjectionNode.current) return;\n    rootProjectionNode.current.isUpdating = false;\n    rootProjectionNode.current.blockUpdate();\n    cb === null || cb === void 0 ? void 0 : cb();\n}\nfunction useInstantTransition() {\n    var _a = tslib.__read(useForceUpdate(), 2), forceUpdate = _a[0], forcedRenderCount = _a[1];\n    var startInstantLayoutTransition = useInstantLayoutTransition();\n    React.useEffect(function() {\n        /**\n         * Unblock after two animation frames, otherwise this will unblock too soon.\n         */ sync__default[\"default\"].postRender(function() {\n            return sync__default[\"default\"].postRender(function() {\n                return instantAnimationState.current = false;\n            });\n        });\n    }, [\n        forcedRenderCount\n    ]);\n    return function(callback) {\n        startInstantLayoutTransition(function() {\n            instantAnimationState.current = true;\n            forceUpdate();\n            callback();\n        });\n    };\n}\nfunction useResetProjection() {\n    var reset = React__namespace.useCallback(function() {\n        var root = rootProjectionNode.current;\n        if (!root) return;\n        root.resetTree();\n    }, []);\n    return reset;\n}\nvar createObject = function() {\n    return {};\n};\nvar stateVisualElement = visualElement({\n    build: function() {},\n    measureViewportBox: createBox,\n    resetTransform: function() {},\n    restoreTransform: function() {},\n    removeValueFromRenderState: function() {},\n    render: function() {},\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function(_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function(element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\n            \"transition\",\n            \"transitionEnd\"\n        ]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return tslib.__assign({\n            transition: transition,\n            transitionEnd: transitionEnd\n        }, target);\n    }\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n */ function useAnimatedState(initialState) {\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function() {\n        return stateVisualElement({\n            props: {},\n            visualState: visualState\n        }, {\n            initialState: initialState\n        });\n    });\n    React.useEffect(function() {\n        element.mount({});\n        return element.unmount;\n    }, [\n        element\n    ]);\n    React.useEffect(function() {\n        element.setProps({\n            onUpdate: function(v) {\n                setAnimationState(tslib.__assign({}, v));\n            }\n        });\n    }, [\n        setAnimationState,\n        element\n    ]);\n    var startAnimation = useConstant(function() {\n        return function(animationDefinition) {\n            return animateVisualElement(element, animationDefinition);\n        };\n    });\n    return [\n        animationState,\n        startAnimation\n    ];\n}\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function(scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @deprecated\n */ function useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    } else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return {\n        scaleX: scaleX,\n        scaleY: scaleY\n    };\n}\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.LayoutGroup = LayoutGroup;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionContext = MotionContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.Reorder = Reorder;\nexports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;\nexports.addPointerEvent = addPointerEvent;\nexports.addScaleCorrector = addScaleCorrector;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.animations = animations;\nexports.calcLength = calcLength;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.createBox = createBox;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.filterProps = filterProps;\nexports.isBrowser = isBrowser;\nexports.isDragActive = isDragActive;\nexports.isMotionValue = isMotionValue;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.makeUseVisualState = makeUseVisualState;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useAnimationControls = useAnimationControls;\nexports.useAnimationFrame = useAnimationFrame;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useForceUpdate = useForceUpdate;\nexports.useInView = useInView;\nexports.useInstantLayoutTransition = useInstantLayoutTransition;\nexports.useInstantTransition = useInstantTransition;\nexports.useIsPresent = useIsPresent;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useReducedMotionConfig = useReducedMotionConfig;\nexports.useResetProjection = useResetProjection;\nexports.useScroll = useScroll;\nexports.useSpring = useSpring;\nexports.useTime = useTime;\nexports.useTransform = useTransform;\nexports.useUnmountEffect = useUnmountEffect;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.useVisualElementContext = useVisualElementContext;\nexports.visualElement = visualElement;\nexports.wrapHandler = wrapHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxZQUFZRixtQkFBT0EsQ0FBQztBQUN4QixJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDO0FBQzlCLElBQUlJLFlBQVlKLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlLLE9BQU9MLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlNLE1BQU1OLG1CQUFPQSxDQUFDO0FBRWxCLFNBQVNPLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsU0FBU0Msa0JBQWtCRCxDQUFDO0lBQ3hCLElBQUlBLEtBQUtBLEVBQUVFLFVBQVUsRUFBRSxPQUFPRjtJQUM5QixJQUFJRyxJQUFJaEIsT0FBT2lCLE1BQU0sQ0FBQztJQUN0QixJQUFJSixHQUFHO1FBQ0hiLE9BQU9rQixJQUFJLENBQUNMLEdBQUdNLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQzlCLElBQUlBLE1BQU0sV0FBVztnQkFDakIsSUFBSUMsSUFBSXJCLE9BQU9zQix3QkFBd0IsQ0FBQ1QsR0FBR087Z0JBQzNDcEIsT0FBT0MsY0FBYyxDQUFDZSxHQUFHSSxHQUFHQyxFQUFFRSxHQUFHLEdBQUdGLElBQUk7b0JBQ3BDRyxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9WLENBQUMsQ0FBQ08sRUFBRTtvQkFBRTtnQkFDcEM7WUFDSjtRQUNKO0lBQ0o7SUFDQUosQ0FBQyxDQUFDLFVBQVUsR0FBR0g7SUFDZixPQUFPYixPQUFPeUIsTUFBTSxDQUFDVDtBQUN6QjtBQUVBLElBQUlVLG1CQUFtQixXQUFX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Qyx3QkFBd0IsR0FBRzJnQjtBQUMzQjNnQixtQkFBbUIsR0FBR29nRDtBQUN0QnBnRCx5QkFBeUIsR0FBRzhnRDtBQUM1QjlnRCwrQkFBK0IsR0FBRzRFO0FBQ2xDNUUscUJBQXFCLEdBQUcyRDtBQUN4QjNELG1CQUFtQixHQUFHZ2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b25kZXJieXRlLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9janMvaW5kZXguanM/NzMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGhleUxpc3RlbiA9IHJlcXVpcmUoJ2hleS1saXN0ZW4nKTtcbnZhciBzdHlsZVZhbHVlVHlwZXMgPSByZXF1aXJlKCdzdHlsZS12YWx1ZS10eXBlcycpO1xudmFyIHBvcG1vdGlvbiA9IHJlcXVpcmUoJ3BvcG1vdGlvbicpO1xudmFyIHN5bmMgPSByZXF1aXJlKCdmcmFtZXN5bmMnKTtcbnZhciBkb20gPSByZXF1aXJlKCdAbW90aW9ub25lL2RvbScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xudmFyIHN5bmNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHN5bmMpO1xuXG4vKipcbiAqIEJyb3dzZXItc2FmZSB1c2FnZSBvZiBwcm9jZXNzXG4gKi9cbnZhciBkZWZhdWx0RW52aXJvbm1lbnQgPSBcInByb2R1Y3Rpb25cIjtcbnZhciBlbnYgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmVudiA9PT0gdW5kZWZpbmVkXG4gICAgPyBkZWZhdWx0RW52aXJvbm1lbnRcbiAgICA6IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8IGRlZmF1bHRFbnZpcm9ubWVudDtcblxudmFyIGNyZWF0ZURlZmluaXRpb24gPSBmdW5jdGlvbiAocHJvcE5hbWVzKSB7IHJldHVybiAoe1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBwcm9wTmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gISFwcm9wc1tuYW1lXTsgfSk7IH0sXG59KTsgfTtcbnZhciBmZWF0dXJlRGVmaW5pdGlvbnMgPSB7XG4gICAgbWVhc3VyZUxheW91dDogY3JlYXRlRGVmaW5pdGlvbihbXCJsYXlvdXRcIiwgXCJsYXlvdXRJZFwiLCBcImRyYWdcIl0pLFxuICAgIGFuaW1hdGlvbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICBcImV4aXRcIixcbiAgICAgICAgXCJ2YXJpYW50c1wiLFxuICAgICAgICBcIndoaWxlSG92ZXJcIixcbiAgICAgICAgXCJ3aGlsZVRhcFwiLFxuICAgICAgICBcIndoaWxlRm9jdXNcIixcbiAgICAgICAgXCJ3aGlsZURyYWdcIixcbiAgICAgICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIF0pLFxuICAgIGV4aXQ6IGNyZWF0ZURlZmluaXRpb24oW1wiZXhpdFwiXSksXG4gICAgZHJhZzogY3JlYXRlRGVmaW5pdGlvbihbXCJkcmFnXCIsIFwiZHJhZ0NvbnRyb2xzXCJdKSxcbiAgICBmb2N1czogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUZvY3VzXCJdKSxcbiAgICBob3ZlcjogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUhvdmVyXCIsIFwib25Ib3ZlclN0YXJ0XCIsIFwib25Ib3ZlckVuZFwiXSksXG4gICAgdGFwOiBjcmVhdGVEZWZpbml0aW9uKFtcIndoaWxlVGFwXCIsIFwib25UYXBcIiwgXCJvblRhcFN0YXJ0XCIsIFwib25UYXBDYW5jZWxcIl0pLFxuICAgIHBhbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgICAgIFwib25QYW5cIixcbiAgICAgICAgXCJvblBhblN0YXJ0XCIsXG4gICAgICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICAgICAgXCJvblBhbkVuZFwiLFxuICAgIF0pLFxuICAgIGluVmlldzogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgICAgIFwid2hpbGVJblZpZXdcIixcbiAgICAgICAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgICAgICAgXCJvblZpZXdwb3J0TGVhdmVcIixcbiAgICBdKSxcbn07XG5mdW5jdGlvbiBsb2FkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmVhdHVyZXMpIHtcbiAgICAgICAgaWYgKGZlYXR1cmVzW2tleV0gPT09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGZlYXR1cmVEZWZpbml0aW9ucy5wcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yID0gZmVhdHVyZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXldLkNvbXBvbmVudCA9IGZlYXR1cmVzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBMYXp5Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoeyBzdHJpY3Q6IGZhbHNlIH0pO1xuXG52YXIgZmVhdHVyZU5hbWVzID0gT2JqZWN0LmtleXMoZmVhdHVyZURlZmluaXRpb25zKTtcbnZhciBudW1GZWF0dXJlcyA9IGZlYXR1cmVOYW1lcy5sZW5ndGg7XG4vKipcbiAqIExvYWQgZmVhdHVyZXMgdmlhIHJlbmRlcmxlc3MgY29tcG9uZW50cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgTW90aW9uUHJvcHMuXG4gKi9cbmZ1bmN0aW9uIHVzZUZlYXR1cmVzKHByb3BzLCB2aXN1YWxFbGVtZW50LCBwcmVsb2FkZWRGZWF0dXJlcykge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIHZhciBsYXp5Q29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTGF6eUNvbnRleHQpO1xuICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSwgY2hlY2sgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCByZW5kZXJpbmcgYSBtb3Rpb24gY29tcG9uZW50XG4gICAgICogYXMgYSBjaGlsZCBvZiBMYXp5TW90aW9uLCBhcyB0aGlzIHdpbGwgYnJlYWsgdGhlIGZpbGUtc2l6ZSBiZW5lZml0cyBvZiB1c2luZyBpdC5cbiAgICAgKi9cbiAgICBpZiAoZW52ICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcmVsb2FkZWRGZWF0dXJlcyAmJiBsYXp5Q29udGV4dC5zdHJpY3QpIHtcbiAgICAgICAgaGV5TGlzdGVuLmludmFyaWFudChmYWxzZSwgXCJZb3UgaGF2ZSByZW5kZXJlZCBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoaW4gYSBgTGF6eU1vdGlvbmAgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgdHJlZSBzaGFraW5nLiBJbXBvcnQgYW5kIHJlbmRlciBhIGBtYCBjb21wb25lbnQgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRmVhdHVyZXM7IGkrKykge1xuICAgICAgICB2YXIgbmFtZV8xID0gZmVhdHVyZU5hbWVzW2ldO1xuICAgICAgICB2YXIgX2EgPSBmZWF0dXJlRGVmaW5pdGlvbnNbbmFtZV8xXSwgaXNFbmFibGVkID0gX2EuaXNFbmFibGVkLCBDb21wb25lbnQgPSBfYS5Db21wb25lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBtaWdodCBiZSBwb3NzaWJsZSBpbiB0aGUgZnV0dXJlIHRvIHVzZSB0aGlzIG1vbWVudCB0b1xuICAgICAgICAgKiBkeW5hbWljYWxseSByZXF1ZXN0IGZ1bmN0aW9uYWxpdHkuIEluIGluaXRpYWwgdGVzdHMgdGhpc1xuICAgICAgICAgKiB3YXMgcHJvZHVjaW5nIGEgbG90IG9mIGR1cGxpY2F0aW9uIGFtb25nc3QgYnVuZGxlcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc0VuYWJsZWQocHJvcHMpICYmIENvbXBvbmVudCkge1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB0c2xpYi5fX2Fzc2lnbih7IGtleTogbmFtZV8xIH0sIHByb3BzLCB7IHZpc3VhbEVsZW1lbnQ6IHZpc3VhbEVsZW1lbnQgfSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG52YXIgTW90aW9uQ29uZmlnQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogZnVuY3Rpb24gKHApIHsgcmV0dXJuIHA7IH0sXG4gICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgIHJlZHVjZWRNb3Rpb246IFwibmV2ZXJcIixcbn0pO1xuXG52YXIgTW90aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29udGV4dCkudmlzdWFsRWxlbWVudDtcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbnZhciBQcmVzZW5jZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuLy8gRG9lcyB0aGlzIGRldmljZSBwcmVmZXIgcmVkdWNlZCBtb3Rpb24/IFJldHVybnMgYG51bGxgIHNlcnZlci1zaWRlLlxudmFyIHByZWZlcnNSZWR1Y2VkTW90aW9uID0geyBjdXJyZW50OiBudWxsIH07XG52YXIgaGFzRGV0ZWN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgICBoYXNEZXRlY3RlZCA9IHRydWU7XG4gICAgaWYgKCFpc0Jyb3dzZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgdmFyIG1vdGlvbk1lZGlhUXVlcnlfMSA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pXCIpO1xuICAgICAgICB2YXIgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gbW90aW9uTWVkaWFRdWVyeV8xLm1hdGNoZXMpO1xuICAgICAgICB9O1xuICAgICAgICBtb3Rpb25NZWRpYVF1ZXJ5XzEuYWRkTGlzdGVuZXIoc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKTtcbiAgICAgICAgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBBIGhvb2sgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB3ZSBzaG91bGQgYmUgdXNpbmcgcmVkdWNlZCBtb3Rpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgZGV2aWNlJ3MgUmVkdWNlZCBNb3Rpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBjaGFuZ2VzIHRvIHlvdXIgVUkgYmFzZWQgb24gUmVkdWNlZCBNb3Rpb24uIEZvciBpbnN0YW5jZSwgcmVwbGFjaW5nIG1vdGlvbi1zaWNrbmVzcyBpbmR1Y2luZ1xuICogYHhgL2B5YCBhbmltYXRpb25zIHdpdGggYG9wYWNpdHlgLCBkaXNhYmxpbmcgdGhlIGF1dG9wbGF5IG9mIGJhY2tncm91bmQgdmlkZW9zLCBvciB0dXJuaW5nIG9mZiBwYXJhbGxheCBtb3Rpb24uXG4gKlxuICogSXQgd2lsbCBhY3RpdmVseSByZXNwb25kIHRvIGNoYW5nZXMgYW5kIHJlLXJlbmRlciB5b3VyIGNvbXBvbmVudHMgd2l0aCB0aGUgbGF0ZXN0IHNldHRpbmcuXG4gKlxuICogYGBganN4XG4gKiBleHBvcnQgZnVuY3Rpb24gU2lkZWJhcih7IGlzT3BlbiB9KSB7XG4gKiAgIGNvbnN0IHNob3VsZFJlZHVjZU1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb24oKVxuICogICBjb25zdCBjbG9zZWRYID0gc2hvdWxkUmVkdWNlTW90aW9uID8gMCA6IFwiLTEwMCVcIlxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8bW90aW9uLmRpdiBhbmltYXRlPXt7XG4gKiAgICAgICBvcGFjaXR5OiBpc09wZW4gPyAxIDogMCxcbiAqICAgICAgIHg6IGlzT3BlbiA/IDAgOiBjbG9zZWRYXG4gKiAgICAgfX0gLz5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybiBib29sZWFuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uKCkge1xuICAgIC8qKlxuICAgICAqIExhenkgaW5pdGlhbGlzYXRpb24gb2YgcHJlZmVyc1JlZHVjZWRNb3Rpb25cbiAgICAgKi9cbiAgICAhaGFzRGV0ZWN0ZWQgJiYgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKFJlYWN0LnVzZVN0YXRlKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQpLCAxKSwgc2hvdWxkUmVkdWNlTW90aW9uID0gX2FbMF07XG4gICAgLyoqXG4gICAgICogVE9ETyBTZWUgaWYgcGVvcGxlIG1pc3MgYXV0b21hdGljYWxseSB1cGRhdGluZyBzaG91bGRSZWR1Y2VNb3Rpb24gc2V0dGluZ1xuICAgICAqL1xuICAgIHJldHVybiBzaG91bGRSZWR1Y2VNb3Rpb247XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uQ29uZmlnKCkge1xuICAgIHZhciByZWR1Y2VkTW90aW9uUHJlZmVyZW5jZSA9IHVzZVJlZHVjZWRNb3Rpb24oKTtcbiAgICB2YXIgcmVkdWNlZE1vdGlvbiA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkucmVkdWNlZE1vdGlvbjtcbiAgICBpZiAocmVkdWNlZE1vdGlvbiA9PT0gXCJuZXZlclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVkdWNlZE1vdGlvbiA9PT0gXCJhbHdheXNcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZWR1Y2VkTW90aW9uUHJlZmVyZW5jZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgcHJvcHMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgbGF6eUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KExhenlDb250ZXh0KTtcbiAgICB2YXIgcGFyZW50ID0gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKTtcbiAgICB2YXIgcHJlc2VuY2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIHZhciBzaG91bGRSZWR1Y2VNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uQ29uZmlnKCk7XG4gICAgdmFyIHZpc3VhbEVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlbid0IHByZWxvYWRlZCBhIHJlbmRlcmVyLCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBvbmUgbGF6eS1sb2FkZWRcbiAgICAgKi9cbiAgICBpZiAoIWNyZWF0ZVZpc3VhbEVsZW1lbnQpXG4gICAgICAgIGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSBsYXp5Q29udGV4dC5yZW5kZXJlcjtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCAmJiBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCA9IGNyZWF0ZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICB2aXN1YWxTdGF0ZTogdmlzdWFsU3RhdGUsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIHByZXNlbmNlSWQ6IHByZXNlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBwcmVzZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlbmNlQ29udGV4dC5pZCxcbiAgICAgICAgICAgIGJsb2NrSW5pdGlhbEFuaW1hdGlvbjogKHByZXNlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBwcmVzZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlbmNlQ29udGV4dC5pbml0aWFsKSA9PT0gZmFsc2UsXG4gICAgICAgICAgICBzaG91bGRSZWR1Y2VNb3Rpb246IHNob3VsZFJlZHVjZU1vdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciB2aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50O1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYW5pbWF0ZUNoYW5nZXMoKTtcbiAgICB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5ub3RpZnlVbm1vdW50KCk7IH07IH0sIFtdKTtcbiAgICByZXR1cm4gdmlzdWFsRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNSZWZPYmplY3QocmVmKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgcmVmID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWYsIFwiY3VycmVudFwiKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlZiBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaHlkcmF0ZXMgdGhlIHByb3ZpZGVkXG4gKiBleHRlcm5hbCByZWYgYW5kIFZpc3VhbEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaW5zdGFuY2UgJiYgKChfYSA9IHZpc3VhbFN0YXRlLm1vdW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2aXN1YWxTdGF0ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgPyB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKVxuICAgICAgICAgICAgICAgIDogdmlzdWFsRWxlbWVudC51bm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZihpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvKipcbiAgICAgKiBPbmx5IHBhc3MgYSBuZXcgcmVmIGNhbGxiYWNrIHRvIFJlYWN0IGlmIHdlJ3ZlIHJlY2VpdmVkIGEgdmlzdWFsIGVsZW1lbnRcbiAgICAgKiBmYWN0b3J5LiBPdGhlcndpc2Ugd2UnbGwgYmUgbW91bnRpbmcvcmVtb3VudGluZyBldmVyeSB0aW1lIGV4dGVybmFsUmVmXG4gICAgICogb3Igb3RoZXIgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBbdmlzdWFsRWxlbWVudF0pO1xufVxuXG4vKipcbiAqIERlY2lkZXMgaWYgdGhlIHN1cHBsaWVkIHZhcmlhYmxlIGlzIGFuIGFycmF5IG9mIHZhcmlhbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVscyh2KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59XG4vKipcbiAqIERlY2lkZXMgaWYgdGhlIHN1cHBsaWVkIHZhcmlhYmxlIGlzIHZhcmlhbnQgbGFiZWxcbiAqL1xuZnVuY3Rpb24gaXNWYXJpYW50TGFiZWwodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCBpc1ZhcmlhbnRMYWJlbHModik7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBzdGF0ZSBvZiBldmVyeSBNb3Rpb25WYWx1ZSBvbiBhIFZpc3VhbEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudCh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB7fTtcbiAgICB2aXN1YWxFbGVtZW50LmZvckVhY2hWYWx1ZShmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXR1cm4gKGN1cnJlbnRba2V5XSA9IHZhbHVlLmdldCgpKTsgfSk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBldmVyeSBNb3Rpb25WYWx1ZSBvbiBhIFZpc3VhbEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHkkMSh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIHZlbG9jaXR5ID0ge307XG4gICAgdmlzdWFsRWxlbWVudC5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmV0dXJuICh2ZWxvY2l0eVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKSk7IH0pO1xuICAgIHJldHVybiB2ZWxvY2l0eTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20sIGN1cnJlbnRWYWx1ZXMsIGN1cnJlbnRWZWxvY2l0eSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY3VycmVudFZhbHVlcyA9PT0gdm9pZCAwKSB7IGN1cnJlbnRWYWx1ZXMgPSB7fTsgfVxuICAgIGlmIChjdXJyZW50VmVsb2NpdHkgPT09IHZvaWQgMCkgeyBjdXJyZW50VmVsb2NpdHkgPSB7fTsgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGRlZmluaXRpb24gaXMgYSBmdW5jdGlvbiwgcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IG51bGwgJiYgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGN1cnJlbnRWYWx1ZXMsIGN1cnJlbnRWZWxvY2l0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGRlZmluaXRpb24gaXMgYSB2YXJpYW50IGxhYmVsLCBvclxuICAgICAqIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBhIHZhcmlhbnQgbGFiZWwsIHJlc29sdmUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSAoX2EgPSBwcm9wcy52YXJpYW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlJ3ZlIHJlc29sdmVkIGJvdGggZnVuY3Rpb25zIGFuZCB2YXJpYW50IGxhYmVscyxcbiAgICAgKiBidXQgdGhlIHJlc29sdmVkIHZhcmlhbnQgbGFiZWwgbWlnaHQgaXRzZWxmIGhhdmUgYmVlbiBhIGZ1bmN0aW9uLlxuICAgICAqIElmIHNvLCByZXNvbHZlLiBUaGlzIGNhbiBvbmx5IGhhdmUgcmV0dXJuZWQgYSB2YWxpZCB0YXJnZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gbnVsbCAmJiBjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59XG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgICB2YXIgcHJvcHMgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgcmV0dXJuIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20gIT09IG51bGwgJiYgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGdldEN1cnJlbnQodmlzdWFsRWxlbWVudCksIGdldFZlbG9jaXR5JDEodmlzdWFsRWxlbWVudCkpO1xufVxuZnVuY3Rpb24gY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICh0eXBlb2YgKChfYSA9IHByb3BzLmFuaW1hdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydCkgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy5pbml0aWFsKSB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy5hbmltYXRlKSB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy53aGlsZUhvdmVyKSB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy53aGlsZURyYWcpIHx8XG4gICAgICAgIGlzVmFyaWFudExhYmVsKHByb3BzLndoaWxlVGFwKSB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy53aGlsZUZvY3VzKSB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy5leGl0KSk7XG59XG5mdW5jdGlvbiBjaGVja0lmVmFyaWFudE5vZGUocHJvcHMpIHtcbiAgICByZXR1cm4gQm9vbGVhbihjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykgfHwgcHJvcHMudmFyaWFudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSkge1xuICAgICAgICB2YXIgaW5pdGlhbCA9IHByb3BzLmluaXRpYWwsIGFuaW1hdGUgPSBwcm9wcy5hbmltYXRlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdGlhbDogaW5pdGlhbCA9PT0gZmFsc2UgfHwgaXNWYXJpYW50TGFiZWwoaW5pdGlhbClcbiAgICAgICAgICAgICAgICA/IGluaXRpYWxcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFuaW1hdGU6IGlzVmFyaWFudExhYmVsKGFuaW1hdGUpID8gYW5pbWF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLmluaGVyaXQgIT09IGZhbHNlID8gY29udGV4dCA6IHt9O1xufVxuXG5mdW5jdGlvbiB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKSB7XG4gICAgdmFyIF9hID0gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KSksIGluaXRpYWwgPSBfYS5pbml0aWFsLCBhbmltYXRlID0gX2EuYW5pbWF0ZTtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBpbml0aWFsOiBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlIH0pOyB9LCBbdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShpbml0aWFsKSwgdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShhbmltYXRlKV0pO1xufVxuZnVuY3Rpb24gdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShwcm9wKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wLmpvaW4oXCIgXCIpIDogcHJvcDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uc3RhbnQgdmFsdWUgb3ZlciB0aGUgbGlmZWN5Y2xlIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEV2ZW4gaWYgYHVzZU1lbW9gIGlzIHByb3ZpZGVkIGFuIGVtcHR5IGFycmF5IGFzIGl0cyBmaW5hbCBhcmd1bWVudCwgaXQgZG9lc24ndCBvZmZlclxuICogYSBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCByZS1ydW4gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgbGF0ZXIgb24uIEJ5IHVzaW5nIGB1c2VDb25zdGFudGBcbiAqIHlvdSBjYW4gZW5zdXJlIHRoYXQgaW5pdGlhbGlzZXJzIGRvbid0IGV4ZWN1dGUgdHdpY2Ugb3IgbW9yZS5cbiAqL1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogVGhpcyBzaG91bGQgb25seSBldmVyIGJlIG1vZGlmaWVkIG9uIHRoZSBjbGllbnQgb3RoZXJ3aXNlIGl0J2xsXG4gKiBwZXJzaXN0IHRocm91Z2ggc2VydmVyIHJlcXVlc3RzLiBJZiB3ZSBuZWVkIGluc3RhbmNlZCBzdGF0ZXMgd2VcbiAqIGNvdWxkIGxhenktaW5pdCB2aWEgcm9vdC5cbiAqL1xudmFyIGdsb2JhbFByb2plY3Rpb25TdGF0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBHbG9iYWwgZmxhZyBhcyB0byB3aGV0aGVyIHRoZSB0cmVlIGhhcyBhbmltYXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lXG4gICAgICogd2UgcmVzaXplZCB0aGUgd2luZG93XG4gICAgICovXG4gICAgaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXZSBzZXQgdGhpcyB0byB0cnVlIG9uY2UsIG9uIHRoZSBmaXJzdCB1cGRhdGUuIEFueSBub2RlcyBhZGRlZCB0byB0aGUgdHJlZSBiZXlvbmQgdGhhdFxuICAgICAqIHVwZGF0ZSB3aWxsIGJlIGdpdmVuIGEgYGRhdGEtcHJvamVjdGlvbi1pZGAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGhhc0V2ZXJVcGRhdGVkOiBmYWxzZSxcbn07XG5cbnZhciBpZCQxID0gMTtcbmZ1bmN0aW9uIHVzZVByb2plY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQkMSsrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbnZhciBMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuLyoqXG4gKiBJbnRlcm5hbCwgZXhwb3J0ZWQgb25seSBmb3IgdXNhZ2UgaW4gRnJhbWVyXG4gKi9cbnZhciBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuZnVuY3Rpb24gdXNlUHJvamVjdGlvbihwcm9qZWN0aW9uSWQsIF9hLCB2aXN1YWxFbGVtZW50LCBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBsYXlvdXRJZCA9IF9hLmxheW91dElkLCBsYXlvdXQgPSBfYS5sYXlvdXQsIGRyYWcgPSBfYS5kcmFnLCBkcmFnQ29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHMsIGxheW91dFNjcm9sbCA9IF9hLmxheW91dFNjcm9sbDtcbiAgICB2YXIgaW5pdGlhbFByb21vdGlvbkNvbmZpZyA9IFJlYWN0LnVzZUNvbnRleHQoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICBpZiAoIVByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgfHxcbiAgICAgICAgIXZpc3VhbEVsZW1lbnQgfHxcbiAgICAgICAgKHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiA9IG5ldyBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKHByb2plY3Rpb25JZCwgdmlzdWFsRWxlbWVudC5nZXRMYXRlc3RWYWx1ZXMoKSwgKF9iID0gdmlzdWFsRWxlbWVudC5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wcm9qZWN0aW9uKTtcbiAgICB2aXN1YWxFbGVtZW50LnByb2plY3Rpb24uc2V0T3B0aW9ucyh7XG4gICAgICAgIGxheW91dElkOiBsYXlvdXRJZCxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIGFsd2F5c01lYXN1cmVMYXlvdXQ6IEJvb2xlYW4oZHJhZykgfHwgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSxcbiAgICAgICAgdmlzdWFsRWxlbWVudDogdmlzdWFsRWxlbWVudCxcbiAgICAgICAgc2NoZWR1bGVSZW5kZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTsgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFVwZGF0ZSBvcHRpb25zIGluIGFuIGVmZmVjdC4gVGhpcyBjb3VsZCBiZSB0cmlja3kgYXMgaXQnbGwgYmUgdG9vIGxhdGVcbiAgICAgICAgICogdG8gdXBkYXRlIGJ5IHRoZSB0aW1lIGxheW91dCBhbmltYXRpb25zIHJ1bi5cbiAgICAgICAgICogV2UgYWxzbyBuZWVkIHRvIGZpeCB0aGlzIHNhZmVUb1JlbW92ZSBieSBsaW5raW5nIGl0IHVwIHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgdXNlUHJlc2VuY2UsXG4gICAgICAgICAqIGVuc3VyaW5nIGl0IGdldHMgY2FsbGVkIGlmIHRoZXJlJ3Mgbm8gcG90ZW50aWFsIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uVHlwZTogdHlwZW9mIGxheW91dCA9PT0gXCJzdHJpbmdcIiA/IGxheW91dCA6IFwiYm90aFwiLFxuICAgICAgICBpbml0aWFsUHJvbW90aW9uQ29uZmlnOiBpbml0aWFsUHJvbW90aW9uQ29uZmlnLFxuICAgICAgICBsYXlvdXRTY3JvbGw6IGxheW91dFNjcm9sbCxcbiAgICB9KTtcbn1cblxudmFyIFZpc3VhbEVsZW1lbnRIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhWaXN1YWxFbGVtZW50SGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXN1YWxFbGVtZW50SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdmlzdWFsIGVsZW1lbnQgcHJvcHMgYXMgc29vbiBhcyB3ZSBrbm93IHRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdGVkLlxuICAgICAqL1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVmlzdWFsRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNldFByb3BzKHByb3BzKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIFZpc3VhbEVsZW1lbnRIYW5kbGVyO1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgYG1vdGlvbmAgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIENvbXBvbmVudCBhcmd1bWVudCwgd2hpY2ggY2FuIGJlIGVpdGhlciBhIHN0cmluZyAoaWUgXCJkaXZcIlxuICogZm9yIGBtb3Rpb24uZGl2YCksIG9yIGFuIGFjdHVhbCBSZWFjdCBjb21wb25lbnQuXG4gKlxuICogQWxvbmdzaWRlIHRoaXMgaXMgYSBjb25maWcgb3B0aW9uIHdoaWNoIHByb3ZpZGVzIGEgd2F5IG9mIHJlbmRlcmluZyB0aGUgcHJvdmlkZWRcbiAqIGNvbXBvbmVudCBcIm9mZmxpbmVcIiwgb3Igb3V0c2lkZSB0aGUgUmVhY3QgcmVuZGVyIGN5Y2xlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnQoX2EpIHtcbiAgICB2YXIgcHJlbG9hZGVkRmVhdHVyZXMgPSBfYS5wcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCA9IF9hLmNyZWF0ZVZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgPSBfYS5wcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCB1c2VSZW5kZXIgPSBfYS51c2VSZW5kZXIsIHVzZVZpc3VhbFN0YXRlID0gX2EudXNlVmlzdWFsU3RhdGUsIENvbXBvbmVudCA9IF9hLkNvbXBvbmVudDtcbiAgICBwcmVsb2FkZWRGZWF0dXJlcyAmJiBsb2FkRmVhdHVyZXMocHJlbG9hZGVkRmVhdHVyZXMpO1xuICAgIGZ1bmN0aW9uIE1vdGlvbkNvbXBvbmVudChwcm9wcywgZXh0ZXJuYWxSZWYpIHtcbiAgICAgICAgdmFyIGxheW91dElkID0gdXNlTGF5b3V0SWQocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBwcm9wcyksIHsgbGF5b3V0SWQ6IGxheW91dElkIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgcmVuZGVyaW5nIGluIGEgc3RhdGljIGVudmlyb25tZW50LCB3ZSBvbmx5IHZpc3VhbGx5IHVwZGF0ZSB0aGUgY29tcG9uZW50XG4gICAgICAgICAqIGFzIGEgcmVzdWx0IG9mIGEgUmVhY3QtcmVyZW5kZXIgcmF0aGVyIHRoYW4gaW50ZXJhY3Rpb25zIG9yIGFuaW1hdGlvbnMuIFRoaXNcbiAgICAgICAgICogbWVhbnMgd2UgZG9uJ3QgbmVlZCB0byBsb2FkIGFkZGl0aW9uYWwgbWVtb3J5IHN0cnVjdHVyZXMgbGlrZSBWaXN1YWxFbGVtZW50LFxuICAgICAgICAgKiBvciBhbnkgZ2VzdHVyZS9hbmltYXRpb24gZmVhdHVyZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29uZmlnID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KTtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHVuaXF1ZSBwcm9qZWN0aW9uIElEIGZvciB0aGlzIGNvbXBvbmVudC4gSWYgYSBuZXcgY29tcG9uZW50IGlzIGFkZGVkXG4gICAgICAgICAqIGR1cmluZyBhIGxheW91dCBhbmltYXRpb24gd2UnbGwgdXNlIHRoaXMgdG8gcXVlcnkgdGhlIERPTSBhbmQgaHlkcmF0ZSBpdHMgcmVmIGVhcmx5LCBhbGxvd2luZ1xuICAgICAgICAgKiB1cyB0byBtZWFzdXJlIGl0IGFzIHNvb24gYXMgYW55IGxheW91dCBlZmZlY3QgZmx1c2hlcyBwZW5kaW5nIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJmb3JtYW5jZSBub3RlOiBJdCdkIGJlIGJldHRlciBub3QgdG8gaGF2ZSB0byBzZWFyY2ggdGhlIERPTSBmb3IgdGhlc2UgZWxlbWVudHMuXG4gICAgICAgICAqIEZvciBuZXdseS1lbnRlcmluZyBjb21wb25lbnRzIGl0IGNvdWxkIGJlIGVub3VnaCB0byBvbmx5IGNvcnJlY3QgdHJlZVNjYWxlLCBpbiB3aGljaFxuICAgICAgICAgKiBjYXNlIHdlIGNvdWxkIG1vdW50IGluIGEgc2NhbGUtY29ycmVjdGlvbiBtb2RlLiBUaGlzIHdvdWxkbid0IGJlIGVub3VnaCBmb3JcbiAgICAgICAgICogc2hhcmVkIGVsZW1lbnQgdHJhbnNpdGlvbnMgaG93ZXZlci4gUGVyaGFwcyBmb3IgdGhvc2Ugd2UgY291bGQgcmV2ZXJ0IHRvIGEgcm9vdCBub2RlXG4gICAgICAgICAqIHRoYXQgZ2V0cyBmb3JjZVJlbmRlcmVkIGFuZCBsYXlvdXQgYW5pbWF0aW9ucyBhcmUgdHJpZ2dlcmVkIG9uIGl0cyBsYXlvdXQgZWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHByb2plY3Rpb25JZCA9IGNvbmZpZy5pc1N0YXRpYyA/IHVuZGVmaW5lZCA6IHVzZVByb2plY3Rpb25JZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhciB2aXN1YWxTdGF0ZSA9IHVzZVZpc3VhbFN0YXRlKHByb3BzLCBjb25maWcuaXNTdGF0aWMpO1xuICAgICAgICBpZiAoIWNvbmZpZy5pc1N0YXRpYyAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGEgVmlzdWFsRWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQuIEEgVmlzdWFsRWxlbWVudCBwcm92aWRlcyBhIGNvbW1vblxuICAgICAgICAgICAgICogaW50ZXJmYWNlIHRvIHJlbmRlcmVyLXNwZWNpZmljIEFQSXMgKGllIERPTS9UaHJlZS5qcyBldGMpIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAqIHByb3ZpZGluZyBhIHdheSBvZiByZW5kZXJpbmcgdG8gdGhlc2UgQVBJcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCByZW5kZXIgbG9vcFxuICAgICAgICAgICAgICogZm9yIG1vcmUgcGVyZm9ybWFudCBhbmltYXRpb25zIGFuZCBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udGV4dC52aXN1YWxFbGVtZW50ID0gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY29uZmlnKSwgcHJvcHMpLCBjcmVhdGVWaXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIHVzZVByb2plY3Rpb24ocHJvamVjdGlvbklkLCBwcm9wcywgY29udGV4dC52aXN1YWxFbGVtZW50LCBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICAgICAgZmVhdHVyZURlZmluaXRpb25zLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMb2FkIE1vdGlvbiBnZXN0dXJlIGFuZCBhbmltYXRpb24gZmVhdHVyZXMuIFRoZXNlIGFyZSByZW5kZXJlZCBhcyByZW5kZXJsZXNzXG4gICAgICAgICAgICAgKiBjb21wb25lbnRzIHNvIGVhY2ggZmVhdHVyZSBjYW4gb3B0aW9uYWxseSBtYWtlIHVzZSBvZiBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZmVhdHVyZXMgPSB1c2VGZWF0dXJlcyhwcm9wcywgY29udGV4dC52aXN1YWxFbGVtZW50LCBwcmVsb2FkZWRGZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3VudCBvcmRlciBhbmQgaGllcmFyY2h5IGlzIHNwZWNpZmljIHRvIGVuc3VyZSBvdXIgZWxlbWVudCByZWZcbiAgICAgICAgICogaXMgaHlkcmF0ZWQgYnkgdGhlIHRpbWUgZmVhdHVyZXMgZmlyZSB0aGVpciBlZmZlY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoVmlzdWFsRWxlbWVudEhhbmRsZXIsIHsgdmlzdWFsRWxlbWVudDogY29udGV4dC52aXN1YWxFbGVtZW50LCBwcm9wczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbmZpZyksIHByb3BzKSB9LFxuICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTW90aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCB1c2VSZW5kZXIoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCB1c2VNb3Rpb25SZWYodmlzdWFsU3RhdGUsIGNvbnRleHQudmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpLCB2aXN1YWxTdGF0ZSwgY29uZmlnLmlzU3RhdGljLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZihNb3Rpb25Db21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0SWQoX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIGxheW91dElkID0gX2EubGF5b3V0SWQ7XG4gICAgdmFyIGxheW91dEdyb3VwSWQgPSAoX2IgPSBSZWFjdC51c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZDtcbiAgICByZXR1cm4gbGF5b3V0R3JvdXBJZCAmJiBsYXlvdXRJZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGF5b3V0R3JvdXBJZCArIFwiLVwiICsgbGF5b3V0SWRcbiAgICAgICAgOiBsYXlvdXRJZDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFueSBSZWFjdCBjb21wb25lbnQgaW50byBhIGBtb3Rpb25gIGNvbXBvbmVudC4gVGhlIHByb3ZpZGVkIGNvbXBvbmVudFxuICogKiptdXN0KiogdXNlIGBSZWFjdC5mb3J3YXJkUmVmYCB0byB0aGUgdW5kZXJseWluZyBET00gY29tcG9uZW50IHlvdSB3YW50IHRvIGFuaW1hdGUuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gKiAgIHJldHVybiA8ZGl2IHJlZj17cmVmfSAvPlxuICogfSlcbiAqXG4gKiBjb25zdCBNb3Rpb25Db21wb25lbnQgPSBtb3Rpb24oQ29tcG9uZW50KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Qcm94eShjcmVhdGVDb25maWcpIHtcbiAgICBmdW5jdGlvbiBjdXN0b20oQ29tcG9uZW50LCBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9PT0gdm9pZCAwKSB7IGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlQ29uZmlnKENvbXBvbmVudCwgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiBnZW5lcmF0ZWQgYG1vdGlvbmAgY29tcG9uZW50cywgZS5nIGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAqIFJhdGhlciB0aGFuIGdlbmVyYXRpbmcgdGhlbSBhbmV3IGV2ZXJ5IHJlbmRlci5cbiAgICAgKi9cbiAgICB2YXIgY29tcG9uZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIG5ldyBQcm94eShjdXN0b20sIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGBtb3Rpb25gIGlzIHJlZmVyZW5jZWQgd2l0aCBhIHByb3A6IGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAgICAgKiBUaGUgcHJvcCBuYW1lIGlzIHBhc3NlZCB0aHJvdWdoIGFzIGBrZXlgIGFuZCB3ZSBjYW4gdXNlIHRoYXQgdG8gZ2VuZXJhdGUgYSBgbW90aW9uYFxuICAgICAgICAgKiBET00gY29tcG9uZW50IHdpdGggdGhhdCBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoX3RhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgZWxlbWVudCBkb2Vzbid0IGV4aXN0IGluIHRoZSBjb21wb25lbnQgY2FjaGUsIGNyZWF0ZSBpdCBhbmQgY2FjaGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Q2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDYWNoZS5zZXQoa2V5LCBjdXN0b20oa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Q2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogV2Uga2VlcCB0aGVzZSBsaXN0ZWQgc2VwZXJhdGVseSBhcyB3ZSB1c2UgdGhlIGxvd2VyY2FzZSB0YWcgbmFtZXMgYXMgcGFydFxuICogb2YgdGhlIHJ1bnRpbWUgYnVuZGxlIHRvIGRldGVjdCBTVkcgY29tcG9uZW50c1xuICovXG52YXIgbG93ZXJjYXNlU1ZHRWxlbWVudHMgPSBbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJjaXJjbGVcIixcbiAgICBcImRlZnNcIixcbiAgICBcImRlc2NcIixcbiAgICBcImVsbGlwc2VcIixcbiAgICBcImdcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJsaW5lXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcIm1hcmtlclwiLFxuICAgIFwibWFza1wiLFxuICAgIFwibWV0YWRhdGFcIixcbiAgICBcInBhdGhcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcInBvbHlnb25cIixcbiAgICBcInBvbHlsaW5lXCIsXG4gICAgXCJyZWN0XCIsXG4gICAgXCJzdG9wXCIsXG4gICAgXCJzdmdcIixcbiAgICBcInN3aXRjaFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJ0ZXh0XCIsXG4gICAgXCJ0c3BhblwiLFxuICAgIFwidXNlXCIsXG4gICAgXCJ2aWV3XCIsXG5dO1xuXG5mdW5jdGlvbiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICBpZiAoXG4gICAgLyoqXG4gICAgICogSWYgaXQncyBub3QgYSBzdHJpbmcsIGl0J3MgYSBjdXN0b20gUmVhY3QgY29tcG9uZW50LiBDdXJyZW50bHkgd2Ugb25seSBzdXBwb3J0XG4gICAgICogSFRNTCBjdXN0b20gUmVhY3QgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICB0eXBlb2YgQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBpdCBjb250YWlucyBhIGRhc2gsIHRoZSBlbGVtZW50IGlzIGEgY3VzdG9tIEhUTUwgd2ViY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50LmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8qKlxuICAgICAqIElmIGl0J3MgaW4gb3VyIGxpc3Qgb2YgbG93ZXJjYXNlIFNWRyB0YWdzLCBpdCdzIGFuIFNWRyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBsb3dlcmNhc2VTVkdFbGVtZW50cy5pbmRleE9mKENvbXBvbmVudCkgPiAtMSB8fFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaXQgY29udGFpbnMgYSBjYXBpdGFsIGxldHRlciwgaXQncyBhbiBTVkcgY29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICAvW0EtWl0vLnRlc3QoQ29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc2NhbGVDb3JyZWN0b3JzID0ge307XG5mdW5jdGlvbiBhZGRTY2FsZUNvcnJlY3Rvcihjb3JyZWN0b3JzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzY2FsZUNvcnJlY3RvcnMsIGNvcnJlY3RvcnMpO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgdHJhbnNmb3JtYWJsZSBheGVzLiBXZSdsbCB1c2UgdGhpcyBsaXN0IHRvIGdlbmVyYXRlZCBhIHZlcnNpb25cbiAqIG9mIGVhY2ggYXhlcyBmb3IgZWFjaCB0cmFuc2Zvcm0uXG4gKi9cbnZhciB0cmFuc2Zvcm1BeGVzID0gW1wiXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdO1xuLyoqXG4gKiBBbiBvcmRlcmVkIGFycmF5IG9mIGVhY2ggdHJhbnNmb3JtYWJsZSB2YWx1ZS4gQnkgZGVmYXVsdCwgdHJhbnNmb3JtIHZhbHVlc1xuICogd2lsbCBiZSBzb3J0ZWQgdG8gdGhpcyBvcmRlci5cbiAqL1xudmFyIG9yZGVyID0gW1widHJhbnNsYXRlXCIsIFwic2NhbGVcIiwgXCJyb3RhdGVcIiwgXCJza2V3XCJdO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgZXZlcnkgcG9zc2libGUgdHJhbnNmb3JtIGtleS5cbiAqL1xudmFyIHRyYW5zZm9ybVByb3BzID0gW1widHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCJ4XCIsIFwieVwiLCBcInpcIl07XG5vcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYXRpb25LZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtQXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGVzS2V5KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5wdXNoKG9wZXJhdGlvbktleSArIGF4ZXNLZXkpO1xuICAgIH0pO1xufSk7XG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gdXNlIHdpdGggQXJyYXkuc29ydCB0byBzb3J0IHRyYW5zZm9ybSBrZXlzIGJ5IHRoZWlyIGRlZmF1bHQgb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHNvcnRUcmFuc2Zvcm1Qcm9wcyhhLCBiKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVByb3BzLmluZGV4T2YoYSkgLSB0cmFuc2Zvcm1Qcm9wcy5pbmRleE9mKGIpO1xufVxuLyoqXG4gKiBBIHF1aWNrIGxvb2t1cCBmb3IgdHJhbnNmb3JtIHByb3BzLlxuICovXG52YXIgdHJhbnNmb3JtUHJvcFNldCA9IG5ldyBTZXQodHJhbnNmb3JtUHJvcHMpO1xuZnVuY3Rpb24gaXNUcmFuc2Zvcm1Qcm9wKGtleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wU2V0LmhhcyhrZXkpO1xufVxuLyoqXG4gKiBBIHF1aWNrIGxvb2t1cCBmb3IgdHJhbnNmb3JtIG9yaWdpbiBwcm9wc1xuICovXG52YXIgdHJhbnNmb3JtT3JpZ2luUHJvcHMgPSBuZXcgU2V0KFtcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwib3JpZ2luWlwiXSk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpblByb3BzLmhhcyhrZXkpO1xufVxuXG5mdW5jdGlvbiBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgX2EpIHtcbiAgICB2YXIgbGF5b3V0ID0gX2EubGF5b3V0LCBsYXlvdXRJZCA9IF9hLmxheW91dElkO1xuICAgIHJldHVybiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkgfHxcbiAgICAgICAgaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wKGtleSkgfHxcbiAgICAgICAgKChsYXlvdXQgfHwgbGF5b3V0SWQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICghIXNjYWxlQ29ycmVjdG9yc1trZXldIHx8IGtleSA9PT0gXCJvcGFjaXR5XCIpKSk7XG59XG5cbnZhciBpc01vdGlvblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmdldFZlbG9jaXR5KTtcbn07XG5cbnZhciB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgICB4OiBcInRyYW5zbGF0ZVhcIixcbiAgICB5OiBcInRyYW5zbGF0ZVlcIixcbiAgICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogXCJwZXJzcGVjdGl2ZVwiLFxufTtcbi8qKlxuICogQnVpbGQgYSBDU1MgdHJhbnNmb3JtIHN0eWxlIGZyb20gaW5kaXZpZHVhbCB4L3kvc2NhbGUgZXRjIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBvdXRwdXRzIHdpdGggYSBkZWZhdWx0IG9yZGVyIG9mIHRyYW5zZm9ybXMvc2NhbGVzL3JvdGF0aW9ucywgdGhpcyBjYW4gYmUgY3VzdG9taXNlZCBieVxuICogcHJvdmlkaW5nIGEgdHJhbnNmb3JtVGVtcGxhdGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtKF9hLCBfYiwgdHJhbnNmb3JtSXNEZWZhdWx0LCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBfYS50cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXMgPSBfYS50cmFuc2Zvcm1LZXlzO1xuICAgIHZhciBfYyA9IF9iLmVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uLCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2IuYWxsb3dUcmFuc2Zvcm1Ob25lLCBhbGxvd1RyYW5zZm9ybU5vbmUgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kO1xuICAgIC8vIFRoZSB0cmFuc2Zvcm0gc3RyaW5nIHdlJ3JlIGdvaW5nIHRvIGJ1aWxkIGludG8uXG4gICAgdmFyIHRyYW5zZm9ybVN0cmluZyA9IFwiXCI7XG4gICAgLy8gVHJhbnNmb3JtIGtleXMgaW50byB0aGVpciBkZWZhdWx0IG9yZGVyIC0gdGhpcyB3aWxsIGRldGVybWluZSB0aGUgb3V0cHV0IG9yZGVyLlxuICAgIHRyYW5zZm9ybUtleXMuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIGRlZmluZWQgdHJhbnNmb3JtIGhhcyBhIGRlZmluZWQgeiBzbyB3ZSBkb24ndCBhZGQgYVxuICAgIC8vIHNlY29uZCB0byBlbmFibGUgaGFyZHdhcmUgYWNjZWxlcmF0aW9uXG4gICAgdmFyIHRyYW5zZm9ybUhhc1ogPSBmYWxzZTtcbiAgICAvLyBMb29wIG92ZXIgZWFjaCB0cmFuc2Zvcm0gYW5kIGJ1aWxkIHRoZW0gaW50byB0cmFuc2Zvcm1TdHJpbmdcbiAgICB2YXIgbnVtVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybUtleXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHJhbnNmb3JtS2V5czsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFuc2Zvcm1LZXlzW2ldO1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJcIi5jb25jYXQodHJhbnNsYXRlQWxpYXNba2V5XSB8fCBrZXksIFwiKFwiKS5jb25jYXQodHJhbnNmb3JtW2tleV0sIFwiKSBcIik7XG4gICAgICAgIGlmIChrZXkgPT09IFwielwiKVxuICAgICAgICAgICAgdHJhbnNmb3JtSGFzWiA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdHJhbnNmb3JtSGFzWiAmJiBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbikge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJ0cmFuc2xhdGVaKDApXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmcudHJpbSgpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIGEgY3VzdG9tIGB0cmFuc2Zvcm1gIHRlbXBsYXRlLCBwYXNzIG91ciB0cmFuc2Zvcm0gdmFsdWVzIGFuZFxuICAgIC8vIGdlbmVyYXRlZCB0cmFuc2Zvcm1TdHJpbmcgdG8gdGhhdCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVRlbXBsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtSXNEZWZhdWx0ID8gXCJcIiA6IHRyYW5zZm9ybVN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93VHJhbnNmb3JtTm9uZSAmJiB0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG4vKipcbiAqIEJ1aWxkIGEgdHJhbnNmb3JtT3JpZ2luIHN0eWxlLiBVc2VzIHRoZSBzYW1lIGRlZmF1bHRzIGFzIHRoZSBicm93c2VyIGZvclxuICogdW5kZWZpbmVkIG9yaWdpbnMuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtT3JpZ2luKF9hKSB7XG4gICAgdmFyIF9iID0gX2Eub3JpZ2luWCwgb3JpZ2luWCA9IF9iID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2IsIF9jID0gX2Eub3JpZ2luWSwgb3JpZ2luWSA9IF9jID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2MsIF9kID0gX2Eub3JpZ2luWiwgb3JpZ2luWiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG9yaWdpblgsIFwiIFwiKS5jb25jYXQob3JpZ2luWSwgXCIgXCIpLmNvbmNhdChvcmlnaW5aKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIGtleSBpcyBhIENTUyB2YXJpYWJsZVxuICovXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlJDEoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwiLS1cIik7XG59XG5cbi8qKlxuICogUHJvdmlkZWQgYSB2YWx1ZSBhbmQgYSBWYWx1ZVR5cGUsIHJldHVybnMgdGhlIHZhbHVlIGFzIHRoYXQgdmFsdWUgdHlwZS5cbiAqL1xudmFyIGdldFZhbHVlQXNUeXBlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdHlwZS50cmFuc2Zvcm0odmFsdWUpXG4gICAgICAgIDogdmFsdWU7XG59O1xuXG52YXIgaW50ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHN0eWxlVmFsdWVUeXBlcy5udW1iZXIpLCB7IHRyYW5zZm9ybTogTWF0aC5yb3VuZCB9KTtcblxudmFyIG51bWJlclZhbHVlVHlwZXMgPSB7XG4gICAgLy8gQm9yZGVyIHByb3BzXG4gICAgYm9yZGVyV2lkdGg6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBib3JkZXJUb3BXaWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBib3JkZXJCb3R0b21XaWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlckxlZnRXaWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlclJhZGl1czogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHJhZGl1czogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIC8vIFBvc2l0aW9uaW5nIHByb3BzXG4gICAgd2lkdGg6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBtYXhXaWR0aDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGhlaWdodDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1heEhlaWdodDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHNpemU6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICB0b3A6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICByaWdodDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGJvdHRvbTogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIGxlZnQ6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICAvLyBTcGFjaW5nIHByb3BzXG4gICAgcGFkZGluZzogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHBhZGRpbmdUb3A6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBwYWRkaW5nUmlnaHQ6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBwYWRkaW5nQm90dG9tOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgcGFkZGluZ0xlZnQ6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBtYXJnaW46IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBtYXJnaW5Ub3A6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBtYXJnaW5SaWdodDogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1hcmdpbkJvdHRvbTogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIG1hcmdpbkxlZnQ6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICAvLyBUcmFuc2Zvcm0gcHJvcHNcbiAgICByb3RhdGU6IHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLFxuICAgIHJvdGF0ZVg6IHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLFxuICAgIHJvdGF0ZVk6IHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLFxuICAgIHJvdGF0ZVo6IHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLFxuICAgIHNjYWxlOiBzdHlsZVZhbHVlVHlwZXMuc2NhbGUsXG4gICAgc2NhbGVYOiBzdHlsZVZhbHVlVHlwZXMuc2NhbGUsXG4gICAgc2NhbGVZOiBzdHlsZVZhbHVlVHlwZXMuc2NhbGUsXG4gICAgc2NhbGVaOiBzdHlsZVZhbHVlVHlwZXMuc2NhbGUsXG4gICAgc2tldzogc3R5bGVWYWx1ZVR5cGVzLmRlZ3JlZXMsXG4gICAgc2tld1g6IHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLFxuICAgIHNrZXdZOiBzdHlsZVZhbHVlVHlwZXMuZGVncmVlcyxcbiAgICBkaXN0YW5jZTogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHRyYW5zbGF0ZVg6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICB0cmFuc2xhdGVZOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgdHJhbnNsYXRlWjogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHg6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICB5OiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgejogc3R5bGVWYWx1ZVR5cGVzLnB4LFxuICAgIHBlcnNwZWN0aXZlOiBzdHlsZVZhbHVlVHlwZXMucHgsXG4gICAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICBvcGFjaXR5OiBzdHlsZVZhbHVlVHlwZXMuYWxwaGEsXG4gICAgb3JpZ2luWDogc3R5bGVWYWx1ZVR5cGVzLnByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBvcmlnaW5ZOiBzdHlsZVZhbHVlVHlwZXMucHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIG9yaWdpblo6IHN0eWxlVmFsdWVUeXBlcy5weCxcbiAgICAvLyBNaXNjXG4gICAgekluZGV4OiBpbnQsXG4gICAgLy8gU1ZHXG4gICAgZmlsbE9wYWNpdHk6IHN0eWxlVmFsdWVUeXBlcy5hbHBoYSxcbiAgICBzdHJva2VPcGFjaXR5OiBzdHlsZVZhbHVlVHlwZXMuYWxwaGEsXG4gICAgbnVtT2N0YXZlczogaW50LFxufTtcblxuZnVuY3Rpb24gYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlLCB2YXJzID0gc3RhdGUudmFycywgdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtLCB0cmFuc2Zvcm1LZXlzID0gc3RhdGUudHJhbnNmb3JtS2V5cywgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xuICAgIC8vIEVtcHR5IHRoZSB0cmFuc2Zvcm1LZXlzIGFycmF5LiBBcyB3ZSdyZSB0aHJvd2luZyBvdXQgcmVmcyB0byBpdHMgaXRlbXNcbiAgICAvLyB0aGlzIG1pZ2h0IG5vdCBiZSBhcyBjaGVhcCBhcyBzdXNwZWN0ZWQuIE1heWJlIHVzaW5nIHRoZSBhcnJheSBhcyBhIGJ1ZmZlclxuICAgIC8vIHdpdGggYSBtYW51YWwgaW5jcmVtZW50YXRpb24gd291bGQgYmUgYmV0dGVyLlxuICAgIHRyYW5zZm9ybUtleXMubGVuZ3RoID0gMDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIHdlIGVuY291bnRlciBhbnkgdHJhbnNmb3JtIG9yIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMuXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgIHZhciBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgICAvLyBEb2VzIHRoZSBjYWxjdWxhdGVkIHRyYW5zZm9ybSBlc3NlbnRpYWxseSBlcXVhbCBcIm5vbmVcIj9cbiAgICB2YXIgdHJhbnNmb3JtSXNOb25lID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBMb29wIG92ZXIgYWxsIG91ciBsYXRlc3QgYW5pbWF0ZWQgdmFsdWVzIGFuZCBkZWNpZGUgd2hldGhlciB0byBoYW5kbGUgdGhlbVxuICAgICAqIGFzIGEgc3R5bGUgb3IgQ1NTIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVHJhbnNmb3JtcyBhbmQgdHJhbnNmb3JtIG9yaWdpbnMgYXJlIGtlcHQgc2VwZXJhdGVseSBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIGZvciAodmFyIGtleSBpbiBsYXRlc3RWYWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIGEgQ1NTIHZhcmlhYmxlIHdlIGRvbid0IGRvIGFueSBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZSQxKGtleSkpIHtcbiAgICAgICAgICAgIHZhcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gaXRzIGRlZmF1bHQgdmFsdWUgdHlwZSwgaWUgMCAtPiBcIjBweFwiXG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSBudW1iZXJWYWx1ZVR5cGVzW2tleV07XG4gICAgICAgIHZhciB2YWx1ZUFzVHlwZSA9IGdldFZhbHVlQXNUeXBlKHZhbHVlLCB2YWx1ZVR5cGUpO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0cmFuc2Zvcm0sIGZsYWcgdG8gZW5hYmxlIGZ1cnRoZXIgdHJhbnNmb3JtIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGhhc1RyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICB0cmFuc2Zvcm1ba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgdHJhbnNmb3JtS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGtub3cgd2UgaGF2ZSBhIG5vbi1kZWZhdWx0IHRyYW5zZm9ybSwgZWFybHkgcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybUlzTm9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIGRlZmF1bHQgdHJhbnNmb3JtXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICgoX2EgPSB2YWx1ZVR5cGUuZGVmYXVsdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkpXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSXNOb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbltrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdHJhbnNmb3JtIG9yaWdpbiwgZmxhZyBhbmQgZW5hYmxlIGZ1cnRoZXIgdHJhbnNmb3JtLW9yaWdpbiBwcm9jZXNzaW5nXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm1PcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gYnVpbGRUcmFuc2Zvcm0oc3RhdGUsIG9wdGlvbnMsIHRyYW5zZm9ybUlzTm9uZSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFsYXRlc3RWYWx1ZXMudHJhbnNmb3JtICYmIHN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBidWlsZFRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIH1cbn1cblxudmFyIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgc3R5bGU6IHt9LFxuICAgIHRyYW5zZm9ybToge30sXG4gICAgdHJhbnNmb3JtS2V5czogW10sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB7fSxcbiAgICB2YXJzOiB7fSxcbn0pOyB9O1xuXG5mdW5jdGlvbiBjb3B5UmF3VmFsdWVzT25seSh0YXJnZXQsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKF9hLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSBfYS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIHZpc3VhbFN0YXRlLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiAhaXNTdGF0aWMgfSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICB2YXIgdmFycyA9IHN0YXRlLnZhcnMsIHN0eWxlID0gc3RhdGUuc3R5bGU7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdmFycyksIHN0eWxlKTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICB2YXIgc3R5bGVQcm9wID0gcHJvcHMuc3R5bGUgfHwge307XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgLyoqXG4gICAgICogQ29weSBub24tTW90aW9uIFZhbHVlcyBzdHJhaWdodCBpbnRvIHN0eWxlXG4gICAgICovXG4gICAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykpO1xuICAgIGlmIChwcm9wcy50cmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgICAgc3R5bGUgPSBwcm9wcy50cmFuc2Zvcm1WYWx1ZXMoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiB1c2VIVE1MUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICAgIC8vIFRoZSBgYW55YCBpc24ndCBpZGVhbCBidXQgaXQgaXMgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBwcm9wcyBhcmd1bWVudFxuICAgIHZhciBodG1sUHJvcHMgPSB7fTtcbiAgICB2YXIgc3R5bGUgPSB1c2VTdHlsZShwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKTtcbiAgICBpZiAoQm9vbGVhbihwcm9wcy5kcmFnKSAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGdob3N0IGVsZW1lbnQgd2hlbiBhIHVzZXIgZHJhZ3NcbiAgICAgICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uXG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9XG4gICAgICAgICAgICAgICAgc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCI7XG4gICAgICAgIC8vIERpc2FibGUgc2Nyb2xsaW5nIG9uIHRoZSBkcmFnZ2FibGUgZGlyZWN0aW9uXG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID1cbiAgICAgICAgICAgIHByb3BzLmRyYWcgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgOiBcInBhbi1cIi5jb25jYXQocHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiKTtcbiAgICB9XG4gICAgaHRtbFByb3BzLnN0eWxlID0gc3R5bGU7XG4gICAgcmV0dXJuIGh0bWxQcm9wcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIHZhbGlkIE1vdGlvblByb3BzLlxuICpcbiAqIEBwcml2YXRlUmVtYXJrc1xuICogVGhpcyBkb2Vzbid0IHRocm93IGlmIGEgYE1vdGlvblByb3BgIG5hbWUgaXMgbWlzc2luZyAtIGl0IHNob3VsZC5cbiAqL1xudmFyIHZhbGlkTW90aW9uUHJvcHMgPSBuZXcgU2V0KFtcbiAgICBcImluaXRpYWxcIixcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImV4aXRcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJ2YXJpYW50c1wiLFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIFwidHJhbnNmb3JtVGVtcGxhdGVcIixcbiAgICBcInRyYW5zZm9ybVZhbHVlc1wiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbmhlcml0XCIsXG4gICAgXCJsYXlvdXRcIixcbiAgICBcImxheW91dElkXCIsXG4gICAgXCJsYXlvdXREZXBlbmRlbmN5XCIsXG4gICAgXCJvbkxheW91dEFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJvbkxheW91dE1lYXN1cmVcIixcbiAgICBcIm9uQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwib25BbmltYXRpb25TdGFydFwiLFxuICAgIFwib25BbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwib25VcGRhdGVcIixcbiAgICBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgXCJvbkRyYWdcIixcbiAgICBcIm9uRHJhZ0VuZFwiLFxuICAgIFwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzXCIsXG4gICAgXCJvbkRpcmVjdGlvbkxvY2tcIixcbiAgICBcIm9uRHJhZ1RyYW5zaXRpb25FbmRcIixcbiAgICBcImRyYWdcIixcbiAgICBcImRyYWdDb250cm9sc1wiLFxuICAgIFwiZHJhZ0xpc3RlbmVyXCIsXG4gICAgXCJkcmFnQ29uc3RyYWludHNcIixcbiAgICBcImRyYWdEaXJlY3Rpb25Mb2NrXCIsXG4gICAgXCJkcmFnU25hcFRvT3JpZ2luXCIsXG4gICAgXCJfZHJhZ1hcIixcbiAgICBcIl9kcmFnWVwiLFxuICAgIFwiZHJhZ0VsYXN0aWNcIixcbiAgICBcImRyYWdNb21lbnR1bVwiLFxuICAgIFwiZHJhZ1Byb3BhZ2F0aW9uXCIsXG4gICAgXCJkcmFnVHJhbnNpdGlvblwiLFxuICAgIFwid2hpbGVEcmFnXCIsXG4gICAgXCJvblBhblwiLFxuICAgIFwib25QYW5TdGFydFwiLFxuICAgIFwib25QYW5FbmRcIixcbiAgICBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsXG4gICAgXCJvblRhcFwiLFxuICAgIFwib25UYXBTdGFydFwiLFxuICAgIFwib25UYXBDYW5jZWxcIixcbiAgICBcIm9uSG92ZXJTdGFydFwiLFxuICAgIFwib25Ib3ZlckVuZFwiLFxuICAgIFwid2hpbGVGb2N1c1wiLFxuICAgIFwid2hpbGVUYXBcIixcbiAgICBcIndoaWxlSG92ZXJcIixcbiAgICBcIndoaWxlSW5WaWV3XCIsXG4gICAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgICBcIm9uVmlld3BvcnRMZWF2ZVwiLFxuICAgIFwidmlld3BvcnRcIixcbiAgICBcImxheW91dFNjcm9sbFwiLFxuXSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBwcm9wIG5hbWUgaXMgYSB2YWxpZCBgTW90aW9uUHJvcGAga2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVja1xuICogQHJldHVybnMgYHRydWVgIGlzIGtleSBpcyBhIHZhbGlkIGBNb3Rpb25Qcm9wYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkge1xuICAgIHJldHVybiB2YWxpZE1vdGlvblByb3BzLmhhcyhrZXkpO1xufVxuXG52YXIgc2hvdWxkRm9yd2FyZCA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpOyB9O1xuZnVuY3Rpb24gbG9hZEV4dGVybmFsSXNWYWxpZFByb3AoaXNWYWxpZFByb3ApIHtcbiAgICBpZiAoIWlzVmFsaWRQcm9wKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gRXhwbGljaXRseSBmaWx0ZXIgb3VyIGV2ZW50c1xuICAgIHNob3VsZEZvcndhcmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aChcIm9uXCIpID8gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkgOiBpc1ZhbGlkUHJvcChrZXkpO1xuICAgIH07XG59XG4vKipcbiAqIEVtb3Rpb24gYW5kIFN0eWxlZCBDb21wb25lbnRzIGJvdGggYWxsb3cgdXNlcnMgdG8gcGFzcyB0aHJvdWdoIGFyYml0cmFyeSBwcm9wcyB0byB0aGVpciBjb21wb25lbnRzXG4gKiB0byBkeW5hbWljYWxseSBnZW5lcmF0ZSBDU1MuIFRoZXkgYm90aCB1c2UgdGhlIGBAZW1vdGlvbi9pcy1wcm9wLXZhbGlkYCBwYWNrYWdlIHRvIGRldGVybWluZSB3aGljaFxuICogb2YgdGhlc2Ugc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS5cbiAqXG4gKiBIb3dldmVyLCB3aGVuIHN0eWxpbmcgYSBNb3Rpb24gY29tcG9uZW50IGBzdHlsZWQobW90aW9uLmRpdilgLCBib3RoIHBhY2thZ2VzIHBhc3MgdGhyb3VnaCAqYWxsKiBwcm9wc1xuICogYXMgaXQncyBzZWVuIGFzIGFuIGFyYml0cmFyeSBjb21wb25lbnQgcmF0aGVyIHRoYW4gYSBET00gbm9kZS4gTW90aW9uIG9ubHkgYWxsb3dzIGFyYml0cmFyeSBwcm9wc1xuICogcGFzc2VkIHRocm91Z2ggdGhlIGBjdXN0b21gIHByb3Agc28gaXQgZG9lc24ndCAqbmVlZCogdGhlIHBheWxvYWQgb3IgY29tcHV0YXRpb25hbCBvdmVyaGVhZCBvZlxuICogYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgLCBob3dldmVyIHRvIGZpeCB0aGlzIHByb2JsZW0gd2UgbmVlZCB0byB1c2UgaXQuXG4gKlxuICogQnkgbWFraW5nIGl0IGFuIG9wdGlvbmFsRGVwZW5kZW5jeSB3ZSBjYW4gb2ZmZXIgdGhpcyBmdW5jdGlvbmFsaXR5IG9ubHkgaW4gdGhlIHNpdHVhdGlvbnMgd2hlcmUgaXQnc1xuICogYWN0dWFsbHkgcmVxdWlyZWQuXG4gKi9cbnRyeSB7XG4gICAgLyoqXG4gICAgICogV2UgYXR0ZW1wdCB0byBpbXBvcnQgdGhpcyBwYWNrYWdlIGJ1dCByZXF1aXJlIHdvbid0IGJlIGRlZmluZWQgaW4gZXNtIGVudmlyb25tZW50cywgaW4gdGhhdCBjYXNlXG4gICAgICogaXNQcm9wVmFsaWQgd2lsbCBoYXZlIHRvIGJlIHByb3ZpZGVkIHZpYSBgTW90aW9uQ29udGV4dGAuIEluIGEgNi4wLjAgdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZFxuICAgICAqIGluIGZhdm91ciBvZiBleHBsaWNpdCBpbmplY3Rpb24uXG4gICAgICovXG4gICAgbG9hZEV4dGVybmFsSXNWYWxpZFByb3AocmVxdWlyZShcIkBlbW90aW9uL2lzLXByb3AtdmFsaWRcIikuZGVmYXVsdCk7XG59XG5jYXRjaCAoX2EpIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGFjdHVhbGx5IGRvIGFueXRoaW5nIGhlcmUgLSB0aGUgZmFsbGJhY2sgaXMgdGhlIGV4aXN0aW5nIGBpc1Byb3BWYWxpZGAuXG59XG5mdW5jdGlvbiBmaWx0ZXJQcm9wcyhwcm9wcywgaXNEb20sIGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICAgIHZhciBmaWx0ZXJlZFByb3BzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChzaG91bGRGb3J3YXJkKGtleSkgfHxcbiAgICAgICAgICAgIChmb3J3YXJkTW90aW9uUHJvcHMgPT09IHRydWUgJiYgaXNWYWxpZE1vdGlvblByb3Aoa2V5KSkgfHxcbiAgICAgICAgICAgICghaXNEb20gJiYgIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkpIHx8XG4gICAgICAgICAgICAvLyBJZiB0cnlpbmcgdG8gdXNlIG5hdGl2ZSBIVE1MIGRyYWcgZXZlbnRzLCBmb3J3YXJkIGRyYWcgbGlzdGVuZXJzXG4gICAgICAgICAgICAocHJvcHNbXCJkcmFnZ2FibGVcIl0gJiYga2V5LnN0YXJ0c1dpdGgoXCJvbkRyYWdcIikpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZFByb3BzO1xufVxuXG5mdW5jdGlvbiBjYWxjT3JpZ2luJDEob3JpZ2luLCBvZmZzZXQsIHNpemUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IG9yaWdpblxuICAgICAgICA6IHN0eWxlVmFsdWVUeXBlcy5weC50cmFuc2Zvcm0ob2Zmc2V0ICsgc2l6ZSAqIG9yaWdpbik7XG59XG4vKipcbiAqIFRoZSBTVkcgdHJhbnNmb3JtIG9yaWdpbiBkZWZhdWx0cyBhcmUgZGlmZmVyZW50IHRvIENTUyBhbmQgaXMgbGVzcyBpbnR1aXRpdmUsXG4gKiBzbyB3ZSB1c2UgdGhlIG1lYXN1cmVkIGRpbWVuc2lvbnMgb2YgdGhlIFNWRyB0byByZWNvbmNpbGUgdGhlc2UuXG4gKi9cbmZ1bmN0aW9uIGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgIHZhciBweE9yaWdpblggPSBjYWxjT3JpZ2luJDEob3JpZ2luWCwgZGltZW5zaW9ucy54LCBkaW1lbnNpb25zLndpZHRoKTtcbiAgICB2YXIgcHhPcmlnaW5ZID0gY2FsY09yaWdpbiQxKG9yaWdpblksIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChweE9yaWdpblgsIFwiIFwiKS5jb25jYXQocHhPcmlnaW5ZKTtcbn1cblxudmFyIGRhc2hLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICAgIGFycmF5OiBcInN0cm9rZS1kYXNoYXJyYXlcIixcbn07XG52YXIgY2FtZWxLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG59O1xuLyoqXG4gKiBCdWlsZCBTVkcgcGF0aCBwcm9wZXJ0aWVzLiBVc2VzIHRoZSBwYXRoJ3MgbWVhc3VyZWQgbGVuZ3RoIHRvIGNvbnZlcnRcbiAqIG91ciBjdXN0b20gcGF0aExlbmd0aCwgcGF0aFNwYWNpbmcgYW5kIHBhdGhPZmZzZXQgaW50byBzdHJva2UtZGFzaG9mZnNldFxuICogYW5kIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG11dGF0aXZlIHRvIHJlZHVjZSBwZXItZnJhbWUgR0MuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU1ZHUGF0aChhdHRycywgbGVuZ3RoLCBzcGFjaW5nLCBvZmZzZXQsIHVzZURhc2hDYXNlKSB7XG4gICAgaWYgKHNwYWNpbmcgPT09IHZvaWQgMCkgeyBzcGFjaW5nID0gMTsgfVxuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgaWYgKHVzZURhc2hDYXNlID09PSB2b2lkIDApIHsgdXNlRGFzaENhc2UgPSB0cnVlOyB9XG4gICAgLy8gTm9ybWFsaXNlIHBhdGggbGVuZ3RoIGJ5IHNldHRpbmcgU1ZHIGF0dHJpYnV0ZSBwYXRoTGVuZ3RoIHRvIDFcbiAgICBhdHRycy5wYXRoTGVuZ3RoID0gMTtcbiAgICAvLyBXZSB1c2UgZGFzaCBjYXNlIHdoZW4gc2V0dGluZyBhdHRyaWJ1dGVzIGRpcmVjdGx5IHRvIHRoZSBET00gbm9kZSBhbmQgY2FtZWwgY2FzZVxuICAgIC8vIHdoZW4gZGVmaW5pbmcgcHJvcHMgb24gYSBSZWFjdCBjb21wb25lbnQuXG4gICAgdmFyIGtleXMgPSB1c2VEYXNoQ2FzZSA/IGRhc2hLZXlzIDogY2FtZWxLZXlzO1xuICAgIC8vIEJ1aWxkIHRoZSBkYXNoIG9mZnNldFxuICAgIGF0dHJzW2tleXMub2Zmc2V0XSA9IHN0eWxlVmFsdWVUeXBlcy5weC50cmFuc2Zvcm0oLW9mZnNldCk7XG4gICAgLy8gQnVpbGQgdGhlIGRhc2ggYXJyYXlcbiAgICB2YXIgcGF0aExlbmd0aCA9IHN0eWxlVmFsdWVUeXBlcy5weC50cmFuc2Zvcm0obGVuZ3RoKTtcbiAgICB2YXIgcGF0aFNwYWNpbmcgPSBzdHlsZVZhbHVlVHlwZXMucHgudHJhbnNmb3JtKHNwYWNpbmcpO1xuICAgIGF0dHJzW2tleXMuYXJyYXldID0gXCJcIi5jb25jYXQocGF0aExlbmd0aCwgXCIgXCIpLmNvbmNhdChwYXRoU3BhY2luZyk7XG59XG5cbi8qKlxuICogQnVpbGQgU1ZHIHZpc3VhbCBhdHRyYnV0ZXMsIGxpa2UgY3ggYW5kIHN0eWxlLnRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiBidWlsZFNWR0F0dHJzKHN0YXRlLCBfYSwgb3B0aW9ucywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICB2YXIgYXR0clggPSBfYS5hdHRyWCwgYXR0clkgPSBfYS5hdHRyWSwgb3JpZ2luWCA9IF9hLm9yaWdpblgsIG9yaWdpblkgPSBfYS5vcmlnaW5ZLCBwYXRoTGVuZ3RoID0gX2EucGF0aExlbmd0aCwgX2IgPSBfYS5wYXRoU3BhY2luZywgcGF0aFNwYWNpbmcgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iLCBfYyA9IF9hLnBhdGhPZmZzZXQsIHBhdGhPZmZzZXQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLCBcbiAgICAvLyBUaGlzIGlzIG9iamVjdCBjcmVhdGlvbiwgd2hpY2ggd2UgdHJ5IHRvIGF2b2lkIHBlci1mcmFtZS5cbiAgICBsYXRlc3QgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImF0dHJYXCIsIFwiYXR0cllcIiwgXCJvcmlnaW5YXCIsIFwib3JpZ2luWVwiLCBcInBhdGhMZW5ndGhcIiwgXCJwYXRoU3BhY2luZ1wiLCBcInBhdGhPZmZzZXRcIl0pO1xuICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0LCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgc3RhdGUuYXR0cnMgPSBzdGF0ZS5zdHlsZTtcbiAgICBzdGF0ZS5zdHlsZSA9IHt9O1xuICAgIHZhciBhdHRycyA9IHN0YXRlLmF0dHJzLCBzdHlsZSA9IHN0YXRlLnN0eWxlLCBkaW1lbnNpb25zID0gc3RhdGUuZGltZW5zaW9ucztcbiAgICAvKipcbiAgICAgKiBIb3dldmVyLCB3ZSBhcHBseSB0cmFuc2Zvcm1zIGFzIENTUyB0cmFuc2Zvcm1zLiBTbyBpZiB3ZSBkZXRlY3QgYSB0cmFuc2Zvcm0gd2UgdGFrZSBpdCBmcm9tIGF0dHJzXG4gICAgICogYW5kIGNvcHkgaXQgaW50byBzdHlsZS5cbiAgICAgKi9cbiAgICBpZiAoYXR0cnMudHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChkaW1lbnNpb25zKVxuICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gYXR0cnMudHJhbnNmb3JtO1xuICAgICAgICBkZWxldGUgYXR0cnMudHJhbnNmb3JtO1xuICAgIH1cbiAgICAvLyBQYXJzZSB0cmFuc2Zvcm1PcmlnaW5cbiAgICBpZiAoZGltZW5zaW9ucyAmJlxuICAgICAgICAob3JpZ2luWCAhPT0gdW5kZWZpbmVkIHx8IG9yaWdpblkgIT09IHVuZGVmaW5lZCB8fCBzdHlsZS50cmFuc2Zvcm0pKSB7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCAhPT0gdW5kZWZpbmVkID8gb3JpZ2luWCA6IDAuNSwgb3JpZ2luWSAhPT0gdW5kZWZpbmVkID8gb3JpZ2luWSA6IDAuNSk7XG4gICAgfVxuICAgIC8vIFRyZWF0IHgveSBub3QgYXMgc2hvcnRjdXRzIGJ1dCBhcyBhY3R1YWwgYXR0cmlidXRlc1xuICAgIGlmIChhdHRyWCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy54ID0gYXR0clg7XG4gICAgaWYgKGF0dHJZICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF0dHJzLnkgPSBhdHRyWTtcbiAgICAvLyBCdWlsZCBTVkcgcGF0aCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZFxuICAgIGlmIChwYXRoTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVpbGRTVkdQYXRoKGF0dHJzLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZywgcGF0aE9mZnNldCwgZmFsc2UpO1xuICAgIH1cbn1cblxudmFyIGNyZWF0ZVN2Z1JlbmRlclN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjcmVhdGVIdG1sUmVuZGVyU3RhdGUoKSksIHsgYXR0cnM6IHt9IH0pKTsgfTtcblxuZnVuY3Rpb24gdXNlU1ZHUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlKSB7XG4gICAgdmFyIHZpc3VhbFByb3BzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNyZWF0ZVN2Z1JlbmRlclN0YXRlKCk7XG4gICAgICAgIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIHZpc3VhbFN0YXRlLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9LCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc3RhdGUuYXR0cnMpLCB7IHN0eWxlOiB0c2xpYi5fX2Fzc2lnbih7fSwgc3RhdGUuc3R5bGUpIH0pO1xuICAgIH0sIFt2aXN1YWxTdGF0ZV0pO1xuICAgIGlmIChwcm9wcy5zdHlsZSkge1xuICAgICAgICB2YXIgcmF3U3R5bGVzID0ge307XG4gICAgICAgIGNvcHlSYXdWYWx1ZXNPbmx5KHJhd1N0eWxlcywgcHJvcHMuc3R5bGUsIHByb3BzKTtcbiAgICAgICAgdmlzdWFsUHJvcHMuc3R5bGUgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcmF3U3R5bGVzKSwgdmlzdWFsUHJvcHMuc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzdWFsUHJvcHM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMpIHtcbiAgICBpZiAoZm9yd2FyZE1vdGlvblByb3BzID09PSB2b2lkIDApIHsgZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2U7IH1cbiAgICB2YXIgdXNlUmVuZGVyID0gZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHByb2plY3Rpb25JZCwgcmVmLCBfYSwgaXNTdGF0aWMpIHtcbiAgICAgICAgdmFyIGxhdGVzdFZhbHVlcyA9IF9hLmxhdGVzdFZhbHVlcztcbiAgICAgICAgdmFyIHVzZVZpc3VhbFByb3BzID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICAgICAgPyB1c2VTVkdQcm9wc1xuICAgICAgICAgICAgOiB1c2VIVE1MUHJvcHM7XG4gICAgICAgIHZhciB2aXN1YWxQcm9wcyA9IHVzZVZpc3VhbFByb3BzKHByb3BzLCBsYXRlc3RWYWx1ZXMsIGlzU3RhdGljKTtcbiAgICAgICAgdmFyIGZpbHRlcmVkUHJvcHMgPSBmaWx0ZXJQcm9wcyhwcm9wcywgdHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIiwgZm9yd2FyZE1vdGlvblByb3BzKTtcbiAgICAgICAgdmFyIGVsZW1lbnRQcm9wcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBmaWx0ZXJlZFByb3BzKSwgdmlzdWFsUHJvcHMpLCB7IHJlZjogcmVmIH0pO1xuICAgICAgICBpZiAocHJvamVjdGlvbklkKSB7XG4gICAgICAgICAgICBlbGVtZW50UHJvcHNbXCJkYXRhLXByb2plY3Rpb24taWRcIl0gPSBwcm9qZWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50UHJvcHMpO1xuICAgIH07XG4gICAgcmV0dXJuIHVzZVJlbmRlcjtcbn1cblxudmFyIENBTUVMX0NBU0VfUEFUVEVSTiA9IC8oW2Etel0pKFtBLVpdKS9nO1xudmFyIFJFUExBQ0VfVEVNUExBVEUgPSBcIiQxLSQyXCI7XG4vKipcbiAqIENvbnZlcnQgY2FtZWxDYXNlIHRvIGRhc2gtY2FzZSBwcm9wZXJ0aWVzLlxuICovXG52YXIgY2FtZWxUb0Rhc2ggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKENBTUVMX0NBU0VfUEFUVEVSTiwgUkVQTEFDRV9URU1QTEFURSkudG9Mb3dlckNhc2UoKTtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlckhUTUwoZWxlbWVudCwgX2EsIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHZhciBzdHlsZSA9IF9hLnN0eWxlLCB2YXJzID0gX2EudmFycztcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlLCBwcm9qZWN0aW9uICYmIHByb2plY3Rpb24uZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3ApKTtcbiAgICAvLyBMb29wIG92ZXIgYW55IENTUyB2YXJpYWJsZXMgYW5kIGFzc2lnbiB0aG9zZS5cbiAgICBmb3IgKHZhciBrZXkgaW4gdmFycykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFyc1trZXldKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBzZXQgb2YgYXR0cmlidXRlIG5hbWVzIHRoYXQgYXJlIGFsd2F5cyByZWFkL3dyaXR0ZW4gYXMgY2FtZWwgY2FzZS5cbiAqL1xudmFyIGNhbWVsQ2FzZUF0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICBcImJhc2VGcmVxdWVuY3lcIixcbiAgICBcImRpZmZ1c2VDb25zdGFudFwiLFxuICAgIFwia2VybmVsTWF0cml4XCIsXG4gICAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gICAgXCJrZXlTcGxpbmVzXCIsXG4gICAgXCJrZXlUaW1lc1wiLFxuICAgIFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgICBcIm1hcmtlckhlaWdodFwiLFxuICAgIFwibWFya2VyV2lkdGhcIixcbiAgICBcIm51bU9jdGF2ZXNcIixcbiAgICBcInRhcmdldFhcIixcbiAgICBcInRhcmdldFlcIixcbiAgICBcInN1cmZhY2VTY2FsZVwiLFxuICAgIFwic3BlY3VsYXJDb25zdGFudFwiLFxuICAgIFwic3BlY3VsYXJFeHBvbmVudFwiLFxuICAgIFwic3RkRGV2aWF0aW9uXCIsXG4gICAgXCJ0YWJsZVZhbHVlc1wiLFxuICAgIFwidmlld0JveFwiLFxuICAgIFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcbiAgICBcInBhdGhMZW5ndGhcIixcbl0pO1xuXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUsIF9zdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICByZW5kZXJIVE1MKGVsZW1lbnQsIHJlbmRlclN0YXRlLCB1bmRlZmluZWQsIHByb2plY3Rpb24pO1xuICAgIGZvciAodmFyIGtleSBpbiByZW5kZXJTdGF0ZS5hdHRycykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSghY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXksIHJlbmRlclN0YXRlLmF0dHJzW2tleV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEocHJvcHMpIHtcbiAgICB2YXIgc3R5bGUgPSBwcm9wcy5zdHlsZTtcbiAgICB2YXIgbmV3VmFsdWVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHN0eWxlW2tleV0pIHx8IGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1trZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgbmV3VmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEocHJvcHMpO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShwcm9wc1trZXldKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEtleSA9IGtleSA9PT0gXCJ4XCIgfHwga2V5ID09PSBcInlcIiA/IFwiYXR0clwiICsga2V5LnRvVXBwZXJDYXNlKCkgOiBrZXk7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbdGFyZ2V0S2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuZnVuY3Rpb24gaXNBbmltYXRpb25Db250cm9scyh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBpc0tleWZyYW1lc1RhcmdldCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59O1xuXG52YXIgaXNDdXN0b21WYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odiAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Lm1peCAmJiB2LnRvVmFsdWUpO1xufTtcbnZhciByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAvLyBUT0RPIG1heWJlIHRocm93IGlmIHYubGVuZ3RoIC0gMSBpcyBwbGFjZWhvbGRlciB0b2tlbj9cbiAgICByZXR1cm4gaXNLZXlmcmFtZXNUYXJnZXQodikgPyB2W3YubGVuZ3RoIC0gMV0gfHwgMCA6IHY7XG59O1xuXG4vKipcbiAqIElmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1vdGlvblZhbHVlLCB0aGlzIHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3QgdGhlIHZhbHVlIGl0c2VsZlxuICpcbiAqIFRPRE86IFJlbW92ZSBhbmQgbW92ZSB0byBsaWJyYXJ5XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciB1bndyYXBwZWRWYWx1ZSA9IGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgICByZXR1cm4gaXNDdXN0b21WYWx1ZSh1bndyYXBwZWRWYWx1ZSlcbiAgICAgICAgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKClcbiAgICAgICAgOiB1bndyYXBwZWRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbWFrZVN0YXRlKF9hLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KSB7XG4gICAgdmFyIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcywgY3JlYXRlUmVuZGVyU3RhdGUgPSBfYS5jcmVhdGVSZW5kZXJTdGF0ZSwgb25Nb3VudCA9IF9hLm9uTW91bnQ7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgICBsYXRlc3RWYWx1ZXM6IG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKSxcbiAgICAgICAgcmVuZGVyU3RhdGU6IGNyZWF0ZVJlbmRlclN0YXRlKCksXG4gICAgfTtcbiAgICBpZiAob25Nb3VudCkge1xuICAgICAgICBzdGF0ZS5tb3VudCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gb25Nb3VudChwcm9wcywgaW5zdGFuY2UsIHN0YXRlKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxudmFyIG1ha2VVc2VWaXN1YWxTdGF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzLCBpc1N0YXRpYykge1xuICAgICAgICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29udGV4dCk7XG4gICAgICAgIHZhciBwcmVzZW5jZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY1xuICAgICAgICAgICAgPyBtYWtlU3RhdGUoY29uZmlnLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KVxuICAgICAgICAgICAgOiB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcbn07XG5mdW5jdGlvbiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlcykge1xuICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICB2YXIgYmxvY2tJbml0aWFsQW5pbWF0aW9uID0gKHByZXNlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBwcmVzZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlbmNlQ29udGV4dC5pbml0aWFsKSA9PT0gZmFsc2U7XG4gICAgdmFyIG1vdGlvblZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlcyhwcm9wcyk7XG4gICAgZm9yICh2YXIga2V5IGluIG1vdGlvblZhbHVlcykge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHJlc29sdmVNb3Rpb25WYWx1ZShtb3Rpb25WYWx1ZXNba2V5XSk7XG4gICAgfVxuICAgIHZhciBpbml0aWFsID0gcHJvcHMuaW5pdGlhbCwgYW5pbWF0ZSA9IHByb3BzLmFuaW1hdGU7XG4gICAgdmFyIGlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICB2YXIgaXNWYXJpYW50Tm9kZSA9IGNoZWNrSWZWYXJpYW50Tm9kZShwcm9wcyk7XG4gICAgaWYgKGNvbnRleHQgJiZcbiAgICAgICAgaXNWYXJpYW50Tm9kZSAmJlxuICAgICAgICAhaXNDb250cm9sbGluZ1ZhcmlhbnRzICYmXG4gICAgICAgIHByb3BzLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgICAgIGluaXRpYWwgIT09IG51bGwgJiYgaW5pdGlhbCAhPT0gdm9pZCAwID8gaW5pdGlhbCA6IChpbml0aWFsID0gY29udGV4dC5pbml0aWFsKTtcbiAgICAgICAgYW5pbWF0ZSAhPT0gbnVsbCAmJiBhbmltYXRlICE9PSB2b2lkIDAgPyBhbmltYXRlIDogKGFuaW1hdGUgPSBjb250ZXh0LmFuaW1hdGUpO1xuICAgIH1cbiAgICB2YXIgaW5pdGlhbEFuaW1hdGlvbklzQmxvY2tlZCA9IGJsb2NrSW5pdGlhbEFuaW1hdGlvbiB8fCBpbml0aWFsID09PSBmYWxzZTtcbiAgICB2YXIgdmFyaWFudFRvU2V0ID0gaW5pdGlhbEFuaW1hdGlvbklzQmxvY2tlZCA/IGFuaW1hdGUgOiBpbml0aWFsO1xuICAgIGlmICh2YXJpYW50VG9TZXQgJiZcbiAgICAgICAgdHlwZW9mIHZhcmlhbnRUb1NldCAhPT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgIWlzQW5pbWF0aW9uQ29udHJvbHModmFyaWFudFRvU2V0KSkge1xuICAgICAgICB2YXIgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kOyByZXNvbHZlZC50cmFuc2l0aW9uOyB2YXIgdGFyZ2V0ID0gdHNsaWIuX19yZXN0KHJlc29sdmVkLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUYWtlIGZpbmFsIGtleWZyYW1lIGlmIHRoZSBpbml0aWFsIGFuaW1hdGlvbiBpcyBibG9ja2VkIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBpbml0aWFsaXNlIGF0IHRoZSBlbmQgb2YgdGhhdCBibG9ja2VkIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluaXRpYWxBbmltYXRpb25Jc0Jsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVUYXJnZXQubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRhcmdldCA9IHZhbHVlVGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWVUYXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRyYW5zaXRpb25FbmQpXG4gICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuXG52YXIgc3ZnTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZVN2Z1JlbmRlclN0YXRlLFxuICAgICAgICBvbk1vdW50OiBmdW5jdGlvbiAocHJvcHMsIGluc3RhbmNlLCBfYSkge1xuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gX2EucmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcyA9IF9hLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRCQm94ID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGluc3RhbmNlLmdldEJCb3goKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTW9zdCBsaWtlbHkgdHJ5aW5nIHRvIG1lYXN1cmUgYW4gdW5yZW5kZXJlZCBlbGVtZW50IHVuZGVyIEZpcmVmb3hcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUpO1xuICAgICAgICB9LFxuICAgIH0pLFxufTtcblxudmFyIGh0bWxNb3Rpb25Db25maWcgPSB7XG4gICAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVIdG1sUmVuZGVyU3RhdGUsXG4gICAgfSksXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50LCBfYSwgcHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgX2IgPSBfYS5mb3J3YXJkTW90aW9uUHJvcHMsIGZvcndhcmRNb3Rpb25Qcm9wcyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgIHZhciBiYXNlQ29uZmlnID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICA/IHN2Z01vdGlvbkNvbmZpZ1xuICAgICAgICA6IGh0bWxNb3Rpb25Db25maWc7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBiYXNlQ29uZmlnKSwgeyBwcmVsb2FkZWRGZWF0dXJlczogcHJlbG9hZGVkRmVhdHVyZXMsIHVzZVJlbmRlcjogY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyksIGNyZWF0ZVZpc3VhbEVsZW1lbnQ6IGNyZWF0ZVZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3I6IHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIENvbXBvbmVudDogQ29tcG9uZW50IH0pO1xufVxuXG5leHBvcnRzLkFuaW1hdGlvblR5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEFuaW1hdGlvblR5cGUpIHtcbiAgICBBbmltYXRpb25UeXBlW1wiQW5pbWF0ZVwiXSA9IFwiYW5pbWF0ZVwiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJIb3ZlclwiXSA9IFwid2hpbGVIb3ZlclwiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJUYXBcIl0gPSBcIndoaWxlVGFwXCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkRyYWdcIl0gPSBcIndoaWxlRHJhZ1wiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJGb2N1c1wiXSA9IFwid2hpbGVGb2N1c1wiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJJblZpZXdcIl0gPSBcIndoaWxlSW5WaWV3XCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkV4aXRcIl0gPSBcImV4aXRcIjtcbn0pKGV4cG9ydHMuQW5pbWF0aW9uVHlwZSB8fCAoZXhwb3J0cy5BbmltYXRpb25UeXBlID0ge30pKTtcblxuZnVuY3Rpb24gYWRkRG9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTsgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG59XG4vKipcbiAqIEF0dGFjaGVzIGFuIGV2ZW50IGxpc3RlbmVyIGRpcmVjdGx5IHRvIHRoZSBwcm92aWRlZCBET00gZWxlbWVudC5cbiAqXG4gKiBCeXBhc3NpbmcgUmVhY3QncyBldmVudCBzeXN0ZW0gY2FuIGJlIGRlc2lyYWJsZSwgZm9yIGluc3RhbmNlIHdoZW4gYXR0YWNoaW5nIG5vbi1wYXNzaXZlXG4gKiBldmVudCBoYW5kbGVycy5cbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKVxuICpcbiAqIHVzZURvbUV2ZW50KHJlZiwgJ3doZWVsJywgb25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KVxuICpcbiAqIHJldHVybiA8ZGl2IHJlZj17cmVmfSAvPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHJlZiAtIFJlYWN0LlJlZk9iamVjdCB0aGF0J3MgYmVlbiBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBiaW5kIHRoZSBsaXN0ZW5lciB0by5cbiAqIEBwYXJhbSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB5b3Ugd2FudCBsaXN0ZW4gZm9yLlxuICogQHBhcmFtIGhhbmRsZXIgLSBGdW5jdGlvbiB0byBmaXJlIHdoZW4gcmVjZWl2aW5nIHRoZSBldmVudC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIGBFdmVudC5hZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZURvbUV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGhhbmRsZXIgJiYgZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZERvbUV2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbcmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnNdKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHByb3BzXG4gKiBAcGFyYW0gcmVmXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRm9jdXNHZXN0dXJlKF9hKSB7XG4gICAgdmFyIHdoaWxlRm9jdXMgPSBfYS53aGlsZUZvY3VzLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudDtcbiAgICB2YXIgb25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5Gb2N1cywgdHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoZXhwb3J0cy5BbmltYXRpb25UeXBlLkZvY3VzLCBmYWxzZSk7XG4gICAgfTtcbiAgICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50LCBcImZvY3VzXCIsIHdoaWxlRm9jdXMgPyBvbkZvY3VzIDogdW5kZWZpbmVkKTtcbiAgICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50LCBcImJsdXJcIiwgd2hpbGVGb2N1cyA/IG9uQmx1ciA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldmVudCkge1xuICAgIC8vIFBvaW50ZXJFdmVudCBpbmhlcml0cyBmcm9tIE1vdXNlRXZlbnQgc28gd2UgY2FuJ3QgdXNlIGEgc3RyYWlnaHQgaW5zdGFuY2VvZiBjaGVjay5cbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldmVudCBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudCkge1xuICAgICAgICByZXR1cm4gISEoZXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIik7XG4gICAgfVxuICAgIHJldHVybiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgaGFzVG91Y2hlcyA9ICEhZXZlbnQudG91Y2hlcztcbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuLyoqXG4gKiBGaWx0ZXJzIG91dCBldmVudHMgbm90IGF0dGFjaGVkIHRvIHRoZSBwcmltYXJ5IHBvaW50ZXIgKGN1cnJlbnRseSBsZWZ0IG1vdXNlIGJ1dHRvbilcbiAqIEBwYXJhbSBldmVudEhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gZmlsdGVyUHJpbWFyeVBvaW50ZXIoZXZlbnRIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaXNNb3VzZUV2ZW50ID0gZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50O1xuICAgICAgICB2YXIgaXNQcmltYXJ5UG9pbnRlciA9ICFpc01vdXNlRXZlbnQgfHxcbiAgICAgICAgICAgIChpc01vdXNlRXZlbnQgJiYgZXZlbnQuYnV0dG9uID09PSAwKTtcbiAgICAgICAgaWYgKGlzUHJpbWFyeVBvaW50ZXIpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIGRlZmF1bHRQYWdlUG9pbnQgPSB7IHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuZnVuY3Rpb24gcG9pbnRGcm9tVG91Y2goZSwgcG9pbnRUeXBlKSB7XG4gICAgaWYgKHBvaW50VHlwZSA9PT0gdm9pZCAwKSB7IHBvaW50VHlwZSA9IFwicGFnZVwiOyB9XG4gICAgdmFyIHByaW1hcnlUb3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBwb2ludCA9IHByaW1hcnlUb3VjaCB8fCBkZWZhdWx0UGFnZVBvaW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50W3BvaW50VHlwZSArIFwiWFwiXSxcbiAgICAgICAgeTogcG9pbnRbcG9pbnRUeXBlICsgXCJZXCJdLFxuICAgIH07XG59XG5mdW5jdGlvbiBwb2ludEZyb21Nb3VzZShwb2ludCwgcG9pbnRUeXBlKSB7XG4gICAgaWYgKHBvaW50VHlwZSA9PT0gdm9pZCAwKSB7IHBvaW50VHlwZSA9IFwicGFnZVwiOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgICAgICB5OiBwb2ludFtwb2ludFR5cGUgKyBcIllcIl0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIHBvaW50VHlwZSkge1xuICAgIGlmIChwb2ludFR5cGUgPT09IHZvaWQgMCkgeyBwb2ludFR5cGUgPSBcInBhZ2VcIjsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBpc1RvdWNoRXZlbnQoZXZlbnQpXG4gICAgICAgICAgICA/IHBvaW50RnJvbVRvdWNoKGV2ZW50LCBwb2ludFR5cGUpXG4gICAgICAgICAgICA6IHBvaW50RnJvbU1vdXNlKGV2ZW50LCBwb2ludFR5cGUpLFxuICAgIH07XG59XG52YXIgd3JhcEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIpIHtcbiAgICBpZiAoc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPT09IHZvaWQgMCkgeyBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA9IGZhbHNlOyB9XG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKGV2ZW50LCBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXJcbiAgICAgICAgPyBmaWx0ZXJQcmltYXJ5UG9pbnRlcihsaXN0ZW5lcilcbiAgICAgICAgOiBsaXN0ZW5lcjtcbn07XG5cbi8vIFdlIGNoZWNrIGZvciBldmVudCBzdXBwb3J0IHZpYSBmdW5jdGlvbnMgaW4gY2FzZSB0aGV5J3ZlIGJlZW4gbW9ja2VkIGJ5IGEgdGVzdGluZyBzdWl0ZS5cbnZhciBzdXBwb3J0c1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25wb2ludGVyZG93biA9PT0gbnVsbDtcbn07XG52YXIgc3VwcG9ydHNUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XG59O1xudmFyIHN1cHBvcnRzTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25tb3VzZWRvd24gPT09IG51bGw7XG59O1xuXG52YXIgbW91c2VFdmVudE5hbWVzID0ge1xuICAgIHBvaW50ZXJkb3duOiBcIm1vdXNlZG93blwiLFxuICAgIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICAgIHBvaW50ZXJ1cDogXCJtb3VzZXVwXCIsXG4gICAgcG9pbnRlcmNhbmNlbDogXCJtb3VzZWNhbmNlbFwiLFxuICAgIHBvaW50ZXJvdmVyOiBcIm1vdXNlb3ZlclwiLFxuICAgIHBvaW50ZXJvdXQ6IFwibW91c2VvdXRcIixcbiAgICBwb2ludGVyZW50ZXI6IFwibW91c2VlbnRlclwiLFxuICAgIHBvaW50ZXJsZWF2ZTogXCJtb3VzZWxlYXZlXCIsXG59O1xudmFyIHRvdWNoRXZlbnROYW1lcyA9IHtcbiAgICBwb2ludGVyZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gICAgcG9pbnRlcm1vdmU6IFwidG91Y2htb3ZlXCIsXG4gICAgcG9pbnRlcnVwOiBcInRvdWNoZW5kXCIsXG4gICAgcG9pbnRlcmNhbmNlbDogXCJ0b3VjaGNhbmNlbFwiLFxufTtcbmZ1bmN0aW9uIGdldFBvaW50ZXJFdmVudE5hbWUobmFtZSkge1xuICAgIGlmIChzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3VwcG9ydHNUb3VjaEV2ZW50cygpKSB7XG4gICAgICAgIHJldHVybiB0b3VjaEV2ZW50TmFtZXNbbmFtZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHN1cHBvcnRzTW91c2VFdmVudHMoKSkge1xuICAgICAgICByZXR1cm4gbW91c2VFdmVudE5hbWVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGFkZFBvaW50ZXJFdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBhZGREb21FdmVudCh0YXJnZXQsIGdldFBvaW50ZXJFdmVudE5hbWUoZXZlbnROYW1lKSwgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZVBvaW50ZXJFdmVudChyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHJldHVybiB1c2VEb21FdmVudChyZWYsIGdldFBvaW50ZXJFdmVudE5hbWUoZXZlbnROYW1lKSwgaGFuZGxlciAmJiB3cmFwSGFuZGxlcihoYW5kbGVyLCBldmVudE5hbWUgPT09IFwicG9pbnRlcmRvd25cIiksIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NrKG5hbWUpIHtcbiAgICB2YXIgbG9jayA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wZW5Mb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG9jayA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChsb2NrID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2NrID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBvcGVuTG9jaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbnZhciBnbG9iYWxIb3Jpem9udGFsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnSG9yaXpvbnRhbFwiKTtcbnZhciBnbG9iYWxWZXJ0aWNhbExvY2sgPSBjcmVhdGVMb2NrKFwiZHJhZ1ZlcnRpY2FsXCIpO1xuZnVuY3Rpb24gZ2V0R2xvYmFsTG9jayhkcmFnKSB7XG4gICAgdmFyIGxvY2sgPSBmYWxzZTtcbiAgICBpZiAoZHJhZyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgbG9jayA9IGdsb2JhbFZlcnRpY2FsTG9jaygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkcmFnID09PSBcInhcIikge1xuICAgICAgICBsb2NrID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBvcGVuSG9yaXpvbnRhbF8xID0gZ2xvYmFsSG9yaXpvbnRhbExvY2soKTtcbiAgICAgICAgdmFyIG9wZW5WZXJ0aWNhbF8xID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gICAgICAgIGlmIChvcGVuSG9yaXpvbnRhbF8xICYmIG9wZW5WZXJ0aWNhbF8xKSB7XG4gICAgICAgICAgICBsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9wZW5Ib3Jpem9udGFsXzEoKTtcbiAgICAgICAgICAgICAgICBvcGVuVmVydGljYWxfMSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbGVhc2UgdGhlIGxvY2tzIGJlY2F1c2Ugd2UgZG9uJ3QgdXNlIHRoZW1cbiAgICAgICAgICAgIGlmIChvcGVuSG9yaXpvbnRhbF8xKVxuICAgICAgICAgICAgICAgIG9wZW5Ib3Jpem9udGFsXzEoKTtcbiAgICAgICAgICAgIGlmIChvcGVuVmVydGljYWxfMSlcbiAgICAgICAgICAgICAgICBvcGVuVmVydGljYWxfMSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NrO1xufVxuZnVuY3Rpb24gaXNEcmFnQWN0aXZlKCkge1xuICAgIC8vIENoZWNrIHRoZSBnZXN0dXJlIGxvY2sgLSBpZiB3ZSBnZXQgaXQsIGl0IG1lYW5zIG5vIGRyYWcgZ2VzdHVyZSBpcyBhY3RpdmVcbiAgICAvLyBhbmQgd2UgY2FuIHNhZmVseSBmaXJlIHRoZSB0YXAgZ2VzdHVyZS5cbiAgICB2YXIgb3Blbkdlc3R1cmVMb2NrID0gZ2V0R2xvYmFsTG9jayh0cnVlKTtcbiAgICBpZiAoIW9wZW5HZXN0dXJlTG9jaylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgb3Blbkdlc3R1cmVMb2NrKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3ZlckV2ZW50KHZpc3VhbEVsZW1lbnQsIGlzQWN0aXZlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWlzTW91c2VFdmVudChldmVudCkgfHwgaXNEcmFnQWN0aXZlKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmUgd2UgdHJpZ2dlciBhbmltYXRpb25zIGJlZm9yZSBmaXJpbmcgZXZlbnQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoZXhwb3J0cy5BbmltYXRpb25UeXBlLkhvdmVyLCBpc0FjdGl2ZSk7XG4gICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhldmVudCwgaW5mbyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUhvdmVyR2VzdHVyZShfYSkge1xuICAgIHZhciBvbkhvdmVyU3RhcnQgPSBfYS5vbkhvdmVyU3RhcnQsIG9uSG92ZXJFbmQgPSBfYS5vbkhvdmVyRW5kLCB3aGlsZUhvdmVyID0gX2Eud2hpbGVIb3ZlciwgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmVudGVyXCIsIG9uSG92ZXJTdGFydCB8fCB3aGlsZUhvdmVyXG4gICAgICAgID8gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCB0cnVlLCBvbkhvdmVyU3RhcnQpXG4gICAgICAgIDogdW5kZWZpbmVkLCB7IHBhc3NpdmU6ICFvbkhvdmVyU3RhcnQgfSk7XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmxlYXZlXCIsIG9uSG92ZXJFbmQgfHwgd2hpbGVIb3ZlclxuICAgICAgICA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgZmFsc2UsIG9uSG92ZXJFbmQpXG4gICAgICAgIDogdW5kZWZpbmVkLCB7IHBhc3NpdmU6ICFvbkhvdmVyRW5kIH0pO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHVwIHRoZSB0cmVlIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNoaWxkIG5vZGVcbiAqIGlzIHRoZSBwYXJlbnQgb3IgYSBkZXNjZW5kYW50IG9mIGl0LlxuICpcbiAqIEBwYXJhbSBwYXJlbnQgLSBFbGVtZW50IHRvIGZpbmRcbiAqIEBwYXJhbSBjaGlsZCAtIEVsZW1lbnQgdG8gdGVzdCBhZ2FpbnN0IHBhcmVudFxuICovXG52YXIgaXNOb2RlT3JDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudCA9PT0gY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNOb2RlT3JDaGlsZChwYXJlbnQsIGNoaWxkLnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHVzZVVubW91bnRFZmZlY3QoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH07IH0sIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gaGFuZGxlcnMgLVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVRhcEdlc3R1cmUoX2EpIHtcbiAgICB2YXIgb25UYXAgPSBfYS5vblRhcCwgb25UYXBTdGFydCA9IF9hLm9uVGFwU3RhcnQsIG9uVGFwQ2FuY2VsID0gX2Eub25UYXBDYW5jZWwsIHdoaWxlVGFwID0gX2Eud2hpbGVUYXAsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIHZhciBoYXNQcmVzc0xpc3RlbmVycyA9IG9uVGFwIHx8IG9uVGFwU3RhcnQgfHwgb25UYXBDYW5jZWwgfHwgd2hpbGVUYXA7XG4gICAgdmFyIGlzUHJlc3NpbmcgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIHZhciBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIC8qKlxuICAgICAqIE9ubHkgc2V0IGxpc3RlbmVyIHRvIHBhc3NpdmUgaWYgdGhlcmUgYXJlIG5vIGV4dGVybmFsIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICB2YXIgZXZlbnRPcHRpb25zID0ge1xuICAgICAgICBwYXNzaXZlOiAhKG9uVGFwU3RhcnQgfHwgb25UYXAgfHwgb25UYXBDYW5jZWwgfHwgb25Qb2ludGVyRG93biksXG4gICAgfTtcbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzKTtcbiAgICAgICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRW5kKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgICAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuVGFwLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAhaXNEcmFnQWN0aXZlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBvbmx5IGNvdW50IHRoaXMgYXMgYSB0YXAgZ2VzdHVyZSBpZiB0aGUgZXZlbnQudGFyZ2V0IGlzIHRoZSBzYW1lXG4gICAgICAgICAqIGFzLCBvciBhIGNoaWxkIG9mLCB0aGlzIGNvbXBvbmVudCdzIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgICFpc05vZGVPckNoaWxkKHZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKSwgZXZlbnQudGFyZ2V0KVxuICAgICAgICAgICAgPyBvblRhcENhbmNlbCA9PT0gbnVsbCB8fCBvblRhcENhbmNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UYXBDYW5jZWwoZXZlbnQsIGluZm8pXG4gICAgICAgICAgICA6IG9uVGFwID09PSBudWxsIHx8IG9uVGFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRhcChldmVudCwgaW5mbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckNhbmNlbChldmVudCwgaW5mbykge1xuICAgICAgICBpZiAoIWNoZWNrUG9pbnRlckVuZCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvblRhcENhbmNlbCA9PT0gbnVsbCB8fCBvblRhcENhbmNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UYXBDYW5jZWwoZXZlbnQsIGluZm8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKCk7XG4gICAgICAgIGlmIChpc1ByZXNzaW5nLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCA9IHBvcG1vdGlvbi5waXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBldmVudE9wdGlvbnMpLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyQ2FuY2VsLCBldmVudE9wdGlvbnMpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZSB3ZSB0cmlnZ2VyIGFuaW1hdGlvbnMgYmVmb3JlIGZpcmluZyBldmVudCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuVGFwLCB0cnVlKTtcbiAgICAgICAgb25UYXBTdGFydCA9PT0gbnVsbCB8fCBvblRhcFN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRhcFN0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgaGFzUHJlc3NMaXN0ZW5lcnMgPyBvblBvaW50ZXJEb3duIDogdW5kZWZpbmVkLCBldmVudE9wdGlvbnMpO1xuICAgIHVzZVVubW91bnRFZmZlY3QocmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKTtcbn1cblxudmFyIHdhcm5lZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHdhcm5PbmNlKGNvbmRpdGlvbiwgbWVzc2FnZSwgZWxlbWVudCkge1xuICAgIGlmIChjb25kaXRpb24gfHwgd2FybmVkLmhhcyhtZXNzYWdlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICBpZiAoZWxlbWVudClcbiAgICAgICAgY29uc29sZS53YXJuKGVsZW1lbnQpO1xuICAgIHdhcm5lZC5hZGQobWVzc2FnZSk7XG59XG5cbi8qKlxuICogTWFwIGFuIEludGVyc2VjdGlvbkhhbmRsZXIgY2FsbGJhY2sgdG8gYW4gZWxlbWVudC4gV2Ugb25seSBldmVyIG1ha2Ugb25lIGhhbmRsZXIgZm9yIG9uZVxuICogZWxlbWVudCwgc28gZXZlbiB0aG91Z2ggdGhlc2UgaGFuZGxlcnMgbWlnaHQgYWxsIGJlIHRyaWdnZXJlZCBieSBkaWZmZXJlbnRcbiAqIG9ic2VydmVycywgd2UgY2FuIGtlZXAgdGhlbSBpbiB0aGUgc2FtZSBtYXAuXG4gKi9cbnZhciBvYnNlcnZlckNhbGxiYWNrcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIE11bHRpcGxlIG9ic2VydmVycyBjYW4gYmUgY3JlYXRlZCBmb3IgbXVsdGlwbGUgZWxlbWVudC9kb2N1bWVudCByb290cy4gRWFjaCB3aXRoXG4gKiBkaWZmZXJlbnQgc2V0dGluZ3MuIFNvIGhlcmUgd2Ugc3RvcmUgZGljdGlvbmFyaWVzIG9mIG9ic2VydmVycyB0byBlYWNoIHJvb3QsXG4gKiB1c2luZyBzZXJpYWxpc2VkIHNldHRpbmdzICh0aHJlc2hvbGQvbWFyZ2luKSBhcyBsb29rdXAga2V5cy5cbiAqL1xudmFyIG9ic2VydmVycyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgZmlyZU9ic2VydmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gb2JzZXJ2ZXJDYWxsYmFja3MuZ2V0KGVudHJ5LnRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShlbnRyeSk7XG59O1xudmFyIGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcyA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgZW50cmllcy5mb3JFYWNoKGZpcmVPYnNlcnZlckNhbGxiYWNrKTtcbn07XG5mdW5jdGlvbiBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoX2EpIHtcbiAgICB2YXIgcm9vdCA9IF9hLnJvb3QsIG9wdGlvbnMgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInJvb3RcIl0pO1xuICAgIHZhciBsb29rdXBSb290ID0gcm9vdCB8fCBkb2N1bWVudDtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGxvb2t1cCBtYXAgZm9yIHRoaXMgcm9vdCwgY3JlYXRlIG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIW9ic2VydmVycy5oYXMobG9va3VwUm9vdCkpIHtcbiAgICAgICAgb2JzZXJ2ZXJzLnNldChsb29rdXBSb290LCB7fSk7XG4gICAgfVxuICAgIHZhciByb290T2JzZXJ2ZXJzID0gb2JzZXJ2ZXJzLmdldChsb29rdXBSb290KTtcbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhbiBvYnNlcnZlciBmb3IgdGhpcyBjb21iaW5hdGlvbiBvZiByb290IGFuZCBzZXR0aW5ncyxcbiAgICAgKiBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghcm9vdE9ic2VydmVyc1trZXldKSB7XG4gICAgICAgIHJvb3RPYnNlcnZlcnNba2V5XSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MsIHRzbGliLl9fYXNzaWduKHsgcm9vdDogcm9vdCB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiByb290T2JzZXJ2ZXJzW2tleV07XG59XG5mdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIgPSBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIob3B0aW9ucyk7XG4gICAgb2JzZXJ2ZXJDYWxsYmFja3Muc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JzZXJ2ZXJDYWxsYmFja3MuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB1c2VWaWV3cG9ydChfYSkge1xuICAgIHZhciB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgd2hpbGVJblZpZXcgPSBfYS53aGlsZUluVmlldywgb25WaWV3cG9ydEVudGVyID0gX2Eub25WaWV3cG9ydEVudGVyLCBvblZpZXdwb3J0TGVhdmUgPSBfYS5vblZpZXdwb3J0TGVhdmUsIF9iID0gX2Eudmlld3BvcnQsIHZpZXdwb3J0ID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgdmFyIHN0YXRlID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgaGFzRW50ZXJlZFZpZXc6IGZhbHNlLFxuICAgICAgICBpc0luVmlldzogZmFsc2UsXG4gICAgfSk7XG4gICAgdmFyIHNob3VsZE9ic2VydmUgPSBCb29sZWFuKHdoaWxlSW5WaWV3IHx8IG9uVmlld3BvcnRFbnRlciB8fCBvblZpZXdwb3J0TGVhdmUpO1xuICAgIGlmICh2aWV3cG9ydC5vbmNlICYmIHN0YXRlLmN1cnJlbnQuaGFzRW50ZXJlZFZpZXcpXG4gICAgICAgIHNob3VsZE9ic2VydmUgPSBmYWxzZTtcbiAgICB2YXIgdXNlT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgOiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICB1c2VPYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZS5jdXJyZW50LCB2aXN1YWxFbGVtZW50LCB2aWV3cG9ydCk7XG59XG52YXIgdGhyZXNob2xkTmFtZXMgPSB7XG4gICAgc29tZTogMCxcbiAgICBhbGw6IDEsXG59O1xuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIF9hKSB7XG4gICAgdmFyIHJvb3QgPSBfYS5yb290LCByb290TWFyZ2luID0gX2EubWFyZ2luLCBfYiA9IF9hLmFtb3VudCwgYW1vdW50ID0gX2IgPT09IHZvaWQgMCA/IFwic29tZVwiIDogX2IsIG9uY2UgPSBfYS5vbmNlO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvdWxkT2JzZXJ2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCxcbiAgICAgICAgICAgIHJvb3RNYXJnaW46IHJvb3RNYXJnaW4sXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGROYW1lc1thbW91bnRdLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIGJlZW4gbm8gY2hhbmdlIGluIHRoZSB2aWV3cG9ydCBzdGF0ZSwgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRlLmlzSW5WaWV3ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZSBoYXNFbnRlcmVkVmlldy4gSWYgdGhpcyBpcyBvbmx5IG1lYW50IHRvIHJ1biBvbmNlLCBhbmRcbiAgICAgICAgICAgICAqIGVsZW1lbnQgaXNuJ3QgdmlzaWJsZSwgZWFybHkgcmV0dXJuLiBPdGhlcndpc2Ugc2V0IGhhc0VudGVyZWRWaWV3IHRvIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvbmNlICYmICFpc0ludGVyc2VjdGluZyAmJiBzdGF0ZS5oYXNFbnRlcmVkVmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuSW5WaWV3LCBpc0ludGVyc2VjdGluZyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBwcm9wcyByYXRoZXIgdGhhbiB0aGUgb25lcyBpbiBzY29wZVxuICAgICAgICAgICAgICogd2hlbiB0aGlzIG9ic2VydmVyIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gaXNJbnRlcnNlY3RpbmdcbiAgICAgICAgICAgICAgICA/IHByb3BzLm9uVmlld3BvcnRFbnRlclxuICAgICAgICAgICAgICAgIDogcHJvcHMub25WaWV3cG9ydExlYXZlO1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVudHJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVJbnRlcnNlY3Rpb24odmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpLCBvcHRpb25zLCBpbnRlcnNlY3Rpb25DYWxsYmFjayk7XG4gICAgfSwgW3Nob3VsZE9ic2VydmUsIHJvb3QsIHJvb3RNYXJnaW4sIGFtb3VudF0pO1xufVxuLyoqXG4gKiBJZiBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBtaXNzaW5nLCB3ZSBhY3RpdmF0ZSBpblZpZXcgYW5kIGZpcmUgb25WaWV3cG9ydEVudGVyXG4gKiBvbiBtb3VudC4gVGhpcyB3YXksIHRoZSBwYWdlIHdpbGwgYmUgaW4gdGhlIHN0YXRlIHRoZSBhdXRob3IgZXhwZWN0cyB1c2Vyc1xuICogdG8gc2VlIGl0IGluIGZvciBldmVyeW9uZS5cbiAqL1xuZnVuY3Rpb24gdXNlTWlzc2luZ0ludGVyc2VjdGlvbk9ic2VydmVyKHNob3VsZE9ic2VydmUsIHN0YXRlLCB2aXN1YWxFbGVtZW50LCBfYSkge1xuICAgIHZhciBfYiA9IF9hLmZhbGxiYWNrLCBmYWxsYmFjayA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRPYnNlcnZlIHx8ICFmYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGVudiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGZhbHNlLCBcIkludGVyc2VjdGlvbk9ic2VydmVyIG5vdCBhdmFpbGFibGUgb24gdGhpcyBkZXZpY2UuIHdoaWxlSW5WaWV3IGFuaW1hdGlvbnMgd2lsbCB0cmlnZ2VyIG9uIG1vdW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZSB0aGlzIGluIGFuIHJBRiBiZWNhdXNlLCBhdCB0aGlzIHBvaW50LCB0aGUgYW5pbWF0aW9uIHN0YXRlXG4gICAgICAgICAqIHdvbid0IGhhdmUgZmx1c2hlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kIHRoZXJlJ3MgY2VydGFpbiBsb2dpYyBpblxuICAgICAgICAgKiB0aGVyZSB0aGF0IGJlaGF2ZXMgZGlmZmVyZW50bHkgb24gdGhlIGluaXRpYWwgYW5pbWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGhvb2sgc2hvdWxkIGJlIHF1aXRlIHJhcmVseSBjYWxsZWQgc28gc2V0dGluZyB0aGlzIGluIGFuIHJBRlxuICAgICAgICAgKiBpcyBwcmVmZXJyZWQgdG8gY2hhbmdpbmcgdGhlIGJlaGF2aW91ciBvZiB0aGUgYW5pbWF0aW9uIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHN0YXRlLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvblZpZXdwb3J0RW50ZXIgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkub25WaWV3cG9ydEVudGVyO1xuICAgICAgICAgICAgb25WaWV3cG9ydEVudGVyID09PSBudWxsIHx8IG9uVmlld3BvcnRFbnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25WaWV3cG9ydEVudGVyKG51bGwpO1xuICAgICAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuSW5WaWV3LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3Nob3VsZE9ic2VydmVdKTtcbn1cblxudmFyIG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGhvb2socHJvcHMpO1xuICAgIHJldHVybiBudWxsO1xufTsgfTtcblxudmFyIGdlc3R1cmVBbmltYXRpb25zID0ge1xuICAgIGluVmlldzogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlVmlld3BvcnQpLFxuICAgIHRhcDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlVGFwR2VzdHVyZSksXG4gICAgZm9jdXM6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZUZvY3VzR2VzdHVyZSksXG4gICAgaG92ZXI6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZUhvdmVyR2VzdHVyZSksXG59O1xuXG52YXIgY291bnRlciA9IDA7XG52YXIgaW5jcmVtZW50SWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudGVyKys7IH07XG52YXIgdXNlSWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VDb25zdGFudChpbmNyZW1lbnRJZCk7IH07XG4vKipcbiAqIElkZWFsbHkgd2UnZCB1c2UgdGhlIGZvbGxvd2luZyBjb2RlIHRvIHN1cHBvcnQgUmVhY3QgMTggb3B0aW9uYWxseS5cbiAqIEJ1dCB0aGlzIGZhaXJseSBmYWlscyBpbiBXZWJwYWNrIChvdGhlcndpc2UgdHJlZXNoYWtpbmcgd291bGRuJ3Qgd29yayBhdCBhbGwpLlxuICogTmVlZCB0byBjb21lIHVwIHdpdGggYSBkaWZmZXJlbnQgd2F5IG9mIGZpZ3VyaW5nIHRoaXMgb3V0LlxuICovXG4vLyBleHBvcnQgY29uc3QgdXNlSWQgPSAoUmVhY3QgYXMgYW55KS51c2VJZFxuLy8gICAgID8gKFJlYWN0IGFzIGFueSkudXNlSWRcbi8vICAgICA6ICgpID0+IHVzZUNvbnN0YW50KGluY3JlbWVudElkKVxuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgdGhlIGNoaWxkIG9mIGBBbmltYXRlUHJlc2VuY2VgLCBpdCBjYW4gdXNlIGB1c2VQcmVzZW5jZWBcbiAqIHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCB3aGV0aGVyIGl0J3Mgc3RpbGwgcHJlc2VudCBpbiB0aGUgUmVhY3QgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpXG4gKlxuICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgICFpc1ByZXNlbnQgJiYgc2V0VGltZW91dChzYWZlVG9SZW1vdmUsIDEwMDApXG4gKiAgIH0sIFtpc1ByZXNlbnRdKVxuICpcbiAqICAgcmV0dXJuIDxkaXYgLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIElmIGBpc1ByZXNlbnRgIGlzIGBmYWxzZWAsIGl0IG1lYW5zIHRoYXQgYSBjb21wb25lbnQgaGFzIGJlZW4gcmVtb3ZlZCB0aGUgdHJlZSwgYnV0XG4gKiBgQW5pbWF0ZVByZXNlbmNlYCB3b24ndCByZWFsbHkgcmVtb3ZlIGl0IHVudGlsIGBzYWZlVG9SZW1vdmVgIGhhcyBiZWVuIGNhbGxlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVByZXNlbmNlKCkge1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gW3RydWUsIG51bGxdO1xuICAgIHZhciBpc1ByZXNlbnQgPSBjb250ZXh0LmlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUgPSBjb250ZXh0Lm9uRXhpdENvbXBsZXRlLCByZWdpc3RlciA9IGNvbnRleHQucmVnaXN0ZXI7XG4gICAgLy8gSXQncyBzYWZlIHRvIGNhbGwgdGhlIGZvbGxvd2luZyBob29rcyBjb25kaXRpb25hbGx5IChhZnRlciBhbiBlYXJseSByZXR1cm4pIGJlY2F1c2UgdGhlIGNvbnRleHQgd2lsbCBhbHdheXNcbiAgICAvLyBlaXRoZXIgYmUgbnVsbCBvciBub24tbnVsbCBmb3IgdGhlIGxpZmVzcGFuIG9mIHRoZSBjb21wb25lbnQuXG4gICAgLy8gUmVwbGFjZSB3aXRoIHVzZUlkIHdoZW4gcmVsZWFzZWQgaW4gUmVhY3RcbiAgICB2YXIgaWQgPSB1c2VJZCgpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RlcihpZCk7IH0sIFtdKTtcbiAgICB2YXIgc2FmZVRvUmVtb3ZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25FeGl0Q29tcGxldGUgPT09IG51bGwgfHwgb25FeGl0Q29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRXhpdENvbXBsZXRlKGlkKTsgfTtcbiAgICByZXR1cm4gIWlzUHJlc2VudCAmJiBvbkV4aXRDb21wbGV0ZSA/IFtmYWxzZSwgc2FmZVRvUmVtb3ZlXSA6IFt0cnVlXTtcbn1cbi8qKlxuICogU2ltaWxhciB0byBgdXNlUHJlc2VuY2VgLCBleGNlcHQgYHVzZUlzUHJlc2VudGAgc2ltcGx5IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyBwcmVzZW50LlxuICogVGhlcmUgaXMgbm8gYHNhZmVUb1JlbW92ZWAgZnVuY3Rpb24uXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyB1c2VJc1ByZXNlbnQgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgaXNQcmVzZW50ID0gdXNlSXNQcmVzZW50KClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBjb25zb2xlLmxvZyhcIkkndmUgYmVlbiByZW1vdmVkIVwiKVxuICogICB9LCBbaXNQcmVzZW50XSlcbiAqXG4gKiAgIHJldHVybiA8ZGl2IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZUlzUHJlc2VudCgpIHtcbiAgICByZXR1cm4gaXNQcmVzZW50KFJlYWN0LnVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KSk7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID09PSBudWxsID8gdHJ1ZSA6IGNvbnRleHQuaXNQcmVzZW50O1xufVxuXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHByZXZMZW5ndGggPSBwcmV2Lmxlbmd0aDtcbiAgICBpZiAocHJldkxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJldltpXSAhPT0gbmV4dFtpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29udmVydHMgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0gc2Vjb25kcyAtIFRpbWUgaW4gc2Vjb25kcy5cbiAqIEByZXR1cm4gbWlsbGlzZWNvbmRzIC0gQ29udmVydGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG52YXIgc2Vjb25kc1RvTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24gKHNlY29uZHMpIHsgcmV0dXJuIHNlY29uZHMgKiAxMDAwOyB9O1xuXG52YXIgZWFzaW5nTG9va3VwID0ge1xuICAgIGxpbmVhcjogcG9wbW90aW9uLmxpbmVhcixcbiAgICBlYXNlSW46IHBvcG1vdGlvbi5lYXNlSW4sXG4gICAgZWFzZUluT3V0OiBwb3Btb3Rpb24uZWFzZUluT3V0LFxuICAgIGVhc2VPdXQ6IHBvcG1vdGlvbi5lYXNlT3V0LFxuICAgIGNpcmNJbjogcG9wbW90aW9uLmNpcmNJbixcbiAgICBjaXJjSW5PdXQ6IHBvcG1vdGlvbi5jaXJjSW5PdXQsXG4gICAgY2lyY091dDogcG9wbW90aW9uLmNpcmNPdXQsXG4gICAgYmFja0luOiBwb3Btb3Rpb24uYmFja0luLFxuICAgIGJhY2tJbk91dDogcG9wbW90aW9uLmJhY2tJbk91dCxcbiAgICBiYWNrT3V0OiBwb3Btb3Rpb24uYmFja091dCxcbiAgICBhbnRpY2lwYXRlOiBwb3Btb3Rpb24uYW50aWNpcGF0ZSxcbiAgICBib3VuY2VJbjogcG9wbW90aW9uLmJvdW5jZUluLFxuICAgIGJvdW5jZUluT3V0OiBwb3Btb3Rpb24uYm91bmNlSW5PdXQsXG4gICAgYm91bmNlT3V0OiBwb3Btb3Rpb24uYm91bmNlT3V0LFxufTtcbnZhciBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgLy8gSWYgY3ViaWMgYmV6aWVyIGRlZmluaXRpb24sIGNyZWF0ZSBiZXppZXIgY3VydmVcbiAgICAgICAgaGV5TGlzdGVuLmludmFyaWFudChkZWZpbml0aW9uLmxlbmd0aCA9PT0gNCwgXCJDdWJpYyBiZXppZXIgYXJyYXlzIG11c3QgY29udGFpbiBmb3VyIG51bWVyaWNhbCB2YWx1ZXMuXCIpO1xuICAgICAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQoZGVmaW5pdGlvbiwgNCksIHgxID0gX2FbMF0sIHkxID0gX2FbMV0sIHgyID0gX2FbMl0sIHkyID0gX2FbM107XG4gICAgICAgIHJldHVybiBwb3Btb3Rpb24uY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBFbHNlIGxvb2t1cCBmcm9tIHRhYmxlXG4gICAgICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoZWFzaW5nTG9va3VwW2RlZmluaXRpb25dICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBlYXNpbmcgdHlwZSAnXCIuY29uY2F0KGRlZmluaXRpb24sIFwiJ1wiKSk7XG4gICAgICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcbnZhciBpc0Vhc2luZ0FycmF5ID0gZnVuY3Rpb24gKGVhc2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlYXNlKSAmJiB0eXBlb2YgZWFzZVswXSAhPT0gXCJudW1iZXJcIjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbmltYXRhYmxlLiBFeGFtcGxlczpcbiAqXG4gKiDinIU6IDEwMCwgXCIxMDBweFwiLCBcIiNmZmZcIlxuICog4p2MOiBcImJsb2NrXCIsIFwidXJsKDIuanBnKVwiXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIGlzQW5pbWF0YWJsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIGxpc3Qgb2Yga2V5cyB0YXQgbWlnaHQgYmUgbm9uLWFuaW1hdGFibGUgZ3Jvd3MsIHJlcGxhY2Ugd2l0aCBTZXRcbiAgICBpZiAoa2V5ID09PSBcInpJbmRleFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgaXQncyBhIG51bWJlciBvciBhIGtleWZyYW1lcyBhcnJheSwgd2UgY2FuIGFuaW1hdGUgaXQuIFdlIG1pZ2h0IGF0IHNvbWUgcG9pbnRcbiAgICAvLyBuZWVkIHRvIGRvIGEgZGVlcCBpc0FuaW1hdGFibGUgY2hlY2sgb2Yga2V5ZnJhbWVzLCBvciBsZXQgUG9wbW90aW9uIGhhbmRsZSB0aGlzLFxuICAgIC8vIGJ1dCBmb3Igbm93IGxldHMgbGVhdmUgaXQgbGlrZSB0aGlzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAvLyBJdCdzIGFuaW1hdGFibGUgaWYgd2UgaGF2ZSBhIHN0cmluZ1xuICAgICAgICBzdHlsZVZhbHVlVHlwZXMuY29tcGxleC50ZXN0KHZhbHVlKSAmJiAvLyBBbmQgaXQgY29udGFpbnMgbnVtYmVycyBhbmQvb3IgY29sb3JzXG4gICAgICAgICF2YWx1ZS5zdGFydHNXaXRoKFwidXJsKFwiKSAvLyBVbmxlc3MgaXQgc3RhcnRzIHdpdGggXCJ1cmwoXCJcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciB1bmRlckRhbXBlZFNwcmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICBzdGlmZm5lc3M6IDUwMCxcbiAgICBkYW1waW5nOiAyNSxcbiAgICByZXN0U3BlZWQ6IDEwLFxufSk7IH07XG52YXIgY3JpdGljYWxseURhbXBlZFNwcmluZyA9IGZ1bmN0aW9uICh0bykgeyByZXR1cm4gKHtcbiAgICB0eXBlOiBcInNwcmluZ1wiLFxuICAgIHN0aWZmbmVzczogNTUwLFxuICAgIGRhbXBpbmc6IHRvID09PSAwID8gMiAqIE1hdGguc3FydCg1NTApIDogMzAsXG4gICAgcmVzdFNwZWVkOiAxMCxcbn0pOyB9O1xudmFyIGxpbmVhclR3ZWVuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICAgIGVhc2U6IFwibGluZWFyXCIsXG4gICAgZHVyYXRpb246IDAuMyxcbn0pOyB9O1xudmFyIGtleWZyYW1lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHsgcmV0dXJuICh7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBkdXJhdGlvbjogMC44LFxuICAgIHZhbHVlczogdmFsdWVzLFxufSk7IH07XG52YXIgZGVmYXVsdFRyYW5zaXRpb25zID0ge1xuICAgIHg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHo6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgcm90YXRlWDogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgcm90YXRlWTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgcm90YXRlWjogdW5kZXJEYW1wZWRTcHJpbmcsXG4gICAgc2NhbGVYOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICAgIHNjYWxlWTogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgICBzY2FsZTogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgICBvcGFjaXR5OiBsaW5lYXJUd2VlbixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpbmVhclR3ZWVuLFxuICAgIGNvbG9yOiBsaW5lYXJUd2VlbixcbiAgICBkZWZhdWx0OiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxufTtcbnZhciBnZXREZWZhdWx0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZUtleSwgdG8pIHtcbiAgICB2YXIgdHJhbnNpdGlvbkZhY3Rvcnk7XG4gICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KHRvKSkge1xuICAgICAgICB0cmFuc2l0aW9uRmFjdG9yeSA9IGtleWZyYW1lcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb25GYWN0b3J5ID1cbiAgICAgICAgICAgIGRlZmF1bHRUcmFuc2l0aW9uc1t2YWx1ZUtleV0gfHwgZGVmYXVsdFRyYW5zaXRpb25zLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IHRvOiB0byB9LCB0cmFuc2l0aW9uRmFjdG9yeSh0bykpO1xufTtcblxuLyoqXG4gKiBBIG1hcCBvZiBkZWZhdWx0IHZhbHVlIHR5cGVzIGZvciBjb21tb24gdmFsdWVzXG4gKi9cbnZhciBkZWZhdWx0VmFsdWVUeXBlcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBudW1iZXJWYWx1ZVR5cGVzKSwgeyBcbiAgICAvLyBDb2xvciBwcm9wc1xuICAgIGNvbG9yOiBzdHlsZVZhbHVlVHlwZXMuY29sb3IsIGJhY2tncm91bmRDb2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBvdXRsaW5lQ29sb3I6IHN0eWxlVmFsdWVUeXBlcy5jb2xvciwgZmlsbDogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBzdHJva2U6IHN0eWxlVmFsdWVUeXBlcy5jb2xvciwgXG4gICAgLy8gQm9yZGVyIHByb3BzXG4gICAgYm9yZGVyQ29sb3I6IHN0eWxlVmFsdWVUeXBlcy5jb2xvciwgYm9yZGVyVG9wQ29sb3I6IHN0eWxlVmFsdWVUeXBlcy5jb2xvciwgYm9yZGVyUmlnaHRDb2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBib3JkZXJCb3R0b21Db2xvcjogc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLCBib3JkZXJMZWZ0Q29sb3I6IHN0eWxlVmFsdWVUeXBlcy5jb2xvciwgZmlsdGVyOiBzdHlsZVZhbHVlVHlwZXMuZmlsdGVyLCBXZWJraXRGaWx0ZXI6IHN0eWxlVmFsdWVUeXBlcy5maWx0ZXIgfSk7XG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgVmFsdWVUeXBlIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUga2V5XG4gKi9cbnZhciBnZXREZWZhdWx0VmFsdWVUeXBlID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVmYXVsdFZhbHVlVHlwZXNba2V5XTsgfTtcblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZU5vbmUoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlVHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZSAhPT0gc3R5bGVWYWx1ZVR5cGVzLmZpbHRlcilcbiAgICAgICAgZGVmYXVsdFZhbHVlVHlwZSA9IHN0eWxlVmFsdWVUeXBlcy5jb21wbGV4O1xuICAgIC8vIElmIHZhbHVlIGlzIG5vdCByZWNvZ25pc2VkIGFzIGFuaW1hdGFibGUsIGllIFwibm9uZVwiLCBjcmVhdGUgYW4gYW5pbWF0YWJsZSB2ZXJzaW9uIG9yaWdpbiBiYXNlZCBvbiB0aGUgdGFyZ2V0XG4gICAgcmV0dXJuIChfYSA9IGRlZmF1bHRWYWx1ZVR5cGUuZ2V0QW5pbWF0YWJsZU5vbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRlZmF1bHRWYWx1ZVR5cGUsIHZhbHVlKTtcbn1cblxudmFyIGluc3RhbnRBbmltYXRpb25TdGF0ZSA9IHtcbiAgICBjdXJyZW50OiBmYWxzZSxcbn07XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYSB0cmFuc2l0aW9uIGlzIGRlZmluZWQgb24gYSBnaXZlbiBUcmFuc2l0aW9uLlxuICogVGhpcyBmaWx0ZXJzIG91dCBvcmNoZXN0cmF0aW9uIG9wdGlvbnMgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgYW55IG9wdGlvbnMgYXJlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoX2EpIHtcbiAgICBfYS53aGVuOyBfYS5kZWxheTsgX2EuZGVsYXlDaGlsZHJlbjsgX2Euc3RhZ2dlckNoaWxkcmVuOyBfYS5zdGFnZ2VyRGlyZWN0aW9uOyBfYS5yZXBlYXQ7IF9hLnJlcGVhdFR5cGU7IF9hLnJlcGVhdERlbGF5OyBfYS5mcm9tOyB2YXIgdHJhbnNpdGlvbiA9IHRzbGliLl9fcmVzdChfYSwgW1wid2hlblwiLCBcImRlbGF5XCIsIFwiZGVsYXlDaGlsZHJlblwiLCBcInN0YWdnZXJDaGlsZHJlblwiLCBcInN0YWdnZXJEaXJlY3Rpb25cIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJmcm9tXCJdKTtcbiAgICByZXR1cm4gISFPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5sZW5ndGg7XG59XG52YXIgbGVnYWN5UmVwZWF0V2FybmluZyA9IGZhbHNlO1xuLyoqXG4gKiBDb252ZXJ0IEZyYW1lciBNb3Rpb24ncyBUcmFuc2l0aW9uIHR5cGUgaW50byBQb3Btb3Rpb24tY29tcGF0aWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNpdGlvblRvQW5pbWF0aW9uT3B0aW9ucyhfYSkge1xuICAgIHZhciBlYXNlID0gX2EuZWFzZSwgdGltZXMgPSBfYS50aW1lcywgeW95byA9IF9hLnlveW8sIGZsaXAgPSBfYS5mbGlwLCBsb29wID0gX2EubG9vcCwgdHJhbnNpdGlvbiA9IHRzbGliLl9fcmVzdChfYSwgW1wiZWFzZVwiLCBcInRpbWVzXCIsIFwieW95b1wiLCBcImZsaXBcIiwgXCJsb29wXCJdKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKTtcbiAgICBpZiAodGltZXMpXG4gICAgICAgIG9wdGlvbnNbXCJvZmZzZXRcIl0gPSB0aW1lcztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFueSBleGlzdGluZyBkdXJhdGlvbnMgZnJvbSBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGlmICh0cmFuc2l0aW9uLmR1cmF0aW9uKVxuICAgICAgICBvcHRpb25zW1wiZHVyYXRpb25cIl0gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModHJhbnNpdGlvbi5kdXJhdGlvbik7XG4gICAgaWYgKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpXG4gICAgICAgIG9wdGlvbnMucmVwZWF0RGVsYXkgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModHJhbnNpdGlvbi5yZXBlYXREZWxheSk7XG4gICAgLyoqXG4gICAgICogTWFwIGVhc2luZyBuYW1lcyB0byBQb3Btb3Rpb24ncyBlYXNpbmcgZnVuY3Rpb25zXG4gICAgICovXG4gICAgaWYgKGVhc2UpIHtcbiAgICAgICAgb3B0aW9uc1tcImVhc2VcIl0gPSBpc0Vhc2luZ0FycmF5KGVhc2UpXG4gICAgICAgICAgICA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKVxuICAgICAgICAgICAgOiBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbihlYXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBsZWdhY3kgdHJhbnNpdGlvbiBBUElcbiAgICAgKi9cbiAgICBpZiAodHJhbnNpdGlvbi50eXBlID09PSBcInR3ZWVuXCIpXG4gICAgICAgIG9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gICAgLyoqXG4gICAgICogVE9ETzogVGhlc2Ugb3B0aW9ucyBhcmUgb2ZmaWNpYWxseSByZW1vdmVkIGZyb20gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBpZiAoeW95byB8fCBsb29wIHx8IGZsaXApIHtcbiAgICAgICAgaGV5TGlzdGVuLndhcm5pbmcoIWxlZ2FjeVJlcGVhdFdhcm5pbmcsIFwieW95bywgbG9vcCBhbmQgZmxpcCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBBUEkuIFJlcGxhY2Ugd2l0aCByZXBlYXQgYW5kIHJlcGVhdFR5cGUgb3B0aW9ucy5cIik7XG4gICAgICAgIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAoeW95bykge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJyZXZlcnNlXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG9vcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJsb29wXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmxpcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJtaXJyb3JcIjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlcGVhdCA9IGxvb3AgfHwgeW95byB8fCBmbGlwIHx8IHRyYW5zaXRpb24ucmVwZWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUT0RPOiBQb3Btb3Rpb24gOSBoYXMgdGhlIGFiaWxpdHkgdG8gYXV0b21hdGljYWxseSBkZXRlY3Qgd2hldGhlciB0byB1c2VcbiAgICAgKiBhIGtleWZyYW1lcyBvciBzcHJpbmcgYW5pbWF0aW9uLCBidXQgZG9lcyBzbyBieSBkZXRlY3RpbmcgdmVsb2NpdHkgYW5kIG90aGVyIHNwcmluZyBvcHRpb25zLlxuICAgICAqIEl0J2QgYmUgZ29vZCB0byBpbnRyb2R1Y2UgYSBzaW1pbGFyIHRoaW5nIGhlcmUuXG4gICAgICovXG4gICAgaWYgKHRyYW5zaXRpb24udHlwZSAhPT0gXCJzcHJpbmdcIilcbiAgICAgICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogR2V0IHRoZSBkZWxheSBmb3IgYSB2YWx1ZSBieSBjaGVja2luZyBUcmFuc2l0aW9uIHdpdGggZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB8fCB7fTtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdmFsdWVUcmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUtleWZyYW1lcyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykgJiYgb3B0aW9ucy50b1swXSA9PT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnRvID0gdHNsaWIuX19zcHJlYWRBcnJheShbXSwgdHNsaWIuX19yZWFkKG9wdGlvbnMudG8pLCBmYWxzZSk7XG4gICAgICAgIG9wdGlvbnMudG9bMF0gPSBvcHRpb25zLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucyh0cmFuc2l0aW9uLCBvcHRpb25zLCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykpIHtcbiAgICAgICAgKF9hID0gdHJhbnNpdGlvbi5kdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRyYW5zaXRpb24uZHVyYXRpb24gPSAwLjgpO1xuICAgIH1cbiAgICBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIEdldCBhIGRlZmF1bHQgdHJhbnNpdGlvbiBpZiBub25lIGlzIGRldGVybWluZWQgdG8gYmUgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBpZiAoIWlzVHJhbnNpdGlvbkRlZmluZWQodHJhbnNpdGlvbikpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKSwgZ2V0RGVmYXVsdFRyYW5zaXRpb24oa2V5LCBvcHRpb25zLnRvKSk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zKHRyYW5zaXRpb24pKTtcbn1cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSk7XG4gICAgdmFyIG9yaWdpbiA9IChfYSA9IHZhbHVlVHJhbnNpdGlvbi5mcm9tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5nZXQoKTtcbiAgICB2YXIgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleSwgdGFyZ2V0KTtcbiAgICBpZiAob3JpZ2luID09PSBcIm5vbmVcIiAmJiBpc1RhcmdldEFuaW1hdGFibGUgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgZnJvbSBcIm5vbmVcIiwgdHJ5IGFuZCBnZXQgYW4gYW5pbWF0YWJsZSB2ZXJzaW9uXG4gICAgICAgICAqIG9mIHRoZSB0YXJnZXQuIFRoaXMgY291bGQgYmUgaW1wcm92ZWQgdG8gd29yayBib3RoIHdheXMuXG4gICAgICAgICAqL1xuICAgICAgICBvcmlnaW4gPSBnZXRBbmltYXRhYmxlTm9uZShrZXksIHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWmVybyhvcmlnaW4pICYmIHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3JpZ2luID0gZ2V0WmVyb1VuaXQodGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJlxuICAgICAgICBpc1plcm8odGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRhcmdldCA9IGdldFplcm9Vbml0KG9yaWdpbik7XG4gICAgfVxuICAgIHZhciBpc09yaWdpbkFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCBvcmlnaW4pO1xuICAgIGhleUxpc3Rlbi53YXJuaW5nKGlzT3JpZ2luQW5pbWF0YWJsZSA9PT0gaXNUYXJnZXRBbmltYXRhYmxlLCBcIllvdSBhcmUgdHJ5aW5nIHRvIGFuaW1hdGUgXCIuY29uY2F0KGtleSwgXCIgZnJvbSBcXFwiXCIpLmNvbmNhdChvcmlnaW4sIFwiXFxcIiB0byBcXFwiXCIpLmNvbmNhdCh0YXJnZXQsIFwiXFxcIi4gXCIpLmNvbmNhdChvcmlnaW4sIFwiIGlzIG5vdCBhbiBhbmltYXRhYmxlIHZhbHVlIC0gdG8gZW5hYmxlIHRoaXMgYW5pbWF0aW9uIHNldCBcIikuY29uY2F0KG9yaWdpbiwgXCIgdG8gYSB2YWx1ZSBhbmltYXRhYmxlIHRvIFwiKS5jb25jYXQodGFyZ2V0LCBcIiB2aWEgdGhlIGBzdHlsZWAgcHJvcGVydHkuXCIpKTtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBmcm9tOiBvcmlnaW4sXG4gICAgICAgICAgICB0bzogdGFyZ2V0LFxuICAgICAgICAgICAgdmVsb2NpdHk6IHZhbHVlLmdldFZlbG9jaXR5KCksXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2YWx1ZS5zZXQodik7IH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gXCJpbmVydGlhXCIgfHxcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImRlY2F5XCJcbiAgICAgICAgICAgID8gcG9wbW90aW9uLmluZXJ0aWEodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB2YWx1ZVRyYW5zaXRpb24pKVxuICAgICAgICAgICAgOiBwb3Btb3Rpb24uYW5pbWF0ZSh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucyh2YWx1ZVRyYW5zaXRpb24sIG9wdGlvbnMsIGtleSkpLCB7IG9uVXBkYXRlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25VcGRhdGUodik7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWVUcmFuc2l0aW9uLCB2KTtcbiAgICAgICAgICAgICAgICB9LCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBmaW5hbFRhcmdldCA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0KTtcbiAgICAgICAgdmFsdWUuc2V0KGZpbmFsVGFyZ2V0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAoX2EgPSB2YWx1ZVRyYW5zaXRpb24gPT09IG51bGwgfHwgdmFsdWVUcmFuc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlVHJhbnNpdGlvbiwgZmluYWxUYXJnZXQpO1xuICAgICAgICAoX2IgPSB2YWx1ZVRyYW5zaXRpb24gPT09IG51bGwgfHwgdmFsdWVUcmFuc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodmFsdWVUcmFuc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgc3RvcDogZnVuY3Rpb24gKCkgeyB9IH07XG4gICAgfVxuICAgIHJldHVybiAhaXNPcmlnaW5BbmltYXRhYmxlIHx8XG4gICAgICAgICFpc1RhcmdldEFuaW1hdGFibGUgfHxcbiAgICAgICAgdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IGZhbHNlXG4gICAgICAgID8gc2V0XG4gICAgICAgIDogc3RhcnQ7XG59XG5mdW5jdGlvbiBpc1plcm8odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlID09PSAwIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUpID09PSAwICYmXG4gICAgICAgICAgICB2YWx1ZS5pbmRleE9mKFwiIFwiKSA9PT0gLTEpKTtcbn1cbmZ1bmN0aW9uIGdldFplcm9Vbml0KHBvdGVudGlhbFVuaXRUeXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwb3RlbnRpYWxVbml0VHlwZSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IDBcbiAgICAgICAgOiBnZXRBbmltYXRhYmxlTm9uZShcIlwiLCBwb3RlbnRpYWxVbml0VHlwZSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xufVxuLyoqXG4gKiBTdGFydCBhbmltYXRpb24gb24gYSBNb3Rpb25WYWx1ZS4gVGhpcyBmdW5jdGlvbiBpcyBhbiBpbnRlcmZhY2UgYmV0d2VlblxuICogRnJhbWVyIE1vdGlvbiBhbmQgUG9wbW90aW9uXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbikge1xuICAgIGlmICh0cmFuc2l0aW9uID09PSB2b2lkIDApIHsgdHJhbnNpdGlvbiA9IHt9OyB9XG4gICAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50KSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSB7IHR5cGU6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zdGFydChmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgZGVsYXlUaW1lcjtcbiAgICAgICAgdmFyIGNvbnRyb2xzO1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSk7XG4gICAgICAgIHZhciBkZWxheSA9IGdldERlbGF5RnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNvbnRyb2xzID0gYW5pbWF0aW9uKCkpOyB9O1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIGRlbGF5VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChzdGFydCwgc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGRlbGF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXlUaW1lcik7XG4gICAgICAgICAgICBjb250cm9scyA9PT0gbnVsbCB8fCBjb250cm9scyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbHMuc3RvcCgpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGEgbnVtZXJpY2FsIHN0cmluZywgaWUgYSBzdHJpbmcgdGhhdCBpcyBwdXJlbHkgYSBudW1iZXIgZWcgXCIxMDBcIiBvciBcIi0xMDAuMVwiXG4gKi9cbnZhciBpc051bWVyaWNhbFN0cmluZyA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAvXlxcLT9cXGQqXFwuP1xcZCskLy50ZXN0KHYpOyB9O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIHplcm8gdmFsdWUgc3RyaW5nIGxpa2UgXCIwcHhcIiBvciBcIjAlXCJcbiAqL1xudmFyIGlzWmVyb1ZhbHVlU3RyaW5nID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIC9eMFteLlxcc10rJC8udGVzdCh2KTsgfTtcblxuZnVuY3Rpb24gYWRkVW5pcXVlSXRlbShhcnIsIGl0ZW0pIHtcbiAgICBhcnIuaW5kZXhPZihpdGVtKSA9PT0gLTEgJiYgYXJyLnB1c2goaXRlbSk7XG59XG5mdW5jdGlvbiByZW1vdmVJdGVtKGFyciwgaXRlbSkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGluZGV4ID4gLTEgJiYgYXJyLnNwbGljZShpbmRleCwgMSk7XG59XG4vLyBBZGFwdGVkIGZyb20gYXJyYXktbW92ZVxuZnVuY3Rpb24gbW92ZUl0ZW0oX2EsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgIHZhciBfYiA9IHRzbGliLl9fcmVhZChfYSksIGFyciA9IF9iLnNsaWNlKDApO1xuICAgIHZhciBzdGFydEluZGV4ID0gZnJvbUluZGV4IDwgMCA/IGFyci5sZW5ndGggKyBmcm9tSW5kZXggOiBmcm9tSW5kZXg7XG4gICAgaWYgKHN0YXJ0SW5kZXggPj0gMCAmJiBzdGFydEluZGV4IDwgYXJyLmxlbmd0aCkge1xuICAgICAgICB2YXIgZW5kSW5kZXggPSB0b0luZGV4IDwgMCA/IGFyci5sZW5ndGggKyB0b0luZGV4IDogdG9JbmRleDtcbiAgICAgICAgdmFyIF9jID0gdHNsaWIuX19yZWFkKGFyci5zcGxpY2UoZnJvbUluZGV4LCAxKSwgMSksIGl0ZW0gPSBfY1swXTtcbiAgICAgICAgYXJyLnNwbGljZShlbmRJbmRleCwgMCwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5cbnZhciBTdWJzY3JpcHRpb25NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbk1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmVJdGVtKF90aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpOyB9O1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uTWFuYWdlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIG51bVN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoIW51bVN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChudW1TdWJzY3JpcHRpb25zID09PSAxKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSBoYW5kbGVyIHdlIGNhbiBqdXN0IGNhbGwgaXQgd2l0aG91dCBpbnZva2luZyBhIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1swXShhLCBiLCBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU3Vic2NyaXB0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgaGFuZGxlciBleGlzdHMgYmVmb3JlIGZpcmluZyBhcyBpdCdzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICogdGhlIHN1YnNjcmlwdGlvbnMgd2VyZSBtb2RpZmllZCBkdXJpbmcgdGhpcyBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLnN1YnNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpcHRpb25NYW5hZ2VyO1xufSgpKTtcblxudmFyIGlzRmxvYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG4vKipcbiAqIGBNb3Rpb25WYWx1ZWAgaXMgdXNlZCB0byB0cmFjayB0aGUgc3RhdGUgYW5kIHZlbG9jaXR5IG9mIG1vdGlvbiB2YWx1ZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgTW90aW9uVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGluaXQgLSBUaGUgaW5pdGlhdGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIC0gIGB0cmFuc2Zvcm1lcmA6IEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGluY29taW5nIHZhbHVlcyB3aXRoLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW90aW9uVmFsdWUoaW5pdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBidWlsZCBzdGVwIHdpdGggdGhlIGxhdGVzdCB2ZXJzaW9uIG51bWJlci5cbiAgICAgICAgICogV2hlbiBNb3Rpb25WYWx1ZXMgYXJlIHByb3ZpZGVkIHRvIG1vdGlvbiBjb21wb25lbnRzLCB3YXJuIGlmIHZlcnNpb25zIGFyZSBtaXhlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiNi41LjFcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIER1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHMsIHNpbmNlIGxhc3QgdXBkYXRpbmcgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lRGVsdGEgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZXN0YW1wIG9mIHRoZSBsYXN0IHRpbWUgdGhpcyBgTW90aW9uVmFsdWVgIHdhcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIHVwZGF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbnMgdG8gbm90aWZ5IHdoZW4gdGhlIHZlbG9jaXR5IHVwZGF0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgYE1vdGlvblZhbHVlYCB1cGRhdGVzIGFuZCBgcmVuZGVyYCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgdGhpcyB2YWx1ZSBjYW4gb3V0cHV0IGEgdmVsb2NpdHkuIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdHJ1ZVxuICAgICAgICAgKiBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpY2FsLCBidXQgd2UgbWlnaHQgYmUgYWJsZSB0byB3aWRlbiB0aGUgc2NvcGUgaGVyZSBhbmQgc3VwcG9ydFxuICAgICAgICAgKiBvdGhlciB2YWx1ZSB0eXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkgPSBmdW5jdGlvbiAodiwgcmVuZGVyKSB7XG4gICAgICAgICAgICBpZiAocmVuZGVyID09PSB2b2lkIDApIHsgcmVuZGVyID0gdHJ1ZTsgfVxuICAgICAgICAgICAgX3RoaXMucHJldiA9IF90aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50ID0gdjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aW1lc3RhbXBcbiAgICAgICAgICAgIHZhciBfYSA9IHN5bmMuZ2V0RnJhbWVEYXRhKCksIGRlbHRhID0gX2EuZGVsdGEsIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0VXBkYXRlZCAhPT0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZURlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucG9zdFJlbmRlcihfdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHVwZGF0ZSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKF90aGlzLnByZXYgIT09IF90aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVTdWJzY3JpYmVycy5ub3RpZnkoX3RoaXMuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIGlmIChfdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHJlbmRlciBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlclN1YnNjcmliZXJzLm5vdGlmeShfdGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjaGVkdWxlIGEgdmVsb2NpdHkgY2hlY2sgZm9yIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGFuIGluc3RhbmNlZCBhbmQgYm91bmQgZnVuY3Rpb24gdG8gcHJldmVudCBnZW5lcmF0aW5nIGEgbmV3XG4gICAgICAgICAqIGZ1bmN0aW9uIG9uY2UgcGVyIGZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucG9zdFJlbmRlcihfdGhpcy52ZWxvY2l0eUNoZWNrKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYHByZXZgIHdpdGggYGN1cnJlbnRgIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgYmVlbiB1cGRhdGVkIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgZW5zdXJlcyB2ZWxvY2l0eSBjYWxjdWxhdGlvbnMgcmV0dXJuIGAwYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhbiBpbnN0YW5jZWQgYW5kIGJvdW5kIGZ1bmN0aW9uIHRvIHByZXZlbnQgZ2VuZXJhdGluZyBhIG5ld1xuICAgICAgICAgKiBmdW5jdGlvbiBvbmNlIHBlciBmcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlbG9jaXR5Q2hlY2sgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBfYS50aW1lc3RhbXA7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wICE9PSBfdGhpcy5sYXN0VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgICAgIF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudCA9IGluaXQ7XG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGlzRmxvYXQodGhpcy5jdXJyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBub3RpZmllZCB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxpbmcgYG9uQ2hhbmdlYCBpbnNpZGUgYSBSZWFjdCBjb21wb25lbnQsIGl0IHNob3VsZCBiZSB3cmFwcGVkIHdpdGggdGhlXG4gICAgICogYHVzZUVmZmVjdGAgaG9vay4gQXMgaXQgcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICAgKiBmcm9tIHRoZSBgdXNlRWZmZWN0YCBmdW5jdGlvbiB0byBlbnN1cmUgeW91IGRvbid0IGFkZCBkdXBsaWNhdGUgc3Vic2NyaWJlcnMuLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAqICAgY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogICBjb25zdCB5ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IG9wYWNpdHkgPSB1c2VNb3Rpb25WYWx1ZSgxKVxuICAgICAqXG4gICAgICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAqICAgICBmdW5jdGlvbiB1cGRhdGVPcGFjaXR5KCkge1xuICAgICAqICAgICAgIGNvbnN0IG1heFhZID0gTWF0aC5tYXgoeC5nZXQoKSwgeS5nZXQoKSlcbiAgICAgKiAgICAgICBjb25zdCBuZXdPcGFjaXR5ID0gdHJhbnNmb3JtKG1heFhZLCBbMCwgMTAwXSwgWzEsIDBdKVxuICAgICAqICAgICAgIG9wYWNpdHkuc2V0KG5ld09wYWNpdHkpXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVggPSB4Lm9uQ2hhbmdlKHVwZGF0ZU9wYWNpdHkpXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWSA9IHkub25DaGFuZ2UodXBkYXRlT3BhY2l0eSlcbiAgICAgKlxuICAgICAqICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWCgpXG4gICAgICogICAgICAgdW5zdWJzY3JpYmVZKClcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSwgW10pXG4gICAgICpcbiAgICAgKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyB4IH19IC8+XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHByaXZhdGVSZW1hcmtzXG4gICAgICpcbiAgICAgKiBXZSBjb3VsZCBsb29rIGludG8gYSBgdXNlT25DaGFuZ2VgIGhvb2sgaWYgdGhlIGFib3ZlIGxpZmVjeWNsZSBtYW5hZ2VtZW50IHByb3ZlcyBjb25mdXNpbmcuXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiB1c2VPbkNoYW5nZSh4LCAoKSA9PiB7fSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyIC0gQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3QgdmFsdWUuXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTdWJzY3JpYmVycy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5jbGVhckxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBub3RpZmllZCB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIHJlcXVlc3RzIGEgcmVuZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YnNjcmliZXIgLSBBIGZ1bmN0aW9uIHRoYXQncyBwcm92aWRlZCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLm9uUmVuZGVyUmVxdWVzdCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgLy8gUmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICAgIHN1YnNjcmlwdGlvbih0aGlzLmdldCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhIHBhc3NpdmUgZWZmZWN0IHRvIHRoZSBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwYXNzaXZlRWZmZWN0KSB7XG4gICAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCA9IHBhc3NpdmVFZmZlY3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiB4LnNldCgxMClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRlc3QgLSBMYXRlc3QgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSByZW5kZXIgLSBXaGV0aGVyIHRvIG5vdGlmeSByZW5kZXIgc3Vic2NyaWJlcnMuIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgcmVuZGVyKSB7XG4gICAgICAgIGlmIChyZW5kZXIgPT09IHZvaWQgMCkgeyByZW5kZXIgPSB0cnVlOyB9XG4gICAgICAgIGlmICghcmVuZGVyIHx8ICF0aGlzLnBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYsIHJlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QodiwgdGhpcy51cGRhdGVBbmROb3RpZnkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3Qgc3RhdGUgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5nZXRQcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYC4gUmV0dXJucyBgMGAgaWYgdGhlIHN0YXRlIGlzIG5vbi1udW1lcmljYWwuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGlzRmxvYXQodGhpcy5wcmV2KSAmJiBpc0Zsb2F0KHRoaXMuY3VycmVudCksIGJ1dCB0aGF0IHdvdWxkIGJlIHdhc3RlZnVsXG4gICAgICAgIHJldHVybiB0aGlzLmNhblRyYWNrVmVsb2NpdHlcbiAgICAgICAgICAgID8gLy8gVGhlc2UgY2FzdHMgY291bGQgYmUgYXZvaWRlZCBpZiBwYXJzZUZsb2F0IHdvdWxkIGJlIHR5cGVkIGJldHRlclxuICAgICAgICAgICAgICAgIHBvcG1vdGlvbi52ZWxvY2l0eVBlclNlY29uZChwYXJzZUZsb2F0KHRoaXMuY3VycmVudCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMucHJldiksIHRoaXMudGltZURlbHRhKVxuICAgICAgICAgICAgOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGFuaW1hdGlvbiB0byBjb250cm9sIHRoaXMgYE1vdGlvblZhbHVlYC4gT25seSBvbmVcbiAgICAgKiBhbmltYXRpb24gY2FuIGRyaXZlIGEgYE1vdGlvblZhbHVlYCBhdCBvbmUgdGltZS5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIHZhbHVlLnN0YXJ0KClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gLSBBIGZ1bmN0aW9uIHRoYXQgc3RhcnRzIHRoZSBwcm92aWRlZCBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuaGFzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuc3RvcEFuaW1hdGlvbiA9IGFuaW1hdGlvbihyZXNvbHZlKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbGVhckFuaW1hdGlvbigpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wQW5pbWF0aW9uKVxuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuaXNBbmltYXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3RvcEFuaW1hdGlvbjtcbiAgICB9O1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5jbGVhckFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuIHVwIHN1YnNjcmliZXJzIHRvIHRoaXMgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgTW90aW9uVmFsdWVgIGhvb2tzIGxpa2UgYHVzZU1vdGlvblZhbHVlYCBhbmQgYHVzZVRyYW5zZm9ybWAgYXV0b21hdGljYWxseVxuICAgICAqIGhhbmRsZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByZXR1cm5lZCBgTW90aW9uVmFsdWVgLCBzbyB0aGlzIG1ldGhvZCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB5b3UndmUgbWFudWFsbHlcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBNb3Rpb25WYWx1ZTtcbn0oKSk7XG5mdW5jdGlvbiBtb3Rpb25WYWx1ZShpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0KTtcbn1cblxuLyoqXG4gKiBUZXN0cyBhIHByb3ZpZGVkIHZhbHVlIGFnYWluc3QgYSBWYWx1ZVR5cGVcbiAqL1xudmFyIHRlc3RWYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudGVzdCh2KTsgfTsgfTtcblxuLyoqXG4gKiBWYWx1ZVR5cGUgZm9yIFwiYXV0b1wiXG4gKi9cbnZhciBhdXRvID0ge1xuICAgIHRlc3Q6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ID09PSBcImF1dG9cIjsgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0sXG59O1xuXG4vKipcbiAqIEEgbGlzdCBvZiB2YWx1ZSB0eXBlcyBjb21tb25seSB1c2VkIGZvciBkaW1lbnNpb25zXG4gKi9cbnZhciBkaW1lbnNpb25WYWx1ZVR5cGVzID0gW3N0eWxlVmFsdWVUeXBlcy5udW1iZXIsIHN0eWxlVmFsdWVUeXBlcy5weCwgc3R5bGVWYWx1ZVR5cGVzLnBlcmNlbnQsIHN0eWxlVmFsdWVUeXBlcy5kZWdyZWVzLCBzdHlsZVZhbHVlVHlwZXMudncsIHN0eWxlVmFsdWVUeXBlcy52aCwgYXV0b107XG4vKipcbiAqIFRlc3RzIGEgZGltZW5zaW9uYWwgdmFsdWUgYWdhaW5zdCB0aGUgbGlzdCBvZiBkaW1lbnNpb24gVmFsdWVUeXBlc1xuICovXG52YXIgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvblZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcbn07XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbCBWYWx1ZVR5cGVzXG4gKi9cbnZhciB2YWx1ZVR5cGVzID0gdHNsaWIuX19zcHJlYWRBcnJheSh0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQoZGltZW5zaW9uVmFsdWVUeXBlcyksIGZhbHNlKSwgW3N0eWxlVmFsdWVUeXBlcy5jb2xvciwgc3R5bGVWYWx1ZVR5cGVzLmNvbXBsZXhdLCBmYWxzZSk7XG4vKipcbiAqIFRlc3RzIGEgdmFsdWUgYWdhaW5zdCB0aGUgbGlzdCBvZiBWYWx1ZVR5cGVzXG4gKi9cbnZhciBmaW5kVmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTsgfTtcblxuLyoqXG4gKiBTZXQgVmlzdWFsRWxlbWVudCdzIE1vdGlvblZhbHVlLCBjcmVhdGluZyBhIG5ldyBNb3Rpb25WYWx1ZSBmb3IgaXQgaWZcbiAqIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICB2YXIgX2EgPSByZXNvbHZlZCA/IHZpc3VhbEVsZW1lbnQubWFrZVRhcmdldEFuaW1hdGFibGUocmVzb2x2ZWQsIGZhbHNlKSA6IHt9LCBfYiA9IF9hLnRyYW5zaXRpb25FbmQsIHRyYW5zaXRpb25FbmQgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjsgX2EudHJhbnNpdGlvbjsgdmFyIHRhcmdldCA9IHRzbGliLl9fcmVzdChfYSwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICAgIHRhcmdldCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0W2tleV0pO1xuICAgICAgICBzZXRNb3Rpb25WYWx1ZSh2aXN1YWxFbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCB2YXJpYW50TGFiZWxzKSB7XG4gICAgdmFyIHJldmVyc2VkTGFiZWxzID0gdHNsaWIuX19zcHJlYWRBcnJheShbXSwgdHNsaWIuX19yZWFkKHZhcmlhbnRMYWJlbHMpLCBmYWxzZSkucmV2ZXJzZSgpO1xuICAgIHJldmVyc2VkTGFiZWxzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB2YXJpYW50ID0gdmlzdWFsRWxlbWVudC5nZXRWYXJpYW50KGtleSk7XG4gICAgICAgIHZhcmlhbnQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQpO1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBzZXRWYXJpYW50cyhjaGlsZCwgdmFyaWFudExhYmVscyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2V0VmFyaWFudHModmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCBbZGVmaW5pdGlvbl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdmFyIF9kO1xuICAgIHZhciBuZXdWYWx1ZUtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhdmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpOyB9KTtcbiAgICB2YXIgbnVtTmV3VmFsdWVzID0gbmV3VmFsdWVLZXlzLmxlbmd0aDtcbiAgICBpZiAoIW51bU5ld1ZhbHVlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTmV3VmFsdWVzOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld1ZhbHVlS2V5c1tpXTtcbiAgICAgICAgdmFyIHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGEgc2VyaWVzIG9mIGtleWZyYW1lcywgd2UgY2FuIHVzZSB0aGUgZmlyc3QgdmFsdWVcbiAgICAgICAgICogaW4gdGhlIGFycmF5LiBJZiB0aGlzIGZpcnN0IHZhbHVlIGlzIG51bGwsIHdlJ2xsIHN0aWxsIG5lZWQgdG8gcmVhZCBmcm9tIHRoZSBET00uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0VmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB0YXJnZXQgaXNuJ3Qga2V5ZnJhbWVzLCBvciB0aGUgZmlyc3Qga2V5ZnJhbWUgd2FzIG51bGwsIHdlIG5lZWQgdG9cbiAgICAgICAgICogZmlyc3QgY2hlY2sgaWYgYW4gb3JpZ2luIHZhbHVlIHdhcyBleHBsaWNpdGx5IGRlZmluZWQgaW4gdGhlIHRyYW5zaXRpb24gYXMgXCJmcm9tXCIsXG4gICAgICAgICAqIGlmIG5vdCByZWFkIHRoZSB2YWx1ZSBmcm9tIHRoZSBET00uIEFzIGFuIGFic29sdXRlIGZhbGxiYWNrLCB0YWtlIHRoZSBkZWZpbmVkIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAoX2IgPSAoX2EgPSBvcmlnaW5ba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlzdWFsRWxlbWVudC5yZWFkVmFsdWUoa2V5KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHZhbHVlIGlzIHN0aWxsIHVuZGVmaW5lZCBvciBudWxsLCBpZ25vcmUgaXQuIFByZWZlcmFibHkgdGhpcyB3b3VsZCB0aHJvdyxcbiAgICAgICAgICogYnV0IHRoaXMgd2FzIGNhdXNpbmcgaXNzdWVzIGluIEZyYW1lci5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIChpc051bWVyaWNhbFN0cmluZyh2YWx1ZSkgfHwgaXNaZXJvVmFsdWVTdHJpbmcodmFsdWUpKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG51bWJlciByZWFkIGFzIGEgc3RyaW5nLCBpZSBcIjBcIiBvciBcIjIwMFwiLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmaW5kVmFsdWVUeXBlKHZhbHVlKSAmJiBzdHlsZVZhbHVlVHlwZXMuY29tcGxleC50ZXN0KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBnZXRBbmltYXRhYmxlTm9uZShrZXksIHRhcmdldFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICAgICAgKF9jID0gKF9kID0gb3JpZ2luKVtrZXldKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2Rba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRCYXNlVGFyZ2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE9yaWdpbkZyb21UcmFuc2l0aW9uKGtleSwgdHJhbnNpdGlvbikge1xuICAgIGlmICghdHJhbnNpdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciB2YWx1ZVRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gfHwgdHJhbnNpdGlvbltcImRlZmF1bHRcIl0gfHwgdHJhbnNpdGlvbjtcbiAgICByZXR1cm4gdmFsdWVUcmFuc2l0aW9uLmZyb207XG59XG5mdW5jdGlvbiBnZXRPcmlnaW4odGFyZ2V0LCB0cmFuc2l0aW9uLCB2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgb3JpZ2luID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgICAgICBvcmlnaW5ba2V5XSA9XG4gICAgICAgICAgICAoX2EgPSBnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbihrZXksIHRyYW5zaXRpb24pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbjtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmlzdWFsRWxlbWVudC5ub3RpZnlBbmltYXRpb25TdGFydChkZWZpbml0aW9uKTtcbiAgICB2YXIgYW5pbWF0aW9uO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gZGVmaW5pdGlvbi5tYXAoZnVuY3Rpb24gKHZhcmlhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhbmltYXRpb24gPSBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXNvbHZlZERlZmluaXRpb24gPSB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMuY3VzdG9tKVxuICAgICAgICAgICAgOiBkZWZpbml0aW9uO1xuICAgICAgICBhbmltYXRpb24gPSBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkRGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb24udGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2aXN1YWxFbGVtZW50Lm5vdGlmeUFuaW1hdGlvbkNvbXBsZXRlKGRlZmluaXRpb24pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMuY3VzdG9tKTtcbiAgICB2YXIgX2IgPSAocmVzb2x2ZWQgfHwge30pLnRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBfYiA9PT0gdm9pZCAwID8gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IDogX2I7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSBhIHZhcmlhbnQsIGNyZWF0ZSBhIGNhbGxiYWNrIHRoYXQgcnVucyBpdCBhcyBhbiBhbmltYXRpb24uXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIHZhciBnZXRBbmltYXRpb24gPSByZXNvbHZlZFxuICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWQsIG9wdGlvbnMpOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH07XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSBjaGlsZHJlbiwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGFsbCB0aGVpciBhbmltYXRpb25zLlxuICAgICAqIE90aGVyd2lzZSwgd2UgcmVzb2x2ZSBhIFByb21pc2UgaW1tZWRpYXRlbHkgZm9yIGEgY29tcG9zYWJsZSBuby1vcC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0Q2hpbGRBbmltYXRpb25zID0gKChfYSA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSlcbiAgICAgICAgPyBmdW5jdGlvbiAoZm9yd2FyZERlbGF5KSB7XG4gICAgICAgICAgICBpZiAoZm9yd2FyZERlbGF5ID09PSB2b2lkIDApIHsgZm9yd2FyZERlbGF5ID0gMDsgfVxuICAgICAgICAgICAgdmFyIF9hID0gdHJhbnNpdGlvbi5kZWxheUNoaWxkcmVuLCBkZWxheUNoaWxkcmVuID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYSwgc3RhZ2dlckNoaWxkcmVuID0gdHJhbnNpdGlvbi5zdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24gPSB0cmFuc2l0aW9uLnN0YWdnZXJEaXJlY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0ZUNoaWxkcmVuKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIGRlbGF5Q2hpbGRyZW4gKyBmb3J3YXJkRGVsYXksIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiBleHBsaWNpdGx5IGRlZmluZXMgYSBcIndoZW5cIiBvcHRpb24sIHdlIG5lZWQgdG8gcmVzb2x2ZSBlaXRoZXJcbiAgICAgKiB0aGlzIGFuaW1hdGlvbiBvciBhbGwgY2hpbGRyZW4gYW5pbWF0aW9ucyBiZWZvcmUgcGxheWluZyB0aGUgb3RoZXIuXG4gICAgICovXG4gICAgdmFyIHdoZW4gPSB0cmFuc2l0aW9uLndoZW47XG4gICAgaWYgKHdoZW4pIHtcbiAgICAgICAgdmFyIF9jID0gdHNsaWIuX19yZWFkKHdoZW4gPT09IFwiYmVmb3JlQ2hpbGRyZW5cIlxuICAgICAgICAgICAgPyBbZ2V0QW5pbWF0aW9uLCBnZXRDaGlsZEFuaW1hdGlvbnNdXG4gICAgICAgICAgICA6IFtnZXRDaGlsZEFuaW1hdGlvbnMsIGdldEFuaW1hdGlvbl0sIDIpLCBmaXJzdCA9IF9jWzBdLCBsYXN0ID0gX2NbMV07XG4gICAgICAgIHJldHVybiBmaXJzdCgpLnRoZW4obGFzdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dldEFuaW1hdGlvbigpLCBnZXRDaGlsZEFuaW1hdGlvbnMob3B0aW9ucy5kZWxheSldKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIF9hKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBfYyA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfZCA9IF9jLmRlbGF5LCBkZWxheSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIHRyYW5zaXRpb25PdmVycmlkZSA9IF9jLnRyYW5zaXRpb25PdmVycmlkZSwgdHlwZSA9IF9jLnR5cGU7XG4gICAgdmFyIF9lID0gdmlzdWFsRWxlbWVudC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShkZWZpbml0aW9uKSwgX2YgPSBfZS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gX2YgPT09IHZvaWQgMCA/IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSA6IF9mLCB0cmFuc2l0aW9uRW5kID0gX2UudHJhbnNpdGlvbkVuZCwgdGFyZ2V0ID0gdHNsaWIuX19yZXN0KF9lLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgaWYgKHRyYW5zaXRpb25PdmVycmlkZSlcbiAgICAgICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25PdmVycmlkZTtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBhbmltYXRpb25UeXBlU3RhdGUgPSB0eXBlICYmICgoX2IgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0U3RhdGUoKVt0eXBlXSk7XG4gICAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgIHZhciB2YWx1ZVRhcmdldCA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICB2YWx1ZVRhcmdldCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoYW5pbWF0aW9uVHlwZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkQmxvY2tBbmltYXRpb24oYW5pbWF0aW9uVHlwZVN0YXRlLCBrZXkpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlVHJhbnNpdGlvbiA9IHRzbGliLl9fYXNzaWduKHsgZGVsYXk6IGRlbGF5IH0sIHRyYW5zaXRpb24pO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZSBhbmltYXRpb24gaW5zdGFudCBpZiB0aGlzIGlzIGEgdHJhbnNmb3JtIHByb3AgYW5kIHdlIHNob3VsZCByZWR1Y2UgbW90aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuc2hvdWxkUmVkdWNlTW90aW9uICYmIGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24gPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdmFsdWVUcmFuc2l0aW9uKSwgeyB0eXBlOiBmYWxzZSwgZGVsYXk6IDAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHN0YXJ0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHZhbHVlVGFyZ2V0LCB2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFuc2l0aW9uRW5kICYmIHNldFRhcmdldCh2aXN1YWxFbGVtZW50LCB0cmFuc2l0aW9uRW5kKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoZGVsYXlDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGRlbGF5Q2hpbGRyZW4gPSAwOyB9XG4gICAgaWYgKHN0YWdnZXJDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IHN0YWdnZXJDaGlsZHJlbiA9IDA7IH1cbiAgICBpZiAoc3RhZ2dlckRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IHN0YWdnZXJEaXJlY3Rpb24gPSAxOyB9XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcbiAgICB2YXIgbWF4U3RhZ2dlckR1cmF0aW9uID0gKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgICB2YXIgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxXG4gICAgICAgID8gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChpID09PSB2b2lkIDApIHsgaSA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBpICogc3RhZ2dlckNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChpID09PSB2b2lkIDApIHsgaSA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBtYXhTdGFnZ2VyRHVyYXRpb24gLSBpICogc3RhZ2dlckNoaWxkcmVuO1xuICAgICAgICB9O1xuICAgIEFycmF5LmZyb20odmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pXG4gICAgICAgIC5zb3J0KHNvcnRCeVRyZWVPcmRlcilcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRlVmFyaWFudChjaGlsZCwgdmFyaWFudCwgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRlbGF5OiBkZWxheUNoaWxkcmVuICsgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24oaSkgfSkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hpbGQubm90aWZ5QW5pbWF0aW9uQ29tcGxldGUodmFyaWFudCk7IH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG59XG5mdW5jdGlvbiBzdG9wQW5pbWF0aW9uKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2aXN1YWxFbGVtZW50LmZvckVhY2hWYWx1ZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnN0b3AoKTsgfSk7XG59XG5mdW5jdGlvbiBzb3J0QnlUcmVlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBhLnNvcnROb2RlUG9zaXRpb24oYik7XG59XG4vKipcbiAqIERlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCBibG9jayB0aGlzIGFuaW1hdGlvbi4gUHJldmlvdXNseSwgd2UgYWNoaWV2ZWQgdGhpc1xuICoganVzdCBieSBjaGVja2luZyB3aGV0aGVyIHRoZSBrZXkgd2FzIGxpc3RlZCBpbiBwcm90ZWN0ZWRLZXlzLCBidXQgdGhpc1xuICogcG9zZWQgcHJvYmxlbXMgaWYgYW4gYW5pbWF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgYWZ0ZXJDaGlsZHJlbiBhbmQgcHJvdGVjdGVkS2V5c1xuICogaGFkIGJlZW4gc2V0IHRvIHRydWUgaW4gdGhlIG1lYW50aW1lLlxuICovXG5mdW5jdGlvbiBzaG91bGRCbG9ja0FuaW1hdGlvbihfYSwga2V5KSB7XG4gICAgdmFyIHByb3RlY3RlZEtleXMgPSBfYS5wcm90ZWN0ZWRLZXlzLCBuZWVkc0FuaW1hdGluZyA9IF9hLm5lZWRzQW5pbWF0aW5nO1xuICAgIHZhciBzaG91bGRCbG9jayA9IHByb3RlY3RlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBuZWVkc0FuaW1hdGluZ1trZXldICE9PSB0cnVlO1xuICAgIG5lZWRzQW5pbWF0aW5nW2tleV0gPSBmYWxzZTtcbiAgICByZXR1cm4gc2hvdWxkQmxvY2s7XG59XG5cbnZhciB2YXJpYW50UHJpb3JpdHlPcmRlciA9IFtcbiAgICBleHBvcnRzLkFuaW1hdGlvblR5cGUuQW5pbWF0ZSxcbiAgICBleHBvcnRzLkFuaW1hdGlvblR5cGUuSW5WaWV3LFxuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5Gb2N1cyxcbiAgICBleHBvcnRzLkFuaW1hdGlvblR5cGUuSG92ZXIsXG4gICAgZXhwb3J0cy5BbmltYXRpb25UeXBlLlRhcCxcbiAgICBleHBvcnRzLkFuaW1hdGlvblR5cGUuRHJhZyxcbiAgICBleHBvcnRzLkFuaW1hdGlvblR5cGUuRXhpdCxcbl07XG52YXIgcmV2ZXJzZVByaW9yaXR5T3JkZXIgPSB0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQodmFyaWFudFByaW9yaXR5T3JkZXIpLCBmYWxzZSkucmV2ZXJzZSgpO1xudmFyIG51bUFuaW1hdGlvblR5cGVzID0gdmFyaWFudFByaW9yaXR5T3JkZXIubGVuZ3RoO1xuZnVuY3Rpb24gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX2EuYW5pbWF0aW9uLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgYW5pbWF0ZSA9IGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpO1xuICAgIHZhciBzdGF0ZSA9IGNyZWF0ZVN0YXRlKCk7XG4gICAgdmFyIGFsbEFuaW1hdGVkS2V5cyA9IHt9O1xuICAgIHZhciBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlZHVjZSB0aGUgYW5pbWF0aW9uIGRlZmluaXRpb25zIGZvclxuICAgICAqIGVhY2ggYWN0aXZlIGFuaW1hdGlvbiB0eXBlIGludG8gYW4gb2JqZWN0IG9mIHJlc29sdmVkIHZhbHVlcyBmb3IgaXQuXG4gICAgICovXG4gICAgdmFyIGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzID0gZnVuY3Rpb24gKGFjYywgZGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZC50cmFuc2l0aW9uOyB2YXIgdHJhbnNpdGlvbkVuZCA9IHJlc29sdmVkLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IHRzbGliLl9fcmVzdChyZXNvbHZlZCwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgICAgICAgYWNjID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGFjYyksIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc0FuaW1hdGVkKGtleSkge1xuICAgICAgICByZXR1cm4gYWxsQW5pbWF0ZWRLZXlzW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBqdXN0IGFsbG93cyB1cyB0byBpbmplY3QgbW9ja2VkIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBbmltYXRlRnVuY3Rpb24obWFrZUFuaW1hdG9yKSB7XG4gICAgICAgIGFuaW1hdGUgPSBtYWtlQW5pbWF0b3IodmlzdWFsRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgcmVjZWl2ZSBuZXcgcHJvcHMsIHdlIG5lZWQgdG86XG4gICAgICogMS4gQ3JlYXRlIGEgbGlzdCBvZiBwcm90ZWN0ZWQga2V5cyBmb3IgZWFjaCB0eXBlLiBUaGlzIGlzIGEgZGlyZWN0b3J5IG9mXG4gICAgICogICAgdmFsdWUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgXCJoYW5kbGVkXCIgYnkgdHlwZXMgb2YgYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgKiAgICBzbyB0aGF0IHdoZW5ldmVyIGFuIGFuaW1hdGlvbiBpcyBwbGF5ZWQgb2YgYSBnaXZlbiB0eXBlLCB0aGVzZSB2YWx1ZXMgYXJlXG4gICAgICogICAgcHJvdGVjdGVkIGZyb20gYmVpbmcgYW5pbWF0ZWQuXG4gICAgICogMi4gRGV0ZXJtaW5lIGlmIGFuIGFuaW1hdGlvbiB0eXBlIG5lZWRzIGFuaW1hdGluZy5cbiAgICAgKiAzLiBEZXRlcm1pbmUgaWYgYW55IHZhbHVlcyBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIGEgdHlwZSBhbmQgZmlndXJlIG91dFxuICAgICAqICAgIHdoYXQgdG8gYW5pbWF0ZSB0aG9zZSB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlQ2hhbmdlcyhvcHRpb25zLCBjaGFuZ2VkQWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB2aXN1YWxFbGVtZW50LmdldFZhcmlhbnRDb250ZXh0KHRydWUpIHx8IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGFuaW1hdGlvbnMgdGhhdCB3ZSdsbCBidWlsZCBpbnRvIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIHR5cGVzLiBUaGlzIHdpbGwgZ2V0IGV4ZWN1dGVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2Ygd2hpY2ggdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLiBUaGVuLCBhcyB3ZSBoaXQgbG93ZXIgcHJpb3JpdHlcbiAgICAgICAgICogYW5pbWF0aW9uIHR5cGVzLCB3ZSBjYW4gY2hlY2sgaWYgdGhleSBjb250YWluIHJlbW92ZWQgdmFsdWVzIGFuZCBhbmltYXRlIHRvIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVtb3ZlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRpY3Rpb25hcnkgb2YgYWxsIGVuY291bnRlcmVkIGtleXMuIFRoaXMgaXMgYW4gb2JqZWN0IHRvIGxldCB1cyBidWlsZCBpbnRvIGFuZFxuICAgICAgICAgKiBjb3B5IGl0IHdpdGhvdXQgaXRlcmF0aW9uLiBFYWNoIHRpbWUgd2UgaGl0IGFuIGFuaW1hdGlvbiB0eXBlIHdlIHNldCBpdHMgcHJvdGVjdGVkXG4gICAgICAgICAqIGtleXMgLSB0aGUga2V5cyBpdHMgbm90IGFsbG93ZWQgdG8gYW5pbWF0ZSAtIHRvIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBlbmNvdW50ZXJlZEtleXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgdmFyaWFudCBoYXMgYmVlbiByZW1vdmVkIGF0IGEgZ2l2ZW4gaW5kZXgsIGFuZCB0aGlzIGNvbXBvbmVudCBpcyBjb250cm9sbGluZ1xuICAgICAgICAgKiB2YXJpYW50IGFuaW1hdGlvbnMsIHdlIHdhbnQgdG8gZW5zdXJlIGxvd2VyLXByaW9yaXR5IHZhcmlhbnRzIGFyZSBmb3JjZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZW1vdmVkVmFyaWFudEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gcmV2ZXJzZVByaW9yaXR5T3JkZXJbaV07XG4gICAgICAgICAgICB2YXIgdHlwZVN0YXRlID0gc3RhdGVbdHlwZV07XG4gICAgICAgICAgICB2YXIgcHJvcCA9IChfYSA9IHByb3BzW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250ZXh0W3R5cGVdO1xuICAgICAgICAgICAgdmFyIHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyB0eXBlIGhhcyAqanVzdCogY2hhbmdlZCBpc0FjdGl2ZSBzdGF0dXMsIHNldCBhY3RpdmVEZWx0YVxuICAgICAgICAgICAgICogdG8gdGhhdCBzdGF0dXMuIE90aGVyd2lzZSBzZXQgdG8gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGFjdGl2ZURlbHRhID0gdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgPyB0eXBlU3RhdGUuaXNBY3RpdmUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZW1vdmVkVmFyaWFudEluZGV4ID0gaTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBwcm9wIGlzIGFuIGluaGVyaXRlZCB2YXJpYW50LCByYXRoZXIgdGhhbiBiZWVuIHNldCBkaXJlY3RseSBvbiB0aGVcbiAgICAgICAgICAgICAqIGNvbXBvbmVudCBpdHNlbGYsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFsbG93IHRoZSBwYXJlbnQgdG8gdHJpZ2dlciBhbmltYXRpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IENhbiBwcm9iYWJseSBjaGFuZ2UgdGhpcyB0byBhICFpc0NvbnRyb2xsaW5nVmFyaWFudHMgY2hlY2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGlzSW5oZXJpdGVkID0gcHJvcCA9PT0gY29udGV4dFt0eXBlXSAmJiBwcm9wICE9PSBwcm9wc1t0eXBlXSAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNJbmhlcml0ZWQgJiZcbiAgICAgICAgICAgICAgICBpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgICAgICBpc0luaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGVuY291bnRlcmVkIGtleXMgc28gZmFyIGFzIHRoZSBwcm90ZWN0ZWQga2V5cyBmb3IgdGhpcyB0eXBlLiBUaGlzIHdpbGxcbiAgICAgICAgICAgICAqIGJlIGFueSBrZXkgdGhhdCBoYXMgYmVlbiBhbmltYXRlZCBvciBvdGhlcndpc2UgaGFuZGxlZCBieSBhY3RpdmUsIGhpZ2hlci1wcmlvcnRpeSB0eXBlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgZW5jb3VudGVyZWRLZXlzKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBza2lwIGFuYWx5c2luZyB0aGlzIHByb3AgZWFybHlcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IGFjdGl2ZSBhbmQgaGFzbid0ICpqdXN0KiBiZWVuIHNldCBhcyBpbmFjdGl2ZVxuICAgICAgICAgICAgKCF0eXBlU3RhdGUuaXNBY3RpdmUgJiYgYWN0aXZlRGVsdGEgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGFuZCBkb24ndCBoYXZlIGFueSBkZWZpbmVkIHByb3AgZm9yIHRoaXMgYW5pbWF0aW9uIHR5cGVcbiAgICAgICAgICAgICAgICAoIXByb3AgJiYgIXR5cGVTdGF0ZS5wcmV2UHJvcCkgfHxcbiAgICAgICAgICAgICAgICAvLyBPciBpZiB0aGUgcHJvcCBkb2Vzbid0IGRlZmluZSBhbiBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3ApIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHByb3AgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgd2UgZ28gbG9vayB0aHJvdWdoIHRoZSB2YWx1ZXMgZGVmaW5lZCBvbiB0aGlzIHR5cGUsIGlmIHdlIGRldGVjdFxuICAgICAgICAgICAgICogYSBjaGFuZ2VkIHZhbHVlIG9yIGEgdmFsdWUgdGhhdCB3YXMgcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSwgd2Ugc2V0XG4gICAgICAgICAgICAgKiB0aGlzIHRvIHRydWUgYW5kIGFkZCB0aGlzIHByb3AgdG8gdGhlIGFuaW1hdGlvbiBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdmFyaWFudERpZENoYW5nZSA9IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UodHlwZVN0YXRlLnByZXZQcm9wLCBwcm9wKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRBbmltYXRlVHlwZSA9IHZhcmlhbnREaWRDaGFuZ2UgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBtYWtpbmcgdGhpcyB2YXJpYW50IGFjdGl2ZSwgd2Ugd2FudCB0byBhbHdheXMgbWFrZSBpdCBhY3RpdmVcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLmlzQWN0aXZlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0luaGVyaXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBwcm9wSXNWYXJpYW50KSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBoaWdoZXItcHJpb3JpdHkgdmFyaWFudCAoaSBpcyBpbiByZXZlcnNlIG9yZGVyKVxuICAgICAgICAgICAgICAgIChpID4gcmVtb3ZlZFZhcmlhbnRJbmRleCAmJiBwcm9wSXNWYXJpYW50KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgYW5pbWF0aW9ucyBjYW4gYmUgc2V0IGFzIHZhcmlhbnQgbGlzdHMsIHZhcmlhbnRzIG9yIHRhcmdldCBvYmplY3RzLCB3ZVxuICAgICAgICAgICAgICogY29lcmNlIGV2ZXJ5dGhpbmcgdG8gYW4gYXJyYXkgaWYgaXQgaXNuJ3Qgb25lIGFscmVhZHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGRlZmluaXRpb25MaXN0ID0gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWxkIGFuIG9iamVjdCBvZiBhbGwgdGhlIHJlc29sdmVkIHZhbHVlcy4gV2UnbGwgdXNlIHRoaXMgaW4gdGhlIHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAqIGFuaW1hdGVDaGFuZ2VzIGNhbGxzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcywge30pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3cgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBrZXlzIGluIHRoZSBwcmV2IHByb3AgYW5kIHRoaXMgcHJvcCxcbiAgICAgICAgICAgICAqIGFuZCBkZWNpZGU6XG4gICAgICAgICAgICAgKiAxLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDIuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZCBuZWVkcyBhZGRpbmcgdG8gdGhlIHJlbW92ZWRLZXlzIHNldFxuICAgICAgICAgICAgICogMy4gSWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSB0eXBlIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDQuIElmIGl0IGhhc24ndCBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgYnV0IGhhc24ndCBjaGFuZ2VkLCBhbmRcbiAgICAgICAgICAgICAqICAgIG5lZWRzIGFkZGluZyB0byB0aGUgdHlwZSdzIHByb3RlY3RlZEtleXMgbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIF9iID0gdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcywgcHJldlJlc29sdmVkVmFsdWVzID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgICAgICAgICB2YXIgYWxsS2V5cyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBwcmV2UmVzb2x2ZWRWYWx1ZXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgbWFya1RvQW5pbWF0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHlwZVN0YXRlLm5lZWRzQW5pbWF0aW5nW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSByZXNvbHZlZFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoaXMgd2UgY2FuIGp1c3Qgc2tpcCBhaGVhZFxuICAgICAgICAgICAgICAgIGlmIChlbmNvdW50ZXJlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCB3ZSBwcm9iYWJseSB3YW50IHRvIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIGJvdGggdmFsdWVzIGFyZSBrZXlmcmFtZXMsIHdlIG5lZWQgdG8gc2hhbGxvdyBjb21wYXJlIHRoZW0gdG9cbiAgICAgICAgICAgICAgICAgICAgICogZGV0ZWN0IHdoZXRoZXIgYW55IHZhbHVlIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXMsIHdlIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQobmV4dCkgJiYgaXNLZXlmcmFtZXNUYXJnZXQocHJldikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldikgfHwgdmFyaWFudERpZENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIGl0IGhhc24ndCBjaGFuZ2VkLCB3ZSB3YW50IHRvIGVuc3VyZSBpdCBkb2Vzbid0IGFuaW1hdGUgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhZGRpbmcgaXQgdG8gdGhlIGxpc3Qgb2YgcHJvdGVjdGVkIGtleXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuZXh0IGlzIGRlZmluZWQgYW5kIGRvZXNuJ3QgZXF1YWwgcHJldiwgaXQgbmVlZHMgYW5pbWF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHVuZGVmaW5lZCwgaXQncyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgcmVtb3ZlZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIG5leHQgaGFzbid0IGNoYW5nZWQgYW5kIGl0IGlzbid0IHVuZGVmaW5lZCwgd2Ugd2FudCB0byBjaGVjayBpZiBpdCdzXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZW4gcmVtb3ZlZCBieSBhIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIGl0IGhhc24ndCBjaGFuZ2VkLCB3ZSBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgcHJvdGVjdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgKiB0byBlbnN1cmUgaXQgZG9lc24ndCBnZXQgYW5pbWF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgdHlwZVN0YXRlIHNvIG5leHQgdGltZSBhbmltYXRlQ2hhbmdlcyBpcyBjYWxsZWQgd2UgY2FuIGNvbXBhcmUgdGhlXG4gICAgICAgICAgICAgKiBsYXRlc3QgcHJvcCBhbmQgcmVzb2x2ZWRWYWx1ZXMgdG8gdGhlc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHR5cGVTdGF0ZS5wcmV2UHJvcCA9IHByb3A7XG4gICAgICAgICAgICB0eXBlU3RhdGUucHJldlJlc29sdmVkVmFsdWVzID0gcmVzb2x2ZWRWYWx1ZXM7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlU3RhdGUuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBlbmNvdW50ZXJlZEtleXMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZW5jb3VudGVyZWRLZXlzKSwgcmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50LmJsb2NrSW5pdGlhbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gaW5oZXJpdGVkIHByb3Agd2Ugd2FudCB0byBoYXJkLWJsb2NrIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIFRPRE86IFRlc3QgYXMgdGhpcyBzaG91bGQgcHJvYmFibHkgc3RpbGwgaGFuZGxlIGFuaW1hdGlvbnMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgKiBieSByZW1vdmVkIHZhbHVlcz9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNob3VsZEFuaW1hdGVUeXBlICYmICFpc0luaGVyaXRlZCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaC5hcHBseShhbmltYXRpb25zLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQoZGVmaW5pdGlvbkxpc3QubWFwKGZ1bmN0aW9uIChhbmltYXRpb24pIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0c2xpYi5fX2Fzc2lnbih7IHR5cGU6IHR5cGUgfSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgfSk7IH0pKSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgYW5pbWF0aW9uIHR5cGVzIGluIHJldmVyc2UgcHJpb3JpdHkgb3JkZXIuIEZvciBlYWNoLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIGRldGVjdCB3aGljaCB2YWx1ZXMgaXQncyBoYW5kbGluZyBhbmQgd2hldGhlciBvciBub3QgdGhleSd2ZSBjaGFuZ2VkIChhbmQgdGhlcmVmb3JlXG4gICAgICAgICAqIG5lZWQgdG8gYmUgYW5pbWF0ZWQpLiBJZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLCB3ZSB3YW50IHRvIGRldGVjdCB0aG9zZSBpblxuICAgICAgICAgKiBsb3dlciBwcmlvcml0eSBwcm9wcyBhbmQgZmxhZyBmb3IgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BbmltYXRpb25UeXBlczsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIGFsbEFuaW1hdGVkS2V5cyA9IHRzbGliLl9fYXNzaWduKHt9LCBlbmNvdW50ZXJlZEtleXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUgYXJlIHNvbWUgcmVtb3ZlZCB2YWx1ZSB0aGF0IGhhdmVuJ3QgYmVlbiBkZWFsdCB3aXRoLFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhbmltYXRpb24gdGhhdCBmYWxscyBiYWNrIGVpdGhlciB0byB0aGUgdmFsdWVcbiAgICAgICAgICogZGVmaW5lZCBpbiB0aGUgc3R5bGUgcHJvcCwgb3IgdGhlIGxhc3QgcmVhZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZW1vdmVkS2V5cy5zaXplKSB7XG4gICAgICAgICAgICB2YXIgZmFsbGJhY2tBbmltYXRpb25fMSA9IHt9O1xuICAgICAgICAgICAgcmVtb3ZlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrVGFyZ2V0ID0gdmlzdWFsRWxlbWVudC5nZXRCYXNlVGFyZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhbGxiYWNrVGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tBbmltYXRpb25fMVtrZXldID0gZmFsbGJhY2tUYXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goeyBhbmltYXRpb246IGZhbGxiYWNrQW5pbWF0aW9uXzEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZEFuaW1hdGUgPSBCb29sZWFuKGFuaW1hdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJlxuICAgICAgICAgICAgcHJvcHMuaW5pdGlhbCA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICF2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpc0luaXRpYWxSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNob3VsZEFuaW1hdGUgPyBhbmltYXRlKGFuaW1hdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB3aGV0aGVyIGEgY2VydGFpbiBhbmltYXRpb24gdHlwZSBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gSWYgdGhlIGFjdGl2ZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZCwgd2UgY2FuIHNhZmVseSBkbyBub3RoaW5nIGhlcmVcbiAgICAgICAgaWYgKHN0YXRlW3R5cGVdLmlzQWN0aXZlID09PSBpc0FjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIGFjdGl2ZSBjaGFuZ2UgdG8gY2hpbGRyZW5cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBjaGlsZC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSk7IH0pO1xuICAgICAgICBzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IGFuaW1hdGVDaGFuZ2VzKG9wdGlvbnMsIHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgIHN0YXRlW2tleV0ucHJvdGVjdGVkS2V5cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0FuaW1hdGVkOiBpc0FuaW1hdGVkLFxuICAgICAgICBhbmltYXRlQ2hhbmdlczogYW5pbWF0ZUNoYW5nZXMsXG4gICAgICAgIHNldEFjdGl2ZTogc2V0QWN0aXZlLFxuICAgICAgICBzZXRBbmltYXRlRnVuY3Rpb246IHNldEFuaW1hdGVGdW5jdGlvbixcbiAgICAgICAgZ2V0U3RhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlOyB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlKHByZXYsIG5leHQpIHtcbiAgICBpZiAodHlwZW9mIG5leHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5leHQgIT09IHByZXY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVmFyaWFudExhYmVscyhuZXh0KSkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlU3RhdGUoaXNBY3RpdmUpIHtcbiAgICBpZiAoaXNBY3RpdmUgPT09IHZvaWQgMCkgeyBpc0FjdGl2ZSA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgICAgICBwcm90ZWN0ZWRLZXlzOiB7fSxcbiAgICAgICAgbmVlZHNBbmltYXRpbmc6IHt9LFxuICAgICAgICBwcmV2UmVzb2x2ZWRWYWx1ZXM6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9hID0ge30sXG4gICAgICAgIF9hW2V4cG9ydHMuQW5pbWF0aW9uVHlwZS5BbmltYXRlXSA9IGNyZWF0ZVR5cGVTdGF0ZSh0cnVlKSxcbiAgICAgICAgX2FbZXhwb3J0cy5BbmltYXRpb25UeXBlLkluVmlld10gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2FbZXhwb3J0cy5BbmltYXRpb25UeXBlLkhvdmVyXSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYVtleHBvcnRzLkFuaW1hdGlvblR5cGUuVGFwXSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYVtleHBvcnRzLkFuaW1hdGlvblR5cGUuRHJhZ10gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2FbZXhwb3J0cy5BbmltYXRpb25UeXBlLkZvY3VzXSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYVtleHBvcnRzLkFuaW1hdGlvblR5cGUuRXhpdF0gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2E7XG59XG5cbnZhciBhbmltYXRpb25zID0ge1xuICAgIGFuaW1hdGlvbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgYW5pbWF0ZSA9IF9hLmFuaW1hdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBkeW5hbWljYWxseSBnZW5lcmF0ZSB0aGUgQW5pbWF0aW9uU3RhdGUgbWFuYWdlciBhcyBpdCBjb250YWlucyBhIHJlZmVyZW5jZVxuICAgICAgICAgKiB0byB0aGUgdW5kZXJseWluZyBhbmltYXRpb24gbGlicmFyeS4gV2Ugb25seSB3YW50IHRvIGxvYWQgdGhhdCBpZiB3ZSBsb2FkIHRoaXMsXG4gICAgICAgICAqIHNvIHBlb3BsZSBjYW4gb3B0aW9uYWxseSBjb2RlIHNwbGl0IGl0IG91dCB1c2luZyB0aGUgYG1gIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgfHwgKHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgPSBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJzY3JpYmUgYW55IHByb3ZpZGVkIEFuaW1hdGlvbkNvbnRyb2xzIHRvIHRoZSBjb21wb25lbnQncyBWaXN1YWxFbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNBbmltYXRpb25Db250cm9scyhhbmltYXRlKSkge1xuICAgICAgICAgICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGUuc3Vic2NyaWJlKHZpc3VhbEVsZW1lbnQpOyB9LCBbYW5pbWF0ZV0pO1xuICAgICAgICB9XG4gICAgfSksXG4gICAgZXhpdDogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQoZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBjdXN0b20gPSBwcm9wcy5jdXN0b20sIHZpc3VhbEVsZW1lbnQgPSBwcm9wcy52aXN1YWxFbGVtZW50O1xuICAgICAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQodXNlUHJlc2VuY2UoKSwgMiksIGlzUHJlc2VudCA9IF9hWzBdLCBzYWZlVG9SZW1vdmUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcbiAgICAgICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSAoX2EgPSB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGV4cG9ydHMuQW5pbWF0aW9uVHlwZS5FeGl0LCAhaXNQcmVzZW50LCB7IGN1c3RvbTogKF9iID0gcHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmN1c3RvbSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3VzdG9tIH0pO1xuICAgICAgICAgICAgIWlzUHJlc2VudCAmJiAoYW5pbWF0aW9uID09PSBudWxsIHx8IGFuaW1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5pbWF0aW9uLnRoZW4oc2FmZVRvUmVtb3ZlKSk7XG4gICAgICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICB9KSxcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBQYW5TZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhblNlc3Npb24oZXZlbnQsIGhhbmRsZXJzLCBfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHJhbnNmb3JtUGFnZVBvaW50ID0gX2IudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEoX3RoaXMubGFzdE1vdmVFdmVudCAmJiBfdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBnZXRQYW5JbmZvKF90aGlzLmxhc3RNb3ZlRXZlbnRJbmZvLCBfdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIHZhciBpc1BhblN0YXJ0ZWQgPSBfdGhpcy5zdGFydEV2ZW50ICE9PSBudWxsO1xuICAgICAgICAgICAgLy8gT25seSBzdGFydCBwYW5uaW5nIGlmIHRoZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gMyBwaXhlbHMuIElmIHdlIG1ha2UgaXRcbiAgICAgICAgICAgIC8vIGFueSBsYXJnZXIgdGhhbiB0aGlzIHdlJ2xsIHdhbnQgdG8gcmVzZXQgdGhlIHBvaW50ZXIgaGlzdG9yeVxuICAgICAgICAgICAgLy8gb24gdGhlIGZpcnN0IHVwZGF0ZSB0byBhdm9pZCB2aXN1YWwgc25hcHBpbmcgdG8gdGhlIGN1cnNvZS5cbiAgICAgICAgICAgIHZhciBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IHBvcG1vdGlvbi5kaXN0YW5jZShpbmZvLm9mZnNldCwgeyB4OiAwLCB5OiAwIH0pID49IDM7XG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCAmJiAhaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gaW5mby5wb2ludDtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBzeW5jLmdldEZyYW1lRGF0YSgpLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIF90aGlzLmhpc3RvcnkucHVzaCh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcG9pbnQpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0pKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmhhbmRsZXJzLCBvblN0YXJ0ID0gX2Eub25TdGFydCwgb25Nb3ZlID0gX2Eub25Nb3ZlO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoX3RoaXMubGFzdE1vdmVFdmVudCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRFdmVudCA9IF90aGlzLmxhc3RNb3ZlRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUgJiYgb25Nb3ZlKF90aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBfdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIF90aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIFNhZmFyaSBkb2Vzbid0IHRyaWdnZXIgbW91c2V1cCBldmVudHMgd2hlbiBpdCdzIGFib3ZlIGEgYDxzZWxlY3Q+YFxuICAgICAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJVcChldmVudCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhyb3R0bGUgbW91c2UgbW92ZSBldmVudCB0byBvbmNlIHBlciBmcmFtZVxuICAgICAgICAgICAgc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0udXBkYXRlKF90aGlzLnVwZGF0ZVBvaW50LCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLmVuZCgpO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuaGFuZGxlcnMsIG9uRW5kID0gX2Eub25FbmQsIG9uU2Vzc2lvbkVuZCA9IF9hLm9uU2Vzc2lvbkVuZDtcbiAgICAgICAgICAgIHZhciBwYW5JbmZvID0gZ2V0UGFuSW5mbyh0cmFuc2Zvcm1Qb2ludChpbmZvLCBfdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpLCBfdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydEV2ZW50ICYmIG9uRW5kKSB7XG4gICAgICAgICAgICAgICAgb25FbmQoZXZlbnQsIHBhbkluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TZXNzaW9uRW5kICYmIG9uU2Vzc2lvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSB0b3VjaCwgZG9uJ3Qgc3RhcnQgZGV0ZWN0aW5nIHRoaXMgZ2VzdHVyZVxuICAgICAgICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQgPSB0cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgICAgIHZhciBpbmZvID0gZXh0cmFjdEV2ZW50SW5mbyhldmVudCk7XG4gICAgICAgIHZhciBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgdmFyIHBvaW50ID0gaW5pdGlhbEluZm8ucG9pbnQ7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBzeW5jLmdldEZyYW1lRGF0YSgpLnRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW3RzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBwb2ludCksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSldO1xuICAgICAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBoYW5kbGVycy5vblNlc3Npb25TdGFydDtcbiAgICAgICAgb25TZXNzaW9uU3RhcnQgJiZcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0KGV2ZW50LCBnZXRQYW5JbmZvKGluaXRpYWxJbmZvLCB0aGlzLmhpc3RvcnkpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgPSBwb3Btb3Rpb24ucGlwZShhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCkpO1xuICAgIH1cbiAgICBQYW5TZXNzaW9uLnByb3RvdHlwZS51cGRhdGVIYW5kbGVycyA9IGZ1bmN0aW9uIChoYW5kbGVycykge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgfTtcbiAgICBQYW5TZXNzaW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzICYmIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHN5bmMuY2FuY2VsU3luYy51cGRhdGUodGhpcy51cGRhdGVQb2ludCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFuU2Vzc2lvbjtcbn0oKSk7XG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFnZVBvaW50ID8geyBwb2ludDogdHJhbnNmb3JtUGFnZVBvaW50KGluZm8ucG9pbnQpIH0gOiBpbmZvO1xufVxuZnVuY3Rpb24gc3VidHJhY3RQb2ludChhLCBiKSB7XG4gICAgcmV0dXJuIHsgeDogYS54IC0gYi54LCB5OiBhLnkgLSBiLnkgfTtcbn1cbmZ1bmN0aW9uIGdldFBhbkluZm8oX2EsIGhpc3RvcnkpIHtcbiAgICB2YXIgcG9pbnQgPSBfYS5wb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGRlbHRhOiBzdWJ0cmFjdFBvaW50KHBvaW50LCBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgICAgICBvZmZzZXQ6IHN1YnRyYWN0UG9pbnQocG9pbnQsIHN0YXJ0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgICAgICB2ZWxvY2l0eTogZ2V0VmVsb2NpdHkoaGlzdG9yeSwgMC4xKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbMF07XG59XG5mdW5jdGlvbiBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSkge1xuICAgIHJldHVybiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRWZWxvY2l0eShoaXN0b3J5LCB0aW1lRGVsdGEpIHtcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgdmFyIGkgPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgdmFyIHRpbWVzdGFtcGVkUG9pbnQgPSBudWxsO1xuICAgIHZhciBsYXN0UG9pbnQgPSBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSk7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICB0aW1lc3RhbXBlZFBvaW50ID0gaGlzdG9yeVtpXTtcbiAgICAgICAgaWYgKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCA+XG4gICAgICAgICAgICBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcGVkUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICB2YXIgdGltZSA9IChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApIC8gMTAwMDtcbiAgICBpZiAodGltZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIHZhciBjdXJyZW50VmVsb2NpdHkgPSB7XG4gICAgICAgIHg6IChsYXN0UG9pbnQueCAtIHRpbWVzdGFtcGVkUG9pbnQueCkgLyB0aW1lLFxuICAgICAgICB5OiAobGFzdFBvaW50LnkgLSB0aW1lc3RhbXBlZFBvaW50LnkpIC8gdGltZSxcbiAgICB9O1xuICAgIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY3VycmVudFZlbG9jaXR5LnggPSAwO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFZlbG9jaXR5LnkgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS55ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRWZWxvY2l0eTtcbn1cblxuZnVuY3Rpb24gY2FsY0xlbmd0aChheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMubWF4IC0gYXhpcy5taW47XG59XG5mdW5jdGlvbiBpc05lYXIodmFsdWUsIHRhcmdldCwgbWF4RGlzdGFuY2UpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gMDsgfVxuICAgIGlmIChtYXhEaXN0YW5jZSA9PT0gdm9pZCAwKSB7IG1heERpc3RhbmNlID0gMC4wMTsgfVxuICAgIHJldHVybiBwb3Btb3Rpb24uZGlzdGFuY2UodmFsdWUsIHRhcmdldCkgPCBtYXhEaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbGNBeGlzRGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSB2b2lkIDApIHsgb3JpZ2luID0gMC41OyB9XG4gICAgZGVsdGEub3JpZ2luID0gb3JpZ2luO1xuICAgIGRlbHRhLm9yaWdpblBvaW50ID0gcG9wbW90aW9uLm1peChzb3VyY2UubWluLCBzb3VyY2UubWF4LCBkZWx0YS5vcmlnaW4pO1xuICAgIGRlbHRhLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIGlmIChpc05lYXIoZGVsdGEuc2NhbGUsIDEsIDAuMDAwMSkgfHwgaXNOYU4oZGVsdGEuc2NhbGUpKVxuICAgICAgICBkZWx0YS5zY2FsZSA9IDE7XG4gICAgZGVsdGEudHJhbnNsYXRlID1cbiAgICAgICAgcG9wbW90aW9uLm1peCh0YXJnZXQubWluLCB0YXJnZXQubWF4LCBkZWx0YS5vcmlnaW4pIC0gZGVsdGEub3JpZ2luUG9pbnQ7XG4gICAgaWYgKGlzTmVhcihkZWx0YS50cmFuc2xhdGUpIHx8IGlzTmFOKGRlbHRhLnRyYW5zbGF0ZSkpXG4gICAgICAgIGRlbHRhLnRyYW5zbGF0ZSA9IDA7XG59XG5mdW5jdGlvbiBjYWxjQm94RGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICBjYWxjQXhpc0RlbHRhKGRlbHRhLngsIHNvdXJjZS54LCB0YXJnZXQueCwgb3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luLm9yaWdpblgpO1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueSwgc291cmNlLnksIHRhcmdldC55LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICAgIHRhcmdldC5taW4gPSBwYXJlbnQubWluICsgcmVsYXRpdmUubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChyZWxhdGl2ZSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVCb3godGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueCwgcmVsYXRpdmUueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LnksIHJlbGF0aXZlLnksIHBhcmVudC55KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IGxheW91dC5taW4gLSBwYXJlbnQubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChsYXlvdXQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueCwgbGF5b3V0LngsIHBhcmVudC54KTtcbiAgICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LnksIGxheW91dC55LCBwYXJlbnQueSk7XG59XG5cbi8qKlxuICogQXBwbHkgY29uc3RyYWludHMgdG8gYSBwb2ludC4gVGhlc2UgY29uc3RyYWludHMgYXJlIGJvdGggcGh5c2ljYWwgYWxvbmcgYW5cbiAqIGF4aXMsIGFuZCBhbiBlbGFzdGljIGZhY3RvciB0aGF0IGRldGVybWluZXMgaG93IG11Y2ggdG8gY29uc3RyYWluIHRoZSBwb2ludFxuICogYnkgaWYgaXQgZG9lcyBsaWUgb3V0c2lkZSB0aGUgZGVmaW5lZCBwYXJhbWV0ZXJzLlxuICovXG5mdW5jdGlvbiBhcHBseUNvbnN0cmFpbnRzKHBvaW50LCBfYSwgZWxhc3RpYykge1xuICAgIHZhciBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heDtcbiAgICBpZiAobWluICE9PSB1bmRlZmluZWQgJiYgcG9pbnQgPCBtaW4pIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1pbiBwb2ludCBkZWZpbmVkLCBhbmQgdGhpcyBpcyBvdXRzaWRlIG9mIHRoYXQsIGNvbnN0cmFpblxuICAgICAgICBwb2ludCA9IGVsYXN0aWMgPyBwb3Btb3Rpb24ubWl4KG1pbiwgcG9pbnQsIGVsYXN0aWMubWluKSA6IE1hdGgubWF4KHBvaW50LCBtaW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBwb2ludCA+IG1heCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF4IHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpYyA/IHBvcG1vdGlvbi5taXgobWF4LCBwb2ludCwgZWxhc3RpYy5tYXgpIDogTWF0aC5taW4ocG9pbnQsIG1heCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuIGRlZmluZWQgcmVsYXRpdmVseSB0byB0aGVcbiAqIG1lYXN1cmVkIGF4aXMuIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSB0aGUgbmVhcmVzdCBlZGdlLCBzbyBhIG1heCBjb25zdHJhaW50IG9mIDIwMFxuICogb24gYW4gYXhpcyB3aXRoIGEgbWF4IHZhbHVlIG9mIDMwMCB3b3VsZCByZXR1cm4gYSBjb25zdHJhaW50IG9mIDUwMCAtIGF4aXMgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhheGlzLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluICE9PSB1bmRlZmluZWQgPyBheGlzLm1pbiArIG1pbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4OiBtYXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBheGlzLm1heCArIG1heCAtIChheGlzLm1heCAtIGF4aXMubWluKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuXG4gKiBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gdGhlIG1lYXN1cmVkIGJvdW5kaW5nIGJveC5cbiAqL1xuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0Qm94LCBfYSkge1xuICAgIHZhciB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCBib3R0b20gPSBfYS5ib3R0b20sIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgICAgIHk6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgdG9wLCBib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBheGlzXG4gKi9cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgICB2YXIgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICAgIC8vIElmIHRoZSBjb25zdHJhaW50cyBheGlzIGlzIGFjdHVhbGx5IHNtYWxsZXIgdGhhbiB0aGUgbGF5b3V0IGF4aXMgdGhlbiB3ZSBjYW5cbiAgICAvLyBmbGlwIHRoZSBjb25zdHJhaW50c1xuICAgIGlmIChjb25zdHJhaW50c0F4aXMubWF4IC0gY29uc3RyYWludHNBeGlzLm1pbiA8XG4gICAgICAgIGxheW91dEF4aXMubWF4IC0gbGF5b3V0QXhpcy5taW4pIHtcbiAgICAgICAgX2EgPSB0c2xpYi5fX3JlYWQoW21heCwgbWluXSwgMiksIG1pbiA9IF9hWzBdLCBtYXggPSBfYVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluOiBtaW4sIG1heDogbWF4IH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgICAgIHk6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgY29uc3RyYWludHNCb3gueSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgc291cmNlIGF4aXMsIGJldHdlZW4gMC0xLCB0aGF0IHJlc3VsdHNcbiAqIGluIGFuIGFzdGhldGljYWxseSBwbGVhc2luZyBzY2FsZS90cmFuc2Zvcm0gbmVlZGVkIHRvIHByb2plY3QgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBjYWxjT3JpZ2luKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgdmFyIG9yaWdpbiA9IDAuNTtcbiAgICB2YXIgc291cmNlTGVuZ3RoID0gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIHZhciB0YXJnZXRMZW5ndGggPSBjYWxjTGVuZ3RoKHRhcmdldCk7XG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwb3Btb3Rpb24ucHJvZ3Jlc3ModGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCAtIHNvdXJjZUxlbmd0aCwgc291cmNlLm1pbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvdXJjZUxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwb3Btb3Rpb24ucHJvZ3Jlc3Moc291cmNlLm1pbiwgc291cmNlLm1heCAtIHRhcmdldExlbmd0aCwgdGFyZ2V0Lm1pbik7XG4gICAgfVxuICAgIHJldHVybiBwb3Btb3Rpb24uY2xhbXAoMCwgMSwgb3JpZ2luKTtcbn1cbi8qKlxuICogUmViYXNlIHRoZSBjYWxjdWxhdGVkIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHJlbGF0aXZlIHRvIHRoZSBsYXlvdXQubWluIHBvaW50LlxuICovXG5mdW5jdGlvbiByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LCBjb25zdHJhaW50cykge1xuICAgIHZhciByZWxhdGl2ZUNvbnN0cmFpbnRzID0ge307XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWluID0gY29uc3RyYWludHMubWluIC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWF4ID0gY29uc3RyYWludHMubWF4IC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG52YXIgZGVmYXVsdEVsYXN0aWMgPSAwLjM1O1xuLyoqXG4gKiBBY2NlcHRzIGEgZHJhZ0VsYXN0aWMgcHJvcCBhbmQgcmV0dXJucyByZXNvbHZlZCBlbGFzdGljIHZhbHVlcyBmb3IgZWFjaCBheGlzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpIHtcbiAgICBpZiAoZHJhZ0VsYXN0aWMgPT09IHZvaWQgMCkgeyBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljOyB9XG4gICAgaWYgKGRyYWdFbGFzdGljID09PSBmYWxzZSkge1xuICAgICAgICBkcmFnRWxhc3RpYyA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWdFbGFzdGljID09PSB0cnVlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJsZWZ0XCIsIFwicmlnaHRcIiksXG4gICAgICAgIHk6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJ0b3BcIiwgXCJib3R0b21cIiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwsIG1heExhYmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCksXG4gICAgICAgIG1heDogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWF4TGFiZWwpLFxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBsYWJlbCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gdHlwZW9mIGRyYWdFbGFzdGljID09PSBcIm51bWJlclwiXG4gICAgICAgID8gZHJhZ0VsYXN0aWNcbiAgICAgICAgOiAoX2EgPSBkcmFnRWxhc3RpY1tsYWJlbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG59XG5cbnZhciBjcmVhdGVBeGlzRGVsdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHRyYW5zbGF0ZTogMCxcbiAgICBzY2FsZTogMSxcbiAgICBvcmlnaW46IDAsXG4gICAgb3JpZ2luUG9pbnQ6IDAsXG59KTsgfTtcbnZhciBjcmVhdGVEZWx0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgeDogY3JlYXRlQXhpc0RlbHRhKCksXG4gICAgeTogY3JlYXRlQXhpc0RlbHRhKCksXG59KTsgfTtcbnZhciBjcmVhdGVBeGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgbWluOiAwLCBtYXg6IDAgfSk7IH07XG52YXIgY3JlYXRlQm94ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICB4OiBjcmVhdGVBeGlzKCksXG4gICAgeTogY3JlYXRlQXhpcygpLFxufSk7IH07XG5cbmZ1bmN0aW9uIGVhY2hBeGlzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFtjYWxsYmFjayhcInhcIiksIGNhbGxiYWNrKFwieVwiKV07XG59XG5cbi8qKlxuICogQm91bmRpbmcgYm94ZXMgdGVuZCB0byBiZSBkZWZpbmVkIGFzIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbS4gRm9yIHZhcmlvdXMgb3BlcmF0aW9uc1xuICogaXQncyBlYXNpZXIgdG8gY29uc2lkZXIgZWFjaCBheGlzIGluZGl2aWR1YWxseS4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYm91bmRpbmcgYm94XG4gKiBhcyBhIG1hcCBvZiBzaW5nbGUtYXhpcyBtaW4vbWF4IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJvdW5kaW5nQm94VG9Cb3goX2EpIHtcbiAgICB2YXIgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHsgbWluOiBsZWZ0LCBtYXg6IHJpZ2h0IH0sXG4gICAgICAgIHk6IHsgbWluOiB0b3AsIG1heDogYm90dG9tIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KF9hKSB7XG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICByZXR1cm4geyB0b3A6IHkubWluLCByaWdodDogeC5tYXgsIGJvdHRvbTogeS5tYXgsIGxlZnQ6IHgubWluIH07XG59XG4vKipcbiAqIEFwcGxpZXMgYSBUcmFuc2Zvcm1Qb2ludCBmdW5jdGlvbiB0byBhIGJvdW5kaW5nIGJveC4gVHJhbnNmb3JtUG9pbnQgaXMgdXN1YWxseSBhIGZ1bmN0aW9uXG4gKiBwcm92aWRlZCBieSBGcmFtZXIgdG8gYWxsb3cgbWVhc3VyZWQgcG9pbnRzIHRvIGJlIGNvcnJlY3RlZCBmb3IgZGV2aWNlIHNjYWxpbmcuIFRoaXMgaXMgdXNlZFxuICogd2hlbiBtZWFzdXJpbmcgRE9NIGVsZW1lbnRzIGFuZCBET00gZXZlbnQgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3hQb2ludHMocG9pbnQsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgaWYgKCF0cmFuc2Zvcm1Qb2ludClcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIHZhciB0b3BMZWZ0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5sZWZ0LCB5OiBwb2ludC50b3AgfSk7XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5yaWdodCwgeTogcG9pbnQuYm90dG9tIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wTGVmdC55LFxuICAgICAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgICAgIGJvdHRvbTogYm90dG9tUmlnaHQueSxcbiAgICAgICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LngsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGl0eVNjYWxlKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlID09PSB1bmRlZmluZWQgfHwgc2NhbGUgPT09IDE7XG59XG5mdW5jdGlvbiBoYXNTY2FsZShfYSkge1xuICAgIHZhciBzY2FsZSA9IF9hLnNjYWxlLCBzY2FsZVggPSBfYS5zY2FsZVgsIHNjYWxlWSA9IF9hLnNjYWxlWTtcbiAgICByZXR1cm4gKCFpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVYKSB8fFxuICAgICAgICAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWSkpO1xufVxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKHZhbHVlcykge1xuICAgIHJldHVybiAoaGFzU2NhbGUodmFsdWVzKSB8fFxuICAgICAgICBoYXNUcmFuc2xhdGUodmFsdWVzLngpIHx8XG4gICAgICAgIGhhc1RyYW5zbGF0ZSh2YWx1ZXMueSkgfHxcbiAgICAgICAgdmFsdWVzLnogfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZSB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlWCB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlWSk7XG59XG5mdW5jdGlvbiBoYXNUcmFuc2xhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgIT09IFwiMCVcIjtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSBwb2ludCBiYXNlZCBvbiBhIGZhY3RvciBhbmQgYW4gb3JpZ2luUG9pbnRcbiAqL1xuZnVuY3Rpb24gc2NhbGVQb2ludChwb2ludCwgc2NhbGUsIG9yaWdpblBvaW50KSB7XG4gICAgdmFyIGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50IC0gb3JpZ2luUG9pbnQ7XG4gICAgdmFyIHNjYWxlZCA9IHNjYWxlICogZGlzdGFuY2VGcm9tT3JpZ2luO1xuICAgIHJldHVybiBvcmlnaW5Qb2ludCArIHNjYWxlZDtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGFwcGx5UG9pbnREZWx0YShwb2ludCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gICAgaWYgKGJveFNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGVQb2ludChwb2ludCwgc2NhbGUsIG9yaWdpblBvaW50KSArIHRyYW5zbGF0ZTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhbiBheGlzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXhpc0RlbHRhKGF4aXMsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkgeyB0cmFuc2xhdGUgPSAwOyB9XG4gICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxOyB9XG4gICAgYXhpcy5taW4gPSBhcHBseVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG4gICAgYXhpcy5tYXggPSBhcHBseVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG4vKipcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGUvc2NhbGUgZGVsdGEgdG8gYSBib3hcbiAqL1xuZnVuY3Rpb24gYXBwbHlCb3hEZWx0YShib3gsIF9hKSB7XG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICBhcHBseUF4aXNEZWx0YShib3gueCwgeC50cmFuc2xhdGUsIHguc2NhbGUsIHgub3JpZ2luUG9pbnQpO1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC55LCB5LnRyYW5zbGF0ZSwgeS5zY2FsZSwgeS5vcmlnaW5Qb2ludCk7XG59XG4vKipcbiAqIEFwcGx5IGEgdHJlZSBvZiBkZWx0YXMgdG8gYSBib3guIFdlIGRvIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBlZmZlY3Qgb2YgYWxsIHRoZSB0cmFuc2Zvcm1zXG4gKiBpbiBhIHRyZWUgdXBvbiBvdXIgYm94IGJlZm9yZSB0aGVuIGNhbGN1bGF0aW5nIGhvdyB0byBwcm9qZWN0IGl0IGludG8gb3VyIGRlc2lyZWQgdmlld3BvcnQtcmVsYXRpdmUgYm94XG4gKlxuICogVGhpcyBpcyB0aGUgZmluYWwgbmVzdGVkIGxvb3Agd2l0aGluIHVwZGF0ZUxheW91dERlbHRhIGZvciBmdXR1cmUgcmVmYWN0b3JpbmdcbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmVlRGVsdGFzKGJveCwgdHJlZVNjYWxlLCB0cmVlUGF0aCwgaXNTaGFyZWRUcmFuc2l0aW9uKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uID09PSB2b2lkIDApIHsgaXNTaGFyZWRUcmFuc2l0aW9uID0gZmFsc2U7IH1cbiAgICB2YXIgdHJlZUxlbmd0aCA9IHRyZWVQYXRoLmxlbmd0aDtcbiAgICBpZiAoIXRyZWVMZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBSZXNldCB0aGUgdHJlZVNjYWxlXG4gICAgdHJlZVNjYWxlLnggPSB0cmVlU2NhbGUueSA9IDE7XG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIGRlbHRhO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSB0cmVlUGF0aFtpXTtcbiAgICAgICAgZGVsdGEgPSBub2RlLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSBub2RlLmluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3R5bGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwbGF5KSA9PT0gXCJjb250ZW50c1wiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIG5vZGUub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiZcbiAgICAgICAgICAgIG5vZGUuc2Nyb2xsICYmXG4gICAgICAgICAgICBub2RlICE9PSBub2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJveChib3gsIHsgeDogLW5vZGUuc2Nyb2xsLngsIHk6IC1ub2RlLnNjcm9sbC55IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgLy8gSW5jb3BvcmF0ZSBlYWNoIGFuY2VzdG9yJ3Mgc2NhbGUgaW50byBhIGN1bG11bGF0aXZlIHRyZWVTY2FsZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIHRyZWVTY2FsZS54ICo9IGRlbHRhLnguc2NhbGU7XG4gICAgICAgICAgICB0cmVlU2NhbGUueSAqPSBkZWx0YS55LnNjYWxlO1xuICAgICAgICAgICAgLy8gQXBwbHkgZWFjaCBhbmNlc3RvcidzIGNhbGN1bGF0ZWQgZGVsdGEgaW50byB0aGlzIGNvbXBvbmVudCdzIHJlY29yZGVkIGxheW91dCBib3hcbiAgICAgICAgICAgIGFwcGx5Qm94RGVsdGEoYm94LCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJiBoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3goYm94LCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVBeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG4gICAgYXhpcy5taW4gPSBheGlzLm1pbiArIGRpc3RhbmNlO1xuICAgIGF4aXMubWF4ID0gYXhpcy5tYXggKyBkaXN0YW5jZTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYW4gYXhpcyBmcm9tIHRoZSBsYXRlc3QgcmVzb2x2ZWQgbW90aW9uIHZhbHVlcy5cbiAqIFRoaXMgZnVuY3Rpb24gYmFzaWNhbGx5IGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBhIGZsYXQgbW90aW9uIHZhbHVlIG1hcFxuICogYW5kIGFwcGx5QXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUF4aXMoYXhpcywgdHJhbnNmb3JtcywgX2EpIHtcbiAgICB2YXIgX2IgPSB0c2xpYi5fX3JlYWQoX2EsIDMpLCBrZXkgPSBfYlswXSwgc2NhbGVLZXkgPSBfYlsxXSwgb3JpZ2luS2V5ID0gX2JbMl07XG4gICAgdmFyIGF4aXNPcmlnaW4gPSB0cmFuc2Zvcm1zW29yaWdpbktleV0gIT09IHVuZGVmaW5lZCA/IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSA6IDAuNTtcbiAgICB2YXIgb3JpZ2luUG9pbnQgPSBwb3Btb3Rpb24ubWl4KGF4aXMubWluLCBheGlzLm1heCwgYXhpc09yaWdpbik7XG4gICAgLy8gQXBwbHkgdGhlIGF4aXMgZGVsdGEgdG8gdGhlIGZpbmFsIGF4aXNcbiAgICBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2Zvcm1zW2tleV0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCBvcmlnaW5Qb2ludCwgdHJhbnNmb3Jtcy5zY2FsZSk7XG59XG4vKipcbiAqIFRoZSBuYW1lcyBvZiB0aGUgbW90aW9uIHZhbHVlcyB3ZSB3YW50IHRvIGFwcGx5IGFzIHRyYW5zbGF0aW9uLCBzY2FsZSBhbmQgb3JpZ2luLlxuICovXG52YXIgeEtleXMkMSA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xudmFyIHlLZXlzJDEgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYSBib3ggZnJvbSB0aGUgbGF0ZXN0IHJlc29sdmVkIG1vdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICAgIHRyYW5zZm9ybUF4aXMoYm94LngsIHRyYW5zZm9ybSwgeEtleXMkMSk7XG4gICAgdHJhbnNmb3JtQXhpcyhib3gueSwgdHJhbnNmb3JtLCB5S2V5cyQxKTtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB0cmFuc2Zvcm1Qb2ludCkge1xuICAgIHJldHVybiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh0cmFuc2Zvcm1Cb3hQb2ludHMoaW5zdGFuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRyYW5zZm9ybVBvaW50KSk7XG59XG5mdW5jdGlvbiBtZWFzdXJlUGFnZUJveChlbGVtZW50LCByb290UHJvamVjdGlvbk5vZGUsIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICAgIHZhciB2aWV3cG9ydEJveCA9IG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIHZhciBzY3JvbGwgPSByb290UHJvamVjdGlvbk5vZGUuc2Nyb2xsO1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC54LCBzY3JvbGwueCk7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueSwgc2Nyb2xsLnkpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld3BvcnRCb3g7XG59XG5cbnZhciBlbGVtZW50RHJhZ0NvbnRyb2xzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICpcbiAqL1xuLy8gbGV0IGxhdGVzdFBvaW50ZXJFdmVudDogQW55UG9pbnRlckV2ZW50XG52YXIgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIGRyYWcgZ2VzdHVyZSBsb2NrLCBlbnN1cmluZyBvbmx5IG9uZSBjb21wb25lbnRcbiAgICAgICAgLy8gY2FuIFwiY2FwdHVyZVwiIHRoZSBkcmFnIG9mIG9uZSBvciBib3RoIGF4ZXMuXG4gICAgICAgIC8vIFRPRE86IExvb2sgaW50byBtb3ZpbmcgdGhpcyBpbnRvIHBhbnNlc3Npb24/XG4gICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcm1pdHRlZCBib3VuZGFyaWVzIG9mIHRyYXZlbCwgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlci1heGlzIHJlc29sdmVkIGVsYXN0aWMgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFzdGljID0gY3JlYXRlQm94KCk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgfVxuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9yaWdpbkV2ZW50LCBfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5zbmFwVG9DdXJzb3IsIHNuYXBUb0N1cnNvciA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9uJ3Qgc3RhcnQgZHJhZ2dpbmcgaWYgdGhpcyBjb21wb25lbnQgaXMgZXhpdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMudmlzdWFsRWxlbWVudC5pc1ByZXNlbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgYW55IGFuaW1hdGlvbnMgb24gYm90aCBheGlzIHZhbHVlcyBpbW1lZGlhdGVseS4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gdGhyb3cgYW5kIGNhdGNoXG4gICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgX3RoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgaWYgKHNuYXBUb0N1cnNvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnNuYXBUb0N1cnNvcihleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBcInBhZ2VcIikucG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25TdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIHRoZSBnbG9iYWwgZHJhZyBnZXN0dXJlIGxvY2sgLSBtYXliZSBtYWtlIHRoaXMgcGFydCBvZiBQYW5TZXNzaW9uXG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5nZXRQcm9wcygpLCBkcmFnID0gX2IuZHJhZywgZHJhZ1Byb3BhZ2F0aW9uID0gX2IuZHJhZ1Byb3BhZ2F0aW9uLCBvbkRyYWdTdGFydCA9IF9iLm9uRHJhZ1N0YXJ0O1xuICAgICAgICAgICAgaWYgKGRyYWcgJiYgIWRyYWdQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3Blbkdsb2JhbExvY2soKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcGVuR2xvYmFsTG9jayA9IGdldEdsb2JhbExvY2soZHJhZyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uICd0IGhhdmUgdGhlIGxvY2ssIGRvbid0IHN0YXJ0IGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29yZCBnZXN0dXJlIG9yaWdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuZ2V0KCkgfHwgMDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgTW90aW9uVmFsdWUgaXMgYSBwZXJjZW50YWdlIHZhbHVlIGNvbnZlcnQgdG8gcHhcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVWYWx1ZVR5cGVzLnBlcmNlbnQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVhc3VyZWRBeGlzID0gKF9iID0gKF9hID0gX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0dWFsW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBjYWxjTGVuZ3RoKG1lYXN1cmVkQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbGVuZ3RoXzEgKiAocGFyc2VGbG9hdChjdXJyZW50KSAvIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMub3JpZ2luUG9pbnRbYXhpc10gPSBjdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBGaXJlIG9uRHJhZ1N0YXJ0IGV2ZW50XG4gICAgICAgICAgICBvbkRyYWdTdGFydCA9PT0gbnVsbCB8fCBvbkRyYWdTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnU3RhcnQoZXZlbnQsIGluZm8pO1xuICAgICAgICAgICAgKF9hID0gX3RoaXMudmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShleHBvcnRzLkFuaW1hdGlvblR5cGUuRHJhZywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIC8vIGxhdGVzdFBvaW50ZXJFdmVudCA9IGV2ZW50XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5nZXRQcm9wcygpLCBkcmFnUHJvcGFnYXRpb24gPSBfYS5kcmFnUHJvcGFnYXRpb24sIGRyYWdEaXJlY3Rpb25Mb2NrID0gX2EuZHJhZ0RpcmVjdGlvbkxvY2ssIG9uRGlyZWN0aW9uTG9jayA9IF9hLm9uRGlyZWN0aW9uTG9jaywgb25EcmFnID0gX2Eub25EcmFnO1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IHN1Y2Nlc3NmdWxseSByZWNlaXZlIHRoZSBnZXN0dXJlIGxvY2ssIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmICFfdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaW5mby5vZmZzZXQ7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBkcmFnIGRpcmVjdGlvbiBpZiBkaXJlY3Rpb25Mb2NrIGlzIHRydWVcbiAgICAgICAgICAgIGlmIChkcmFnRGlyZWN0aW9uTG9jayAmJiBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudERpcmVjdGlvbiA9IGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBzdWNjZXNzZnVsbHkgc2V0IGEgZGlyZWN0aW9uLCBub3RpZnkgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudERpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdGlvbkxvY2sgPT09IG51bGwgfHwgb25EaXJlY3Rpb25Mb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRpcmVjdGlvbkxvY2soX3RoaXMuY3VycmVudERpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBlYWNoIHBvaW50IHdpdGggdGhlIGxhdGVzdCBwb3NpdGlvblxuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXhpcyhcInhcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUF4aXMoXCJ5XCIsIGluZm8ucG9pbnQsIG9mZnNldCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElkZWFsbHkgd2Ugd291bGQgbGVhdmUgdGhlIHJlbmRlcmVyIHRvIGZpcmUgbmF0dXJhbGx5IGF0IHRoZSBlbmQgb2ZcbiAgICAgICAgICAgICAqIHRoaXMgZnJhbWUgYnV0IGlmIHRoZSBlbGVtZW50IGlzIGFib3V0IHRvIGNoYW5nZSBsYXlvdXQgYXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICogb2YgYSByZS1yZW5kZXIgd2Ugd2FudCB0byBlbnN1cmUgdGhlIGJyb3dzZXIgY2FuIHJlYWQgdGhlIGxhdGVzdFxuICAgICAgICAgICAgICogYm91bmRpbmcgYm94IHRvIGVuc3VyZSB0aGUgcG9pbnRlciBhbmQgZWxlbWVudCBkb24ndCBmYWxsIG91dCBvZiBzeW5jLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy52aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBtdXN0IGZpcmUgYWZ0ZXIgdGhlIHN5bmNSZW5kZXIgY2FsbCBhcyBpdCBtaWdodCB0cmlnZ2VyIGEgc3RhdGVcbiAgICAgICAgICAgICAqIGNoYW5nZSB3aGljaCBpdHNlbGYgbWlnaHQgdHJpZ2dlciBhIGxheW91dCB1cGRhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uRHJhZyA9PT0gbnVsbCB8fCBvbkRyYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZyhldmVudCwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblNlc3Npb25FbmQgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdG9wKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYW5TZXNzaW9uID0gbmV3IFBhblNlc3Npb24ob3JpZ2luRXZlbnQsIHtcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0OiBvblNlc3Npb25TdGFydCxcbiAgICAgICAgICAgIG9uU3RhcnQ6IG9uU3RhcnQsXG4gICAgICAgICAgICBvbk1vdmU6IG9uTW92ZSxcbiAgICAgICAgICAgIG9uU2Vzc2lvbkVuZDogb25TZXNzaW9uRW5kLFxuICAgICAgICB9LCB7IHRyYW5zZm9ybVBhZ2VQb2ludDogdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpIH0pO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICB2YXIgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZztcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSBpbmZvLnZlbG9jaXR5O1xuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKHZlbG9jaXR5KTtcbiAgICAgICAgdmFyIG9uRHJhZ0VuZCA9IHRoaXMuZ2V0UHJvcHMoKS5vbkRyYWdFbmQ7XG4gICAgICAgIG9uRHJhZ0VuZCA9PT0gbnVsbCB8fCBvbkRyYWdFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZ0VuZChldmVudCwgaW5mbyk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucGFuU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCgpO1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBkcmFnUHJvcGFnYXRpb24gPSB0aGlzLmdldFByb3BzKCkuZHJhZ1Byb3BhZ2F0aW9uO1xuICAgICAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiB0aGlzLm9wZW5HbG9iYWxMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrKCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSB0aGlzLnZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRBY3RpdmUoZXhwb3J0cy5BbmltYXRpb25UeXBlLkRyYWcsIGZhbHNlKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnVwZGF0ZUF4aXMgPSBmdW5jdGlvbiAoYXhpcywgX3BvaW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGRyYWcgPSB0aGlzLmdldFByb3BzKCkuZHJhZztcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIHRoaXMgYXhpcywgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgICAgICBpZiAoIW9mZnNldCB8fCAhc2hvdWxkRHJhZyhheGlzLCBkcmFnLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArIG9mZnNldFtheGlzXTtcbiAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMgJiYgdGhpcy5jb25zdHJhaW50c1theGlzXSkge1xuICAgICAgICAgICAgbmV4dCA9IGFwcGx5Q29uc3RyYWludHMobmV4dCwgdGhpcy5jb25zdHJhaW50c1theGlzXSwgdGhpcy5lbGFzdGljW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgICBheGlzVmFsdWUuc2V0KG5leHQpO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUucmVzb2x2ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFByb3BzKCksIGRyYWdDb25zdHJhaW50cyA9IF9hLmRyYWdDb25zdHJhaW50cywgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYztcbiAgICAgICAgdmFyIGxheW91dCA9ICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiB8fCB7fSkubGF5b3V0O1xuICAgICAgICB2YXIgcHJldkNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgbGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dC5hY3R1YWwsIGRyYWdDb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGFzdGljID0gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIG91dHB1dHRpbmcgdG8gZXh0ZXJuYWwgTW90aW9uVmFsdWVzLCB3ZSB3YW50IHRvIHJlYmFzZSB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgICAgICogZnJvbSB2aWV3cG9ydC1yZWxhdGl2ZSB0byBjb21wb25lbnQtcmVsYXRpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJldkNvbnN0cmFpbnRzICE9PSB0aGlzLmNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICBsYXlvdXQgJiZcbiAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgICF0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cykge1xuICAgICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdID0gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dC5hY3R1YWxbYXhpc10sIF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUucmVzb2x2ZVJlZkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFByb3BzKCksIGNvbnN0cmFpbnRzID0gX2EuZHJhZ0NvbnN0cmFpbnRzLCBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSBfYS5vbk1lYXN1cmVEcmFnQ29uc3RyYWludHM7XG4gICAgICAgIGlmICghY29uc3RyYWludHMgfHwgIWlzUmVmT2JqZWN0KGNvbnN0cmFpbnRzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzRWxlbWVudCA9IGNvbnN0cmFpbnRzLmN1cnJlbnQ7XG4gICAgICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoY29uc3RyYWludHNFbGVtZW50ICE9PSBudWxsLCBcIklmIGBkcmFnQ29uc3RyYWludHNgIGlzIHNldCBhcyBhIFJlYWN0IHJlZiwgdGhhdCByZWYgbXVzdCBiZSBwYXNzZWQgdG8gYW5vdGhlciBjb21wb25lbnQncyBgcmVmYCBwcm9wLlwiKTtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBpZiAoIXByb2plY3Rpb24gfHwgIXByb2plY3Rpb24ubGF5b3V0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY29uc3RyYWludHNCb3ggPSBtZWFzdXJlUGFnZUJveChjb25zdHJhaW50c0VsZW1lbnQsIHByb2plY3Rpb24ucm9vdCwgdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtcbiAgICAgICAgdmFyIG1lYXN1cmVkQ29uc3RyYWludHMgPSBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhwcm9qZWN0aW9uLmxheW91dC5hY3R1YWwsIGNvbnN0cmFpbnRzQm94KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZXJlJ3MgYW4gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIGxpc3RlbmVyIHdlIGNhbGwgaXQgYW5kXG4gICAgICAgICAqIGlmIGRpZmZlcmVudCBjb25zdHJhaW50cyBhcmUgcmV0dXJuZWQsIHNldCBjb25zdHJhaW50cyB0byB0aGF0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAob25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICB2YXIgdXNlckNvbnN0cmFpbnRzID0gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KG1lYXN1cmVkQ29uc3RyYWludHMpKTtcbiAgICAgICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gISF1c2VyQ29uc3RyYWludHM7XG4gICAgICAgICAgICBpZiAodXNlckNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHVzZXJDb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lYXN1cmVkQ29uc3RyYWludHM7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYS5kcmFnLCBkcmFnTW9tZW50dW0gPSBfYS5kcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljID0gX2EuZHJhZ0VsYXN0aWMsIGRyYWdUcmFuc2l0aW9uID0gX2EuZHJhZ1RyYW5zaXRpb24sIGRyYWdTbmFwVG9PcmlnaW4gPSBfYS5kcmFnU25hcFRvT3JpZ2luLCBvbkRyYWdUcmFuc2l0aW9uRW5kID0gX2Eub25EcmFnVHJhbnNpdGlvbkVuZDtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyB8fCB7fTtcbiAgICAgICAgdmFyIG1vbWVudHVtQW5pbWF0aW9ucyA9IGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgX3RoaXMuY3VycmVudERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IChfYSA9IGNvbnN0cmFpbnRzID09PSBudWxsIHx8IGNvbnN0cmFpbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25zdHJhaW50c1theGlzXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgICBpZiAoZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uID0geyBtaW46IDAsIG1heDogMCB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyZGFtcCB0aGUgYm91bmRhcnkgc3ByaW5nIGlmIGBkcmFnRWxhc3RpY2AgaXMgZGlzYWJsZWQuIFRoZXJlJ3Mgc3RpbGwgYSBmcmFtZVxuICAgICAgICAgICAgICogb2Ygc3ByaW5nIGFuaW1hdGlvbnMgc28gd2Ugc2hvdWxkIGxvb2sgaW50byBhZGRpbmcgYSBkaXNhYmxlIHNwcmluZyBvcHRpb24gdG8gYGluZXJ0aWFgLlxuICAgICAgICAgICAgICogV2UgY291bGQgZG8gc29tZXRoaW5nIGhlcmUgd2hlcmUgd2UgYWZmZWN0IHRoZSBgYm91bmNlU3RpZmZuZXNzYCBhbmQgYGJvdW5jZURhbXBpbmdgXG4gICAgICAgICAgICAgKiB1c2luZyB0aGUgdmFsdWUgb2YgYGRyYWdFbGFzdGljYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGJvdW5jZVN0aWZmbmVzcyA9IGRyYWdFbGFzdGljID8gMjAwIDogMTAwMDAwMDtcbiAgICAgICAgICAgIHZhciBib3VuY2VEYW1waW5nID0gZHJhZ0VsYXN0aWMgPyA0MCA6IDEwMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGluZXJ0aWEgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IHR5cGU6IFwiaW5lcnRpYVwiLCB2ZWxvY2l0eTogZHJhZ01vbWVudHVtID8gdmVsb2NpdHlbYXhpc10gOiAwLCBib3VuY2VTdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcywgYm91bmNlRGFtcGluZzogYm91bmNlRGFtcGluZywgdGltZUNvbnN0YW50OiA3NTAsIHJlc3REZWx0YTogMSwgcmVzdFNwZWVkOiAxMCB9LCBkcmFnVHJhbnNpdGlvbiksIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGFuaW1hdGluZyBvbiBhbiBleHRlcm5hbGx5LXByb3ZpZGVkIGBNb3Rpb25WYWx1ZWAgd2UgY2FuIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCdzIGFuaW1hdGlvbiBjb250cm9scyB3aGljaCB3aWxsIGhhbmRsZSBpbnRlcmFjdGlvbnMgd2l0aCB3aGlsZUhvdmVyIChldGMpLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgaGF2ZSB0byBhbmltYXRlIHRoZSBgTW90aW9uVmFsdWVgIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCBpbmVydGlhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJ1biBhbGwgYW5pbWF0aW9ucyBhbmQgdGhlbiByZXNvbHZlIHRoZSBuZXcgZHJhZyBjb25zdHJhaW50cy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG1vbWVudHVtQW5pbWF0aW9ucykudGhlbihvbkRyYWdUcmFuc2l0aW9uRW5kKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGF4aXMsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICByZXR1cm4gc3RhcnRBbmltYXRpb24oYXhpcywgYXhpc1ZhbHVlLCAwLCB0cmFuc2l0aW9uKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7IHJldHVybiBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuc3RvcCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYWcgd29ya3MgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoaWNoIHByb3BzIGFyZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIC0gSWYgX2RyYWdYIGFuZCBfZHJhZ1kgYXJlIHByb3ZpZGVkLCB3ZSBvdXRwdXQgdGhlIGdlc3R1cmUgZGVsdGEgZGlyZWN0bHkgdG8gdGhvc2UgbW90aW9uIHZhbHVlcy5cbiAgICAgKiAtIE90aGVyd2lzZSwgd2UgYXBwbHkgdGhlIGRlbHRhIHRvIHRoZSB4L3kgbW90aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5nZXRBeGlzTW90aW9uVmFsdWUgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgZHJhZ0tleSA9IFwiX2RyYWdcIiArIGF4aXMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIGV4dGVybmFsTW90aW9uVmFsdWUgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKVtkcmFnS2V5XTtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsTW90aW9uVmFsdWVcbiAgICAgICAgICAgID8gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgOiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoYXhpcywgKF9iID0gKF9hID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCkuaW5pdGlhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2F4aXNdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnNuYXBUb0N1cnNvciA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGRyYWcgPSBfdGhpcy5nZXRQcm9wcygpLmRyYWc7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgdGhpcyBheGlzLCBkbyBhbiBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgX3RoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHByb2plY3Rpb24gPSBfdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgICAgICB2YXIgYXhpc1ZhbHVlID0gX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBwcm9qZWN0aW9uLmxheW91dC5hY3R1YWxbYXhpc10sIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgICAgICAgICAgICAgIGF4aXNWYWx1ZS5zZXQocG9pbnRbYXhpc10gLSBwb3Btb3Rpb24ubWl4KG1pbiwgbWF4LCAwLjUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSB2aWV3cG9ydCByZXNpemVzIHdlIHdhbnQgdG8gY2hlY2sgaWYgdGhlIG1lYXN1cmVkIGNvbnN0cmFpbnRzXG4gICAgICogaGF2ZSBjaGFuZ2VkIGFuZCwgaWYgc28sIHJlcG9zaXRpb24gdGhlIGVsZW1lbnQgd2l0aGluIHRob3NlIG5ldyBjb25zdHJhaW50c1xuICAgICAqIHJlbGF0aXZlIHRvIHdoZXJlIGl0IHdhcyBiZWZvcmUgdGhlIHJlc2l6ZS5cbiAgICAgKi9cbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5nZXRQcm9wcygpLCBkcmFnID0gX2IuZHJhZywgZHJhZ0NvbnN0cmFpbnRzID0gX2IuZHJhZ0NvbnN0cmFpbnRzO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICBpZiAoIWlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykgfHwgIXByb2plY3Rpb24gfHwgIXRoaXMuY29uc3RyYWludHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIGN1cnJlbnQgYW5pbWF0aW9ucyBhcyB0aGVyZSBjYW4gYmUgdmlzdWFsIGdsaXRjaGluZyBpZiB3ZSB0cnkgdG8gZG9cbiAgICAgICAgICogdGhpcyBtaWQtYW5pbWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlY29yZCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGRyYWdnZWQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGVcbiAgICAgICAgICogY29uc3RyYWludHMgYm94IGFuZCBzYXZlIGFzIGEgcHJvZ3Jlc3MgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYm94UHJvZ3Jlc3MgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICBpZiAoYXhpc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhdGVzdCA9IGF4aXNWYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBib3hQcm9ncmVzc1theGlzXSA9IGNhbGNPcmlnaW4oeyBtaW46IGxhdGVzdCwgbWF4OiBsYXRlc3QgfSwgX3RoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgbGF5b3V0IG9mIHRoaXMgZWxlbWVudCBhbmQgcmVzb2x2ZSB0aGUgbGF0ZXN0IGRyYWcgY29uc3RyYWludHNcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgIChfYSA9IHByb2plY3Rpb24ucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGVhY2ggYXhpcywgY2FsY3VsYXRlIHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBsYXlvdXQgYXhpc1xuICAgICAgICAgKiB3aXRoaW4gdGhlIG5ldyBjb25zdHJhaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGUgYSBuZXcgdHJhbnNmb3JtIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBib3ggcHJvZ3Jlc3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heDtcbiAgICAgICAgICAgIGF4aXNWYWx1ZS5zZXQocG9wbW90aW9uLm1peChtaW4sIG1heCwgYm94UHJvZ3Jlc3NbYXhpc10pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5hZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodGhpcy52aXN1YWxFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaCBhIHBvaW50ZXJkb3duIGV2ZW50IGxpc3RlbmVyIG9uIHRoaXMgRE9NIGVsZW1lbnQgdG8gaW5pdGlhdGUgZHJhZyB0cmFja2luZy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdG9wUG9pbnRlckxpc3RlbmVyID0gYWRkUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5nZXRQcm9wcygpLCBkcmFnID0gX2EuZHJhZywgX2IgPSBfYS5kcmFnTGlzdGVuZXIsIGRyYWdMaXN0ZW5lciA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgICAgICAgICBkcmFnICYmIGRyYWdMaXN0ZW5lciAmJiBfdGhpcy5zdGFydChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVhc3VyZURyYWdDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcmFnQ29uc3RyYWludHMgPSBfdGhpcy5nZXRQcm9wcygpLmRyYWdDb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmIChpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29uc3RyYWludHMgPSBfdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgdmFyIHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtZWFzdXJlXCIsIG1lYXN1cmVEcmFnQ29uc3RyYWludHMpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiAhcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgIChfYSA9IHByb2plY3Rpb24ucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIHRvIHNjYWxlIHRoZSBkcmFnZ2FibGUgdGFyZ2V0IHdpdGhpbiBpdHMgZGVmaW5lZFxuICAgICAgICAgKiBjb25zdHJhaW50cyBhcyB0aGUgd2luZG93IHJlc2l6ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RvcFJlc2l6ZUxpc3RlbmVyID0gYWRkRG9tRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGVsZW1lbnQncyBsYXlvdXQgY2hhbmdlcywgY2FsY3VsYXRlIHRoZSBkZWx0YSBhbmQgYXBwbHkgdGhhdCB0b1xuICAgICAgICAgKiB0aGUgZHJhZyBnZXN0dXJlJ3Mgb3JpZ2luIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsIChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IF9hLmRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkID0gX2EuaGFzTGF5b3V0Q2hhbmdlZDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nICYmIGhhc0xheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW90aW9uVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9yaWdpblBvaW50W2F4aXNdICs9IGRlbHRhW2F4aXNdLnRyYW5zbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KG1vdGlvblZhbHVlLmdldCgpICsgZGVsdGFbYXhpc10udHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy52aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RvcFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wUG9pbnRlckxpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5nZXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgIHZhciBfYSA9IHByb3BzLmRyYWcsIGRyYWcgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBwcm9wcy5kcmFnRGlyZWN0aW9uTG9jaywgZHJhZ0RpcmVjdGlvbkxvY2sgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBwcm9wcy5kcmFnUHJvcGFnYXRpb24sIGRyYWdQcm9wYWdhdGlvbiA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IHByb3BzLmRyYWdDb25zdHJhaW50cywgZHJhZ0NvbnN0cmFpbnRzID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIF9lID0gcHJvcHMuZHJhZ0VsYXN0aWMsIGRyYWdFbGFzdGljID0gX2UgPT09IHZvaWQgMCA/IGRlZmF1bHRFbGFzdGljIDogX2UsIF9mID0gcHJvcHMuZHJhZ01vbWVudHVtLCBkcmFnTW9tZW50dW0gPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mO1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHByb3BzKSwgeyBkcmFnOiBkcmFnLCBkcmFnRGlyZWN0aW9uTG9jazogZHJhZ0RpcmVjdGlvbkxvY2ssIGRyYWdQcm9wYWdhdGlvbjogZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnQ29uc3RyYWludHM6IGRyYWdDb25zdHJhaW50cywgZHJhZ0VsYXN0aWM6IGRyYWdFbGFzdGljLCBkcmFnTW9tZW50dW06IGRyYWdNb21lbnR1bSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzO1xufSgpKTtcbmZ1bmN0aW9uIHNob3VsZERyYWcoZGlyZWN0aW9uLCBkcmFnLCBjdXJyZW50RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuICgoZHJhZyA9PT0gdHJ1ZSB8fCBkcmFnID09PSBkaXJlY3Rpb24pICYmXG4gICAgICAgIChjdXJyZW50RGlyZWN0aW9uID09PSBudWxsIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09IGRpcmVjdGlvbikpO1xufVxuLyoqXG4gKiBCYXNlZCBvbiBhbiB4L3kgb2Zmc2V0IGRldGVybWluZSB0aGUgY3VycmVudCBkcmFnIGRpcmVjdGlvbi4gSWYgYm90aCBheGlzJyBvZmZzZXRzIGFyZSBsb3dlclxuICogdGhhbiB0aGUgcHJvdmlkZWQgdGhyZXNob2xkLCByZXR1cm4gYG51bGxgLlxuICpcbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgeC95IG9mZnNldCBmcm9tIG9yaWdpbi5cbiAqIEBwYXJhbSBsb2NrVGhyZXNob2xkIC0gKE9wdGlvbmFsKSAtIHRoZSBtaW5pbXVtIGFic29sdXRlIG9mZnNldCBiZWZvcmUgd2UgY2FuIGRldGVybWluZSBhIGRyYWcgZGlyZWN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCwgbG9ja1RocmVzaG9sZCkge1xuICAgIGlmIChsb2NrVGhyZXNob2xkID09PSB2b2lkIDApIHsgbG9ja1RocmVzaG9sZCA9IDEwOyB9XG4gICAgdmFyIGRpcmVjdGlvbiA9IG51bGw7XG4gICAgaWYgKE1hdGguYWJzKG9mZnNldC55KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ5XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldC54KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ4XCI7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbi8qKlxuICogQSBob29rIHRoYXQgYWxsb3dzIGFuIGVsZW1lbnQgdG8gYmUgZHJhZ2dlZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZyhwcm9wcykge1xuICAgIHZhciBncm91cERyYWdDb250cm9scyA9IHByb3BzLmRyYWdDb250cm9scywgdmlzdWFsRWxlbWVudCA9IHByb3BzLnZpc3VhbEVsZW1lbnQ7XG4gICAgdmFyIGRyYWdDb250cm9scyA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzKHZpc3VhbEVsZW1lbnQpOyB9KTtcbiAgICAvLyBJZiB3ZSd2ZSBiZWVuIHByb3ZpZGVkIGEgRHJhZ0NvbnRyb2xzIGZvciBtYW51YWwgY29udHJvbCBvdmVyIHRoZSBkcmFnIGdlc3R1cmUsXG4gICAgLy8gc3Vic2NyaWJlIHRoaXMgY29tcG9uZW50IHRvIGl0IG9uIG1vdW50LlxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBncm91cERyYWdDb250cm9scyAmJiBncm91cERyYWdDb250cm9scy5zdWJzY3JpYmUoZHJhZ0NvbnRyb2xzKTsgfSwgW2RyYWdDb250cm9scywgZ3JvdXBEcmFnQ29udHJvbHNdKTtcbiAgICAvLyBBcHBseSB0aGUgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBlbGVtZW50XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRyYWdDb250cm9scy5hZGRMaXN0ZW5lcnMoKTsgfSwgW2RyYWdDb250cm9sc10pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gaGFuZGxlcnMgLVxuICogQHBhcmFtIHJlZiAtXG4gKlxuICogQHByaXZhdGVSZW1hcmtzXG4gKiBDdXJyZW50bHkgdGhpcyBzZXRzIG5ldyBwYW4gZ2VzdHVyZSBmdW5jdGlvbnMgZXZlcnkgcmVuZGVyLiBUaGUgbWVtbyByb3V0ZSBoYXMgYmVlbiBleHBsb3JlZFxuICogaW4gdGhlIHBhc3QgYnV0IHVsdGltYXRlbHkgd2UncmUgc3RpbGwgY3JlYXRpbmcgbmV3IGZ1bmN0aW9ucyBldmVyeSByZW5kZXIuIEFuIG9wdGltaXNhdGlvblxuICogdG8gZXhwbG9yZSBpcyBjcmVhdGluZyB0aGUgcGFuIGdlc3R1cmVzIGFuZCBsb2FkaW5nIHRoZW0gaW50byBhIGByZWZgLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VQYW5HZXN0dXJlKF9hKSB7XG4gICAgdmFyIG9uUGFuID0gX2Eub25QYW4sIG9uUGFuU3RhcnQgPSBfYS5vblBhblN0YXJ0LCBvblBhbkVuZCA9IF9hLm9uUGFuRW5kLCBvblBhblNlc3Npb25TdGFydCA9IF9hLm9uUGFuU2Vzc2lvblN0YXJ0LCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudDtcbiAgICB2YXIgaGFzUGFuRXZlbnRzID0gb25QYW4gfHwgb25QYW5TdGFydCB8fCBvblBhbkVuZCB8fCBvblBhblNlc3Npb25TdGFydDtcbiAgICB2YXIgcGFuU2Vzc2lvbiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgdHJhbnNmb3JtUGFnZVBvaW50ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgdmFyIGhhbmRsZXJzID0ge1xuICAgICAgICBvblNlc3Npb25TdGFydDogb25QYW5TZXNzaW9uU3RhcnQsXG4gICAgICAgIG9uU3RhcnQ6IG9uUGFuU3RhcnQsXG4gICAgICAgIG9uTW92ZTogb25QYW4sXG4gICAgICAgIG9uRW5kOiBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIHBhblNlc3Npb24uY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBvblBhbkVuZCAmJiBvblBhbkVuZChldmVudCwgaW5mbyk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocGFuU2Vzc2lvbi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYW5TZXNzaW9uLmN1cnJlbnQudXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICBwYW5TZXNzaW9uLmN1cnJlbnQgPSBuZXcgUGFuU2Vzc2lvbihldmVudCwgaGFuZGxlcnMsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogdHJhbnNmb3JtUGFnZVBvaW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgaGFzUGFuRXZlbnRzICYmIG9uUG9pbnRlckRvd24pO1xuICAgIHVzZVVubW91bnRFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFuU2Vzc2lvbi5jdXJyZW50ICYmIHBhblNlc3Npb24uY3VycmVudC5lbmQoKTsgfSk7XG59XG5cbnZhciBkcmFnID0ge1xuICAgIHBhbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlUGFuR2VzdHVyZSksXG4gICAgZHJhZzogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlRHJhZyksXG59O1xuXG52YXIgbmFtZXMgPSBbXG4gICAgXCJMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJMYXlvdXRVcGRhdGVcIixcbiAgICBcIlZpZXdwb3J0Qm94VXBkYXRlXCIsXG4gICAgXCJVcGRhdGVcIixcbiAgICBcIlJlbmRlclwiLFxuICAgIFwiQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJBbmltYXRpb25TdGFydFwiLFxuICAgIFwiTGF5b3V0QW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIlNldEF4aXNUYXJnZXRcIixcbiAgICBcIlVubW91bnRcIixcbl07XG5mdW5jdGlvbiBjcmVhdGVMaWZlY3ljbGVzKCkge1xuICAgIHZhciBtYW5hZ2VycyA9IG5hbWVzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpOyB9KTtcbiAgICB2YXIgcHJvcFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB2YXIgbGlmZWN5Y2xlcyA9IHtcbiAgICAgICAgY2xlYXJBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hbmFnZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZXIpIHsgcmV0dXJuIG1hbmFnZXIuY2xlYXIoKTsgfSk7IH0sXG4gICAgICAgIHVwZGF0ZVByb3BMaXN0ZW5lcnM6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgb24gPSBcIm9uXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTGlzdGVuZXIgPSBwcm9wc1tvbl07XG4gICAgICAgICAgICAgICAgLy8gVW5zdWJzY3JpYmUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgKF9hID0gcHJvcFN1YnNjcmlwdGlvbnNbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIGlmIChwcm9wTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFN1YnNjcmlwdGlvbnNbbmFtZV0gPSBsaWZlY3ljbGVzW29uXShwcm9wTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgbWFuYWdlcnMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlciwgaSkge1xuICAgICAgICBsaWZlY3ljbGVzW1wib25cIiArIG5hbWVzW2ldXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBtYW5hZ2VyLmFkZChoYW5kbGVyKTsgfTtcbiAgICAgICAgbGlmZWN5Y2xlc1tcIm5vdGlmeVwiICsgbmFtZXNbaV1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXIubm90aWZ5LmFwcGx5KG1hbmFnZXIsIHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGlmZWN5Y2xlcztcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKGVsZW1lbnQsIG5leHQsIHByZXYpIHtcbiAgICB2YXIgX2E7XG4gICAgZm9yICh2YXIga2V5IGluIG5leHQpIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHRba2V5XTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHByZXZba2V5XTtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbW90aW9uIHZhbHVlIGZvdW5kIGluIHByb3BzIG9yIHN0eWxlLCB3ZSB3YW50IHRvIGFkZCBpdFxuICAgICAgICAgICAgICogdG8gb3VyIHZpc3VhbCBlbGVtZW50J3MgbW90aW9uIHZhbHVlIG1hcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG5leHRWYWx1ZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIHRoZSB2ZXJzaW9uIG9mIHRoZSBpbmNvbWluZyBtb3Rpb24gdmFsdWUgd2l0aCB0aGlzIHZlcnNpb25cbiAgICAgICAgICAgICAqIGFuZCB3YXJuIGFnYWluc3QgbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShuZXh0VmFsdWUudmVyc2lvbiA9PT0gXCI2LjUuMVwiLCBcIkF0dGVtcHRpbmcgdG8gbWl4IEZyYW1lciBNb3Rpb24gdmVyc2lvbnMgXCIuY29uY2F0KG5leHRWYWx1ZS52ZXJzaW9uLCBcIiB3aXRoIDYuNS4xIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTW90aW9uVmFsdWUocHJldlZhbHVlKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBzd2FwcGluZyB0byBhIG5ldyBtb3Rpb24gdmFsdWUsIGNyZWF0ZSBhIG5ldyBtb3Rpb24gdmFsdWVcbiAgICAgICAgICAgICAqIGZyb20gdGhhdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobmV4dFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIGZsYXQgdmFsdWUgdGhhdCBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBtb3Rpb24gdmFsdWVcbiAgICAgICAgICAgICAqIG9yIGNyZWF0ZSBvbmUgaWYgaXQgZG9lc24ndCBleGlzdC4gV2Ugb25seSB3YW50IHRvIGRvIHRoaXMgaWYgd2UncmVcbiAgICAgICAgICAgICAqIG5vdCBoYW5kbGluZyB0aGUgdmFsdWUgd2l0aCBvdXIgYW5pbWF0aW9uIHN0YXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogT25seSB1cGRhdGUgdmFsdWVzIHRoYXQgYXJlbid0IGJlaW5nIGFuaW1hdGVkIG9yIGV2ZW4gbG9va2VkIGF0XG4gICAgICAgICAgICAgICAgIWV4aXN0aW5nVmFsdWUuaGFzQW5pbWF0ZWQgJiYgZXhpc3RpbmdWYWx1ZS5zZXQobmV4dFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZSgoX2EgPSBlbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5leHRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZW1vdmVkIHZhbHVlc1xuICAgIGZvciAodmFyIGtleSBpbiBwcmV2KSB7XG4gICAgICAgIGlmIChuZXh0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG59XG5cbnZhciB2aXN1YWxFbGVtZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EudHJlZVR5cGUsIHRyZWVUeXBlID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgYnVpbGQgPSBfYS5idWlsZCwgZ2V0QmFzZVRhcmdldCA9IF9hLmdldEJhc2VUYXJnZXQsIG1ha2VUYXJnZXRBbmltYXRhYmxlID0gX2EubWFrZVRhcmdldEFuaW1hdGFibGUsIG1lYXN1cmVWaWV3cG9ydEJveCA9IF9hLm1lYXN1cmVWaWV3cG9ydEJveCwgcmVuZGVySW5zdGFuY2UgPSBfYS5yZW5kZXIsIHJlYWRWYWx1ZUZyb21JbnN0YW5jZSA9IF9hLnJlYWRWYWx1ZUZyb21JbnN0YW5jZSwgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUgPSBfYS5yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSwgc29ydE5vZGVQb3NpdGlvbiA9IF9hLnNvcnROb2RlUG9zaXRpb24sIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBfYS5wYXJlbnQsIHByb3BzID0gX2EucHJvcHMsIHByZXNlbmNlSWQgPSBfYS5wcmVzZW5jZUlkLCBibG9ja0luaXRpYWxBbmltYXRpb24gPSBfYS5ibG9ja0luaXRpYWxBbmltYXRpb24sIHZpc3VhbFN0YXRlID0gX2EudmlzdWFsU3RhdGUsIHNob3VsZFJlZHVjZU1vdGlvbiA9IF9hLnNob3VsZFJlZHVjZU1vdGlvbjtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGF0ZXN0VmFsdWVzID0gdmlzdWFsU3RhdGUubGF0ZXN0VmFsdWVzLCByZW5kZXJTdGF0ZSA9IHZpc3VhbFN0YXRlLnJlbmRlclN0YXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSByZW5kZXItc3BlY2lmaWMgbm9kZSB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQgYnkgdGhlXG4gICAgICAgICAqIGV4cG9zZWQgUmVhY3QgcmVmLiBTbyBmb3IgZXhhbXBsZSwgdGhpcyB2aXN1YWwgZWxlbWVudCBjYW4gaG9zdCBhXG4gICAgICAgICAqIEhUTUxFbGVtZW50LCBwbGFpbiBvYmplY3QsIG9yIFRocmVlLmpzIG9iamVjdC4gVGhlIGZ1bmN0aW9ucyBwcm92aWRlZFxuICAgICAgICAgKiBpbiBWaXN1YWxFbGVtZW50Q29uZmlnIGFsbG93IHVzIHRvIGludGVyZmFjZSB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBzdWJzY3JpcHRpb25zIGZvciBhIHZpc3VhbCBlbGVtZW50J3MgbGlmZWN5Y2xlLCBmb3IgaW5zdGFuY2VcbiAgICAgICAgICogb25SZW5kZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsaWZlY3ljbGVzID0gY3JlYXRlTGlmZWN5Y2xlcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgYWxsIG1vdGlvbiB2YWx1ZXMgYXR0YWNoZWQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC4gTW90aW9uXG4gICAgICAgICAqIHZhbHVlcyBhcmUgc291cmNlIG9mIHRydXRoIGZvciBhbnkgZ2l2ZW4gYW5pbWF0ZWQgdmFsdWUuIEEgbW90aW9uXG4gICAgICAgICAqIHZhbHVlIG1pZ2h0IGJlIHByb3ZpZGVkIGV4dGVybmFsbHkgYnkgdGhlIGNvbXBvbmVudCB2aWEgcHJvcHMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgZXZlcnkgc3Vic2NyaXB0aW9uIHRoYXQgYmluZHMgdGhlIHByb3ZpZGVkIG9yIGdlbmVyYXRlZFxuICAgICAgICAgKiBtb3Rpb24gdmFsdWVzIG9uQ2hhbmdlIGxpc3RlbmVycyB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHZhbHVlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91c2x5LXByb3ZpZGVkIG1vdGlvbiB2YWx1ZXMgYXMgcmV0dXJuZWRcbiAgICAgICAgICogZnJvbSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMuIFdlIHVzZSB0aGUga2V5cyBpbiBoZXJlIHRvIGRldGVybWluZVxuICAgICAgICAgKiBpZiBhbnkgbW90aW9uIHZhbHVlcyBuZWVkIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB2YWx1ZXMgYXJlIHJlbW92ZWQgZnJvbSBhbGwgYW5pbWF0aW9uIHByb3BzIHdlIG5lZWQgdG8gc2VhcmNoXG4gICAgICAgICAqIGZvciBhIGZhbGxiYWNrIHZhbHVlIHRvIGFuaW1hdGUgdG8uIFRoZXNlIHZhbHVlcyBhcmUgdHJhY2tlZCBpbiBiYXNlVGFyZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGJhc2VUYXJnZXQgPSB0c2xpYi5fX2Fzc2lnbih7fSwgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIG1vdW50LCB0aGlzIHdpbGwgYmUgaHlkcmF0ZWQgd2l0aCBhIGNhbGxiYWNrIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICogdGhpcyB2aXN1YWwgZWxlbWVudCBmcm9tIGl0cyBwYXJlbnQgb24gdW5tb3VudC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZW1vdmVGcm9tVmFyaWFudFRyZWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgd2l0aCB0aGUgbGF0ZXN0IHN0eWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdFxuICAgICAgICAgKiByZW5kZXIgbGlmZWN5Y2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8ICFpc01vdW50ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckJ1aWxkKCk7XG4gICAgICAgICAgICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHByb3BzLnN0eWxlLCBlbGVtZW50LnByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJCdWlsZCgpIHtcbiAgICAgICAgICAgIGJ1aWxkKGVsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICBsaWZlY3ljbGVzLm5vdGlmeVVwZGF0ZShsYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlbW92ZU9uQ2hhbmdlID0gdmFsdWUub25DaGFuZ2UoZnVuY3Rpb24gKGxhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wcy5vblVwZGF0ZSAmJiBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS51cGRhdGUodXBkYXRlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZW1vdmVPblJlbmRlclJlcXVlc3QgPSB2YWx1ZS5vblJlbmRlclJlcXVlc3QoZWxlbWVudC5zY2hlZHVsZVJlbmRlcik7XG4gICAgICAgICAgICB2YWx1ZVN1YnNjcmlwdGlvbnMuc2V0KGtleSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQW55IG1vdGlvbiB2YWx1ZXMgdGhhdCBhcmUgcHJvdmlkZWQgdG8gdGhlIGVsZW1lbnQgd2hlbiBjcmVhdGVkXG4gICAgICAgICAqIGFyZW4ndCB5ZXQgYm91bmQgdG8gdGhlIGVsZW1lbnQsIGFzIHRoaXMgd291bGQgdGVjaG5pY2FsbHkgYmUgaW1wdXJlLlxuICAgICAgICAgKiBIb3dldmVyLCB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIG1vdGlvbiB2YWx1ZXMgYW5kIHNldCB0aGVtIHRvIHRoZVxuICAgICAgICAgKiBpbml0aWFsIHZhbHVlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IFRoaXMgaXMgaW1wdXJlIGFuZCB3ZSBzaG91bGQgbG9vayBhdCBjaGFuZ2luZyB0aGlzIHRvIHJ1biBvbiBtb3VudC5cbiAgICAgICAgICogRG9pbmcgc28gd2lsbCBicmVhayBzb21lIHRlc3RzIGJ1dCB0aGlzIGlzbid0IG5lY2Nlc3NhcmlseSBhIGJyZWFraW5nIGNoYW5nZSxcbiAgICAgICAgICogbW9yZSBhIHJlZmxlY3Rpb24gb2YgdGhlIHRlc3QuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaW5pdGlhbE1vdGlvblZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcyk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpbml0aWFsTW90aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbml0aWFsTW90aW9uVmFsdWVzW2tleV07XG4gICAgICAgICAgICBpZiAobGF0ZXN0VmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBpc01vdGlvblZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnNldChsYXRlc3RWYWx1ZXNba2V5XSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgd2hhdCByb2xlIHRoaXMgdmlzdWFsIGVsZW1lbnQgc2hvdWxkIHRha2UgaW4gdGhlIHZhcmlhbnQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcyk7XG4gICAgICAgIHZhciBpc1ZhcmlhbnROb2RlID0gY2hlY2tJZlZhcmlhbnROb2RlKHByb3BzKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IHRyZWVUeXBlOiB0cmVlVHlwZSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYSBtaXJyb3Igb2YgdGhlIGludGVybmFsIGluc3RhbmNlIHByb3AsIHdoaWNoIGtlZXBzXG4gICAgICAgICAgICAgKiBWaXN1YWxFbGVtZW50IHR5cGUtY29tcGF0aWJsZSB3aXRoIFJlYWN0J3MgUmVmT2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50OiBudWxsLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGRlcHRoIG9mIHRoaXMgdmlzdWFsIGVsZW1lbnQgd2l0aGluIHRoZSB2aXN1YWwgZWxlbWVudCB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZXB0aDogcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDAsIHBhcmVudDogcGFyZW50LCBjaGlsZHJlbjogbmV3IFNldCgpLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJlc2VuY2VJZDogcHJlc2VuY2VJZCwgc2hvdWxkUmVkdWNlTW90aW9uOiBzaG91bGRSZWR1Y2VNb3Rpb24sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGNvbXBvbmVudCBpcyBwYXJ0IG9mIHRoZSB2YXJpYW50IHRyZWUsIGl0IHNob3VsZCB0cmFja1xuICAgICAgICAgICAgICogYW55IGNoaWxkcmVuIHRoYXQgYXJlIGFsc28gcGFydCBvZiB0aGUgdHJlZS4gVGhpcyBpcyBlc3NlbnRpYWxseVxuICAgICAgICAgICAgICogYSBzaGFkb3cgdHJlZSB0byBzaW1wbGlmeSBsb2dpYyBhcm91bmQgaG93IHRvIHN0YWdnZXIgb3ZlciBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyaWFudENoaWxkcmVuOiBpc1ZhcmlhbnROb2RlID8gbmV3IFNldCgpIDogdW5kZWZpbmVkLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGlzIGluc3RhbmNlIGlzIHZpc2libGUuIFRoaXMgY2FuIGJlIGNoYW5nZWQgaW1wZXJhdGl2ZWx5XG4gICAgICAgICAgICAgKiBieSB0aGUgcHJvamVjdGlvbiB0cmVlLCBpcyBhbmFsb2dvdXMgdG8gQ1NTJ3MgdmlzaWJpbGl0eSBpbiB0aGF0XG4gICAgICAgICAgICAgKiBoaWRkZW4gZWxlbWVudHMgc2hvdWxkIHRha2UgdXAgbGF5b3V0LCBhbmQgbmVlZHMgZW5hY3RpbmcgYnkgdGhlIGNvbmZpZ3VyZWRcbiAgICAgICAgICAgICAqIHJlbmRlciBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNWaXNpYmxlOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3JtYWxseSwgaWYgYSBjb21wb25lbnQgaXMgY29udHJvbGxlZCBieSBhIHBhcmVudCdzIHZhcmlhbnRzLCBpdCBjYW5cbiAgICAgICAgICAgICAqIHJlbHkgb24gdGhhdCBhbmNlc3RvciB0byB0cmlnZ2VyIGFuaW1hdGlvbnMgZnVydGhlciBkb3duIHRoZSB0cmVlLlxuICAgICAgICAgICAgICogSG93ZXZlciwgaWYgYSBjb21wb25lbnQgaXMgY3JlYXRlZCBhZnRlciBpdHMgcGFyZW50IGlzIG1vdW50ZWQsIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAqIHdvbid0IHRyaWdnZXIgdGhhdCBtb3VudCBhbmltYXRpb24gc28gdGhlIGNoaWxkIG5lZWRzIHRvLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IFRoaXMgbWlnaHQgYmUgYmV0dGVyIHJlcGxhY2VkIHdpdGggYSBtZXRob2QgaXNQYXJlbnRNb3VudGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1hbnVhbGx5QW5pbWF0ZU9uTW91bnQ6IEJvb2xlYW4ocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmlzTW91bnRlZCgpKSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgY2FuIGJlIHNldCBieSBBbmltYXRlUHJlc2VuY2UgdG8gZm9yY2UgY29tcG9uZW50cyB0aGF0IG1vdW50XG4gICAgICAgICAgICAgKiBhdCB0aGUgc2FtZSB0aW1lIGFzIGl0IHRvIG1vdW50IGFzIGlmIHRoZXkgaGF2ZSBpbml0aWFsPXtmYWxzZX0gc2V0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBibG9ja0luaXRpYWxBbmltYXRpb246IGJsb2NrSW5pdGlhbEFuaW1hdGlvbiwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoaXMgY29tcG9uZW50IGhhcyBtb3VudGVkIHlldC4gVGhpcyBpcyBtb3N0bHkgdXNlZFxuICAgICAgICAgICAgICogYnkgdmFyaWFudCBjaGlsZHJlbiB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IG5lZWQgdG8gdHJpZ2dlciB0aGVpclxuICAgICAgICAgICAgICogb3duIGFuaW1hdGlvbnMgb24gbW91bnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQm9vbGVhbihpbnN0YW5jZSk7IH0sIG1vdW50OiBmdW5jdGlvbiAobmV3SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gZWxlbWVudC5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnByb2plY3Rpb24ubW91bnQobmV3SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYW50Tm9kZSAmJiBwYXJlbnQgJiYgIWlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVGcm9tVmFyaWFudFRyZWUgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYWRkVmFyaWFudENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXR1cm4gYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbi5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBlbGVtZW50LnByb2plY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm1vdW50KCk7XG4gICAgICAgICAgICAgICAgc3luYy5jYW5jZWxTeW5jLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHN5bmMuY2FuY2VsU3luYy5yZW5kZXIocmVuZGVyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZlKSB7IHJldHVybiByZW1vdmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRnJvbVZhcmlhbnRUcmVlID09PSBudWxsIHx8IHJlbW92ZUZyb21WYXJpYW50VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVtb3ZlRnJvbVZhcmlhbnRUcmVlKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVzLmNsZWFyQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGEgY2hpbGQgdmlzdWFsIGVsZW1lbnQgdG8gb3VyIHNldCBvZiBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkVmFyaWFudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3Nlc3RWYXJpYW50Tm9kZSA9IGVsZW1lbnQuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RWYXJpYW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmRlbGV0ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc29ydE5vZGVQb3NpdGlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlc2Ugbm9kZXMgYXJlbid0IGV2ZW4gb2YgdGhlIHNhbWUgdHlwZSB3ZSBjYW4ndCBjb21wYXJlIHRoZWlyIGRlcHRoLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghc29ydE5vZGVQb3NpdGlvbiB8fCB0cmVlVHlwZSAhPT0gb3RoZXIudHJlZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3J0Tm9kZVBvc2l0aW9uKGVsZW1lbnQuZ2V0SW5zdGFuY2UoKSwgb3RoZXIuZ2V0SW5zdGFuY2UoKSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY2xvc2VzdCB2YXJpYW50IG5vZGUgaW4gdGhlIHRyZWUgc3RhcnRpbmcgZnJvbVxuICAgICAgICAgICAgICogdGhpcyB2aXN1YWwgZWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0Q2xvc2VzdFZhcmlhbnROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFyaWFudE5vZGUgPyBlbGVtZW50IDogcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4cG9zZSB0aGUgbGF0ZXN0IGxheW91dElkIHByb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldExheW91dElkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wcy5sYXlvdXRJZDsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnN0YW5jZTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldC9zZXQgdGhlIGxhdGVzdCBzdGF0aWMgdmFsdWVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRTdGF0aWNWYWx1ZTogZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbGF0ZXN0VmFsdWVzW2tleV07IH0sIHNldFN0YXRpY1ZhbHVlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyByZXR1cm4gKGxhdGVzdFZhbHVlc1trZXldID0gdmFsdWUpOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IG1vdGlvbiB2YWx1ZSBzdGF0ZS4gQ3VycmVudGx5IG9ubHkgdXNlZCB0byB0YWtlXG4gICAgICAgICAgICAgKiBhIHNuYXBzaG90IG9mIHRoZSB2aXN1YWwgZWxlbWVudCAtIHBlcmhhcHMgdGhpcyBjYW4gcmV0dXJuIHRoZSB3aG9sZVxuICAgICAgICAgICAgICogdmlzdWFsIHN0YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldExhdGVzdFZhbHVlczogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGF0ZXN0VmFsdWVzOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSB2aXNpYmxpdHkgb2YgdGhlIHZpc3VhbCBlbGVtZW50LiBJZiBpdCdzIGNoYW5nZWQsIHNjaGVkdWxlXG4gICAgICAgICAgICAgKiBhIHJlbmRlciB0byByZWZsZWN0IHRoZXNlIGNoYW5nZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uICh2aXNpYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaXNWaXNpYmxlID09PSB2aXNpYmlsaXR5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pc1Zpc2libGUgPSB2aXNpYmlsaXR5O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYWtlIGEgdGFyZ2V0IGFuaW1hdGFibGUgYnkgUG9wbW90aW9uLiBGb3IgaW5zdGFuY2UsIGlmIHdlJ3JlXG4gICAgICAgICAgICAgKiB0cnlpbmcgdG8gYW5pbWF0ZSB3aWR0aCBmcm9tIDEwMHB4IHRvIDEwMHZ3IHdlIG5lZWQgdG8gbWVhc3VyZSAxMDB2d1xuICAgICAgICAgICAgICogaW4gcGl4ZWxzIHRvIGRldGVybWluZSB3aGF0IHdlIHJlYWxseSBuZWVkIHRvIGFuaW1hdGUgdG8uIFRoaXMgaXMgYWxzb1xuICAgICAgICAgICAgICogcGx1Z2dhYmxlIHRvIHN1cHBvcnQgRnJhbWVyJ3MgY3VzdG9tIHZhbHVlIHR5cGVzIGxpa2UgQ29sb3IsXG4gICAgICAgICAgICAgKiBhbmQgQ1NTIHZhcmlhYmxlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFrZVRhcmdldEFuaW1hdGFibGU6IGZ1bmN0aW9uICh0YXJnZXQsIGNhbk11dGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjYW5NdXRhdGUgPT09IHZvaWQgMCkgeyBjYW5NdXRhdGUgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VUYXJnZXRBbmltYXRhYmxlKGVsZW1lbnQsIHRhcmdldCwgcHJvcHMsIGNhbk11dGF0ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWVhc3VyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBib3ggd2l0aCBvciB3aXRob3V0IHRyYW5zZm9ybXMuXG4gICAgICAgICAgICAgKiBPbmx5IG1lYXN1cmVzIGF4aXMtYWxpZ25lZCBib3hlcywgcm90YXRlIGFuZCBza2V3IG11c3QgYmUgbWFudWFsbHlcbiAgICAgICAgICAgICAqIHJlbW92ZWQgd2l0aCBhIHJlLXJlbmRlciB0byB3b3JrLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtZWFzdXJlVmlld3BvcnRCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIE1vdGlvbiB2YWx1ZXMgPT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIG1vdGlvbiB2YWx1ZSBhbmQgYmluZCBpdCB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRWYWx1ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgdmFsdWUgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzVmFsdWUoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgYSBtb3Rpb24gdmFsdWUgYW5kIHVuYmluZCBhbnkgYWN0aXZlIHN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbW92ZVZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB2YWx1ZVN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoa2V5LCByZW5kZXJTdGF0ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgbW90aW9uIHZhbHVlIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYXNWYWx1ZTogZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdmFsdWVzLmhhcyhrZXkpOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGEgbW90aW9uIHZhbHVlIGZvciB0aGlzIGtleS4gSWYgY2FsbGVkIHdpdGggYSBkZWZhdWx0XG4gICAgICAgICAgICAgKiB2YWx1ZSwgd2UnbGwgY3JlYXRlIG9uZSBpZiBub25lIGV4aXN0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vdGlvblZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdGVyYXRlIG92ZXIgb3VyIG1vdGlvbiB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvckVhY2hWYWx1ZTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiB2YWx1ZXMuZm9yRWFjaChjYWxsYmFjayk7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSB0cnlpbmcgdG8gYW5pbWF0ZSB0byBhIHByZXZpb3VzbHkgdW5lbmNvdW50ZXJlZCB2YWx1ZSxcbiAgICAgICAgICAgICAqIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGl0IGluIG91ciBzdGF0ZSBhbmQgYXMgYSBsYXN0IHJlc29ydCByZWFkIGl0XG4gICAgICAgICAgICAgKiBkaXJlY3RseSBmcm9tIHRoZSBpbnN0YW5jZSAod2hpY2ggbWlnaHQgaGF2ZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZWFkVmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGxhdGVzdFZhbHVlc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZWFkVmFsdWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UsIGtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBiYXNlIHRhcmdldCB0byBsYXRlciBhbmltYXRlIGJhY2sgdG8uIFRoaXMgaXMgY3VycmVudGx5XG4gICAgICAgICAgICAgKiBvbmx5IGh5ZHJhdGVkIG9uIGNyZWF0aW9uIGFuZCB3aGVuIHdlIGZpcnN0IHJlYWQgYSB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0QmFzZVRhcmdldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBiYXNlVGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaW5kIHRoZSBiYXNlIHRhcmdldCBmb3IgYSB2YWx1ZSB0aGF0cyBiZWVuIHJlbW92ZWQgZnJvbSBhbGwgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiBwcm9wcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0QmFzZVRhcmdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRCYXNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRCYXNlVGFyZ2V0KHByb3BzLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgIWlzTW90aW9uVmFsdWUodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVGFyZ2V0W2tleV07XG4gICAgICAgICAgICB9IH0sIGxpZmVjeWNsZXMpLCB7IFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCdWlsZCB0aGUgcmVuZGVyZXIgc3RhdGUgYmFzZWQgb24gdGhlIGxhdGVzdCB2aXN1YWwgc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckJ1aWxkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclN0YXRlO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjaGVkdWxlIGEgcmVuZGVyIG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2NoZWR1bGVSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5yZW5kZXIocmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3luY2hyb25vdXNseSBmaXJlIHJlbmRlci4gSXQncyBwcmVmZXJlZCB0aGF0IHdlIGJhdGNoIHJlbmRlcnMgYnV0XG4gICAgICAgICAgICAgKiBpbiBtYW55IGNpcmN1bXN0YW5jZXMsIGxpa2UgbGF5b3V0IG1lYXN1cmVtZW50LCB3ZSBuZWVkIHRvIHJ1biB0aGlzXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5LiBIb3dldmVyIGluIHRob3NlIGluc3RhbmNlcyBvdGhlciBtZWFzdXJlcyBzaG91bGQgYmUgdGFrZW5cbiAgICAgICAgICAgICAqIHRvIGJhdGNoIHJlYWRzL3dyaXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3luY1JlbmRlcjogcmVuZGVyLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBwcm92aWRlZCBwcm9wcy4gRW5zdXJlIGFueSBuZXdseS1hZGRlZCBtb3Rpb24gdmFsdWVzIGFyZVxuICAgICAgICAgICAgICogYWRkZWQgdG8gb3VyIG1hcCwgb2xkIG9uZXMgcmVtb3ZlZCwgYW5kIGxpc3RlbmVycyB1cGRhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzLnRyYW5zZm9ybVRlbXBsYXRlIHx8IHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVzLnVwZGF0ZVByb3BMaXN0ZW5lcnMobmV3UHJvcHMpO1xuICAgICAgICAgICAgICAgIHByZXZNb3Rpb25WYWx1ZXMgPSB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSwgcHJldk1vdGlvblZhbHVlcyk7XG4gICAgICAgICAgICB9LCBnZXRQcm9wczogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHM7IH0sIFxuICAgICAgICAgICAgLy8gVmFyaWFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiB3aXRoIGEgZ2l2ZW4gbmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFyaWFudDogZnVuY3Rpb24gKG5hbWUpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcHJvcHMudmFyaWFudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGRlZmluZWQgZGVmYXVsdCB0cmFuc2l0aW9uIG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXREZWZhdWx0VHJhbnNpdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMudHJhbnNpdGlvbjsgfSwgZ2V0VHJhbnNmb3JtUGFnZVBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2VkIGJ5IGNoaWxkIHZhcmlhbnQgbm9kZXMgdG8gZ2V0IHRoZSBjbG9zZXN0IGFuY2VzdG9yIHZhcmlhbnQgcHJvcHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFZhcmlhbnRDb250ZXh0OiBmdW5jdGlvbiAoc3RhcnRBdFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEF0UGFyZW50ID09PSB2b2lkIDApIHsgc3RhcnRBdFBhcmVudCA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0QXRQYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0VmFyaWFudENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dF8xID0gKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRWYXJpYW50Q29udGV4dCgpKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dF8xLmluaXRpYWwgPSBwcm9wcy5pbml0aWFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0XzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYXJpYW50UHJvcHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdmFyaWFudFByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFtuYW1lXzFdID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG59O1xudmFyIHZhcmlhbnRQcm9wcyA9IHRzbGliLl9fc3ByZWFkQXJyYXkoW1wiaW5pdGlhbFwiXSwgdHNsaWIuX19yZWFkKHZhcmlhbnRQcmlvcml0eU9yZGVyKSwgZmFsc2UpO1xudmFyIG51bVZhcmlhbnRQcm9wcyA9IHZhcmlhbnRQcm9wcy5sZW5ndGg7XG5cbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoXCJ2YXIoLS1cIik7XG59XG4vKipcbiAqIFBhcnNlIEZyYW1lcidzIHNwZWNpYWwgQ1NTIHZhcmlhYmxlIGZvcm1hdCBpbnRvIGEgQ1NTIHRva2VuIGFuZCBhIGZhbGxiYWNrLlxuICpcbiAqIGBgYFxuICogYHZhcigtLWZvbywgI2ZmZilgID0+IFtgLS1mb29gLCAnI2ZmZiddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY3VycmVudFxuICovXG52YXIgY3NzVmFyaWFibGVSZWdleCA9IC92YXJcXCgoLS1bYS16QS1aMC05LV9dKyksPyA/KFthLXpBLVowLTkgKCklIy4sLV0rKT9cXCkvO1xuZnVuY3Rpb24gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KSB7XG4gICAgdmFyIG1hdGNoID0gY3NzVmFyaWFibGVSZWdleC5leGVjKGN1cnJlbnQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBbLF07XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKG1hdGNoLCAzKSwgdG9rZW4gPSBfYVsxXSwgZmFsbGJhY2sgPSBfYVsyXTtcbiAgICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59XG52YXIgbWF4RGVwdGggPSA0O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7IGRlcHRoID0gMTsgfVxuICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsIFwiTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGN1cnJlbnQsIFwiXFxcIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LlwiKSk7XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCksIDIpLCB0b2tlbiA9IF9hWzBdLCBmYWxsYmFjayA9IF9hWzFdO1xuICAgIC8vIE5vIENTUyB2YXJpYWJsZSBkZXRlY3RlZFxuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBBdHRlbXB0IHRvIHJlYWQgdGhpcyBDU1MgdmFyaWFibGUgb2ZmIHRoZSBlbGVtZW50XG4gICAgdmFyIHJlc29sdmVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSh0b2tlbik7XG4gICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ1NTVmFyaWFibGUoZmFsbGJhY2spKSB7XG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayBtaWdodCBpdHNlbGYgYmUgYSBDU1MgdmFyaWFibGUsIGluIHdoaWNoIGNhc2Ugd2UgYXR0ZW1wdCB0byByZXNvbHZlIGl0IHRvby5cbiAgICAgICAgcmV0dXJuIGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxufVxuLyoqXG4gKiBSZXNvbHZlIENTUyB2YXJpYWJsZXMgZnJvbVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIF9hLCB0cmFuc2l0aW9uRW5kKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB0YXJnZXQgPSB0c2xpYi5fX3Jlc3QoX2EsIFtdKTtcbiAgICB2YXIgZWxlbWVudCA9IHZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgICAgIHJldHVybiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XG4gICAgLy8gSWYgYHRyYW5zaXRpb25FbmRgIGlzbid0IGB1bmRlZmluZWRgLCBjbG9uZSBpdC4gV2UgY291bGQgY2xvbmUgYHRhcmdldGAgYW5kIGB0cmFuc2l0aW9uRW5kYFxuICAgIC8vIG9ubHkgaWYgdGhleSBjaGFuZ2UgYnV0IEkgdGhpbmsgdGhpcyByZWFkcyBjbGVhcmVyIGFuZCB0aGlzIGlzbid0IGEgcGVyZm9ybWFuY2UtY3JpdGljYWwgcGF0aC5cbiAgICBpZiAodHJhbnNpdGlvbkVuZCkge1xuICAgICAgICB0cmFuc2l0aW9uRW5kID0gdHNsaWIuX19hc3NpZ24oe30sIHRyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgICAvLyBHbyB0aHJvdWdoIGV4aXN0aW5nIGBNb3Rpb25WYWx1ZWBzIGFuZCBlbnN1cmUgYW55IGV4aXN0aW5nIENTUyB2YXJpYWJsZXMgYXJlIHJlc29sdmVkXG4gICAgdmlzdWFsRWxlbWVudC5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICghaXNDU1NWYXJpYWJsZShjdXJyZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgaWYgKHJlc29sdmVkKVxuICAgICAgICAgICAgdmFsdWUuc2V0KHJlc29sdmVkKTtcbiAgICB9KTtcbiAgICAvLyBDeWNsZSB0aHJvdWdoIGV2ZXJ5IHRhcmdldCBwcm9wZXJ0eSBhbmQgcmVzb2x2ZSBDU1MgdmFyaWFibGVzLiBDdXJyZW50bHlcbiAgICAvLyB3ZSBvbmx5IHJlYWQgc2luZ2xlLXZhciBwcm9wZXJ0aWVzIGxpa2UgYHZhcigtLWZvbylgLCBub3QgYGNhbGModmFyKC0tZm9vKSArIDIwcHgpYFxuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKCFpc0NTU1ZhcmlhYmxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gQ2xvbmUgdGFyZ2V0IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cbiAgICAgICAgdGFyZ2V0W2tleV0gPSByZXNvbHZlZDtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGFscmVhZHkgc2V0IHRoaXMga2V5IG9uIGB0cmFuc2l0aW9uRW5kYCwgc2V0IGl0IHRvIHRoZSB1bnJlc29sdmVkXG4gICAgICAgIC8vIENTUyB2YXJpYWJsZS4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIHRoZSBhbmltYXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHJlZmxlY3RcbiAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIENTUyB2YXJpYWJsZS5cbiAgICAgICAgaWYgKHRyYW5zaXRpb25FbmQpXG4gICAgICAgICAgICAoX2IgPSB0cmFuc2l0aW9uRW5kW2tleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICh0cmFuc2l0aW9uRW5kW2tleV0gPSBjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbn1cblxudmFyIHBvc2l0aW9uYWxLZXlzID0gbmV3IFNldChbXG4gICAgXCJ3aWR0aFwiLFxuICAgIFwiaGVpZ2h0XCIsXG4gICAgXCJ0b3BcIixcbiAgICBcImxlZnRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcInhcIixcbiAgICBcInlcIixcbl0pO1xudmFyIGlzUG9zaXRpb25hbEtleSA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHBvc2l0aW9uYWxLZXlzLmhhcyhrZXkpOyB9O1xudmFyIGhhc1Bvc2l0aW9uYWxLZXkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuc29tZShpc1Bvc2l0aW9uYWxLZXkpO1xufTtcbnZhciBzZXRBbmRSZXNldFZlbG9jaXR5ID0gZnVuY3Rpb24gKHZhbHVlLCB0bykge1xuICAgIC8vIExvb2tzIG9kZCBidXQgc2V0dGluZyBpdCB0d2ljZSBkb2Vzbid0IHJlbmRlciwgaXQnbGwganVzdFxuICAgIC8vIHNldCBib3RoIHByZXYgYW5kIGN1cnJlbnQgdG8gdGhlIGxhdGVzdCB2YWx1ZVxuICAgIHZhbHVlLnNldCh0bywgZmFsc2UpO1xuICAgIHZhbHVlLnNldCh0byk7XG59O1xudmFyIGlzTnVtT3JQeFR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ID09PSBzdHlsZVZhbHVlVHlwZXMubnVtYmVyIHx8IHYgPT09IHN0eWxlVmFsdWVUeXBlcy5weDtcbn07XG52YXIgQm91bmRpbmdCb3hEaW1lbnNpb247XG4oZnVuY3Rpb24gKEJvdW5kaW5nQm94RGltZW5zaW9uKSB7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJ3aWR0aFwiXSA9IFwid2lkdGhcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcImhlaWdodFwiXSA9IFwiaGVpZ2h0XCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJyaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcInRvcFwiXSA9IFwidG9wXCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJib3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoQm91bmRpbmdCb3hEaW1lbnNpb24gfHwgKEJvdW5kaW5nQm94RGltZW5zaW9uID0ge30pKTtcbnZhciBnZXRQb3NGcm9tTWF0cml4ID0gZnVuY3Rpb24gKG1hdHJpeCwgcG9zKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG59O1xudmFyIGdldFRyYW5zbGF0ZUZyb21NYXRyaXggPSBmdW5jdGlvbiAocG9zMiwgcG9zMykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYS50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gPT09IFwibm9uZVwiIHx8ICF0cmFuc2Zvcm0pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmFyIG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC8pO1xuICAgICAgICBpZiAobWF0cml4M2QpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeDNkWzFdLCBwb3MzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pO1xuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xudmFyIHRyYW5zZm9ybUtleXMgPSBuZXcgU2V0KFtcInhcIiwgXCJ5XCIsIFwielwiXSk7XG52YXIgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1Qcm9wcy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIXRyYW5zZm9ybUtleXMuaGFzKGtleSk7IH0pO1xuZnVuY3Rpb24gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gICAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWRUcmFuc2Zvcm1zLnB1c2goW2tleSwgdmFsdWUuZ2V0KCldKTtcbiAgICAgICAgICAgIHZhbHVlLnNldChrZXkuc3RhcnRzV2l0aChcInNjYWxlXCIpID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgY2hhbmdlcyB0byBlbGVtZW50IGJlZm9yZSBtZWFzdXJlbWVudFxuICAgIGlmIChyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgIHJldHVybiByZW1vdmVkVHJhbnNmb3Jtcztcbn1cbnZhciBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICAgIC8vIERpbWVuc2lvbnNcbiAgICB3aWR0aDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeCA9IF9hLng7XG4gICAgICAgIHZhciBfYyA9IF9iLnBhZGRpbmdMZWZ0LCBwYWRkaW5nTGVmdCA9IF9jID09PSB2b2lkIDAgPyBcIjBcIiA6IF9jLCBfZCA9IF9iLnBhZGRpbmdSaWdodCwgcGFkZGluZ1JpZ2h0ID0gX2QgPT09IHZvaWQgMCA/IFwiMFwiIDogX2Q7XG4gICAgICAgIHJldHVybiB4Lm1heCAtIHgubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nTGVmdCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdSaWdodCk7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIHkgPSBfYS55O1xuICAgICAgICB2YXIgX2MgPSBfYi5wYWRkaW5nVG9wLCBwYWRkaW5nVG9wID0gX2MgPT09IHZvaWQgMCA/IFwiMFwiIDogX2MsIF9kID0gX2IucGFkZGluZ0JvdHRvbSwgcGFkZGluZ0JvdHRvbSA9IF9kID09PSB2b2lkIDAgPyBcIjBcIiA6IF9kO1xuICAgICAgICByZXR1cm4geS5tYXggLSB5Lm1pbiAtIHBhcnNlRmxvYXQocGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdCb3R0b20pO1xuICAgIH0sXG4gICAgdG9wOiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XG4gICAgICAgIHZhciB0b3AgPSBfYS50b3A7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRvcCk7XG4gICAgfSxcbiAgICBsZWZ0OiBmdW5jdGlvbiAoX2Jib3gsIF9hKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobGVmdCk7XG4gICAgfSxcbiAgICBib3R0b206IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIHkgPSBfYS55O1xuICAgICAgICB2YXIgdG9wID0gX2IudG9wO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3ApICsgKHkubWF4IC0geS5taW4pO1xuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIHggPSBfYS54O1xuICAgICAgICB2YXIgbGVmdCA9IF9iLmxlZnQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpICsgKHgubWF4IC0geC5taW4pO1xuICAgIH0sXG4gICAgLy8gVHJhbnNmb3JtXG4gICAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gICAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNCksXG59O1xudmFyIGNvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHZpc3VhbEVsZW1lbnQsIGNoYW5nZWRLZXlzKSB7XG4gICAgdmFyIG9yaWdpbkJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgIHZhciBlbGVtZW50ID0gdmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBlbGVtZW50Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgdmFyIGRpc3BsYXkgPSBlbGVtZW50Q29tcHV0ZWRTdHlsZS5kaXNwbGF5O1xuICAgIHZhciBvcmlnaW4gPSB7fTtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgc2V0IHRvIGRpc3BsYXk6IFwibm9uZVwiLCBtYWtlIGl0IHZpc2libGUgYmVmb3JlXG4gICAgLy8gbWVhc3VyaW5nIHRoZSB0YXJnZXQgYm91bmRpbmcgYm94XG4gICAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoXCJkaXNwbGF5XCIsIHRhcmdldC5kaXNwbGF5IHx8IFwiYmxvY2tcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29yZCBvcmlnaW5zIGJlZm9yZSB3ZSByZW5kZXIgYW5kIHVwZGF0ZSBzdHlsZXNcbiAgICAgKi9cbiAgICBjaGFuZ2VkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb3JpZ2luW2tleV0gPSBwb3NpdGlvbmFsVmFsdWVzW2tleV0ob3JpZ2luQmJveCwgZWxlbWVudENvbXB1dGVkU3R5bGUpO1xuICAgIH0pO1xuICAgIC8vIEFwcGx5IHRoZSBsYXRlc3QgdmFsdWVzIChhcyBzZXQgaW4gY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMpXG4gICAgdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgdmFyIHRhcmdldEJib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgIGNoYW5nZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBSZXN0b3JlIHN0eWxlcyB0byB0aGVpciAqKmNhbGN1bGF0ZWQgY29tcHV0ZWQgc3R5bGUqKiwgbm90IHRoZWlyIGFjdHVhbFxuICAgICAgICAvLyBvcmlnaW5hbGx5IHNldCBzdHlsZS4gVGhpcyBhbGxvd3MgdXMgdG8gYW5pbWF0ZSBiZXR3ZWVuIGVxdWl2YWxlbnQgcGl4ZWwgdW5pdHMuXG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgb3JpZ2luW2tleV0pO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XSh0YXJnZXRCYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMgPSBmdW5jdGlvbiAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgICBpZiAob3JpZ2luID09PSB2b2lkIDApIHsgb3JpZ2luID0ge307IH1cbiAgICBpZiAodHJhbnNpdGlvbkVuZCA9PT0gdm9pZCAwKSB7IHRyYW5zaXRpb25FbmQgPSB7fTsgfVxuICAgIHRhcmdldCA9IHRzbGliLl9fYXNzaWduKHt9LCB0YXJnZXQpO1xuICAgIHRyYW5zaXRpb25FbmQgPSB0c2xpYi5fX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkVuZCk7XG4gICAgdmFyIHRhcmdldFBvc2l0aW9uYWxLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIoaXNQb3NpdGlvbmFsS2V5KTtcbiAgICAvLyBXZSB3YW50IHRvIHJlbW92ZSBhbnkgdHJhbnNmb3JtIHZhbHVlcyB0aGF0IGNvdWxkIGFmZmVjdCB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIGJveCBiZWZvcmVcbiAgICAvLyBpdCdzIG1lYXN1cmVkLiBXZSdsbCByZWFwcGx5IHRoZXNlIGxhdGVyLlxuICAgIHZhciByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID0gW107XG4gICAgdmFyIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gZmFsc2U7XG4gICAgdmFyIGNoYW5nZWRWYWx1ZVR5cGVLZXlzID0gW107XG4gICAgdGFyZ2V0UG9zaXRpb25hbEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBmcm9tID0gb3JpZ2luW2tleV07XG4gICAgICAgIHZhciBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgICAgIHZhciB0byA9IHRhcmdldFtrZXldO1xuICAgICAgICB2YXIgdG9UeXBlO1xuICAgICAgICAvLyBUT0RPOiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGJhc2ljYWxseSB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgLy8gaWYgeW91IHRyeSBhbmQgZG8gdmFsdWUgY29udmVyc2lvbiB2aWEga2V5ZnJhbWVzLiBUaGVyZSdzIHByb2JhYmx5XG4gICAgICAgIC8vIGEgd2F5IG9mIGRvaW5nIHRoaXMgYnV0IHRoZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMgd291bGQgbmVlZCBncmVhdGVyIHNjcnV0aW55LFxuICAgICAgICAvLyBhcyBpdCdkIGJlIGRvaW5nIG11bHRpcGxlIHJlc2l6ZS1yZW1lYXN1cmUgb3BlcmF0aW9ucy5cbiAgICAgICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KHRvKSkge1xuICAgICAgICAgICAgdmFyIG51bUtleWZyYW1lcyA9IHRvLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSB0b1swXSA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgICAgICAgZnJvbSA9IHRvW2Zyb21JbmRleF07XG4gICAgICAgICAgICBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4OyBpIDwgbnVtS2V5ZnJhbWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0b1R5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaGV5TGlzdGVuLmludmFyaWFudCh0b1R5cGUgPT09IGZyb21UeXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNOdW1PclB4VHlwZShmcm9tVHlwZSkgJiYgaXNOdW1PclB4VHlwZSh0b1R5cGUpKSwgXCJLZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBkaW1lbnNpb24gYXMgdGhlIGN1cnJlbnQgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZXlMaXN0ZW4uaW52YXJpYW50KGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pID09PSB0b1R5cGUsIFwiQWxsIGtleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZSh0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21UeXBlICE9PSB0b1R5cGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXkncmUgYm90aCBqdXN0IG51bWJlciBvciBweCwgY29udmVydCB0aGVtIGJvdGggdG8gbnVtYmVycyByYXRoZXIgdGhhblxuICAgICAgICAgICAgLy8gcmVseWluZyBvbiByZXNpemUvcmVtZWFzdXJlIHRvIGNvbnZlcnQgKHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoaXMgc2l0dWF0aW9uKVxuICAgICAgICAgICAgaWYgKGlzTnVtT3JQeFR5cGUoZnJvbVR5cGUpICYmIGlzTnVtT3JQeFR5cGUodG9UeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldChwYXJzZUZsb2F0KGN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHBhcnNlRmxvYXQodG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRvKSAmJiB0b1R5cGUgPT09IHN0eWxlVmFsdWVUeXBlcy5weCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHRvLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZnJvbVR5cGUgPT09IG51bGwgfHwgZnJvbVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyb21UeXBlLnRyYW5zZm9ybSkgJiZcbiAgICAgICAgICAgICAgICAodG9UeXBlID09PSBudWxsIHx8IHRvVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9UeXBlLnRyYW5zZm9ybSkgJiZcbiAgICAgICAgICAgICAgICAoZnJvbSA9PT0gMCB8fCB0byA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBvbmUgb3IgdGhlIG90aGVyIHZhbHVlIGlzIDAsIGl0J3Mgc2FmZSB0byBjb2VyY2UgaXQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHlwZSBvZiB0aGUgb3RoZXIgd2l0aG91dCBtZWFzdXJlbWVudFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldCh0b1R5cGUudHJhbnNmb3JtKGZyb20pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZnJvbVR5cGUudHJhbnNmb3JtKHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byBkbyB2YWx1ZSBjb252ZXJzaW9uIHZpYSBET00gbWVhc3VyZW1lbnRzLCB3ZSBmaXJzdFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVtb3ZlIG5vbi1wb3NpdGlvbmFsIHRyYW5zZm9ybSB2YWx1ZXMgdGhhdCBjb3VsZCBhZmZlY3QgdGhlIGJib3ggbWVhc3VyZW1lbnRzLlxuICAgICAgICAgICAgICAgIGlmICghaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWRWYWx1ZVR5cGVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRW5kW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWRWYWx1ZVR5cGVLZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIgc2Nyb2xsWV8xID0gY2hhbmdlZFZhbHVlVHlwZUtleXMuaW5kZXhPZihcImhlaWdodFwiKSA+PSAwXG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB2YXIgY29udmVydGVkVGFyZ2V0ID0gY29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZFZhbHVlVHlwZUtleXMpO1xuICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIHRyYW5zZm9ybSB2YWx1ZXMsIHJlYXBwbHkgdGhlbSBiZWZvcmUgdGhlIG5leHQgcmVuZGVyXG4gICAgICAgIGlmIChyZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IHRzbGliLl9fcmVhZChfYSwgMiksIGtleSA9IF9iWzBdLCB2YWx1ZSA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhcHBseSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgICAgIC8vIFJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxZXzEgIT09IG51bGwpXG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeyB0b3A6IHNjcm9sbFlfMSB9KTtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiBjb252ZXJ0ZWRUYXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XG4gICAgfVxufTtcbi8qKlxuICogQ29udmVydCB2YWx1ZSB0eXBlcyBmb3IgeC95L3dpZHRoL2hlaWdodC90b3AvbGVmdC9ib3R0b20vcmlnaHRcbiAqXG4gKiBBbGxvd3MgYW5pbWF0aW9uIGJldHdlZW4gYCdhdXRvJ2AgLT4gYCcxMDAlJ2Agb3IgYDBgIC0+IGAnY2FsYyg1MCUgLSAxMHZ3KSdgXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVuaXRDb252ZXJzaW9uKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSB7XG4gICAgcmV0dXJuIGhhc1Bvc2l0aW9uYWxLZXkodGFyZ2V0KVxuICAgICAgICA/IGNoZWNrQW5kQ29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKVxuICAgICAgICA6IHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIERPTSB2YXJpYW50IHRvIG1ha2UgaXQgYW5pbWF0YWJsZS4gVGhpcyBpbnZvbHZlcyByZXNvbHZpbmcgQ1NTIHZhcmlhYmxlc1xuICogYW5kIGVuc3VyaW5nIGFuaW1hdGlvbnMgbGlrZSBcIjIwJVwiID0+IFwiY2FsYyg1MHZ3KVwiIGFyZSBwZXJmb3JtZWQgaW4gcGl4ZWxzLlxuICovXG52YXIgcGFyc2VEb21WYXJpYW50ID0gZnVuY3Rpb24gKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKSB7XG4gICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIHRyYW5zaXRpb25FbmQpO1xuICAgIHRhcmdldCA9IHJlc29sdmVkLnRhcmdldDtcbiAgICB0cmFuc2l0aW9uRW5kID0gcmVzb2x2ZWQudHJhbnNpdGlvbkVuZDtcbiAgICByZXR1cm4gdW5pdENvbnZlcnNpb24odmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG52YXIgaHRtbENvbmZpZyA9IHtcbiAgICB0cmVlVHlwZTogXCJkb21cIixcbiAgICByZWFkVmFsdWVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChkb21FbGVtZW50LCBrZXkpIHtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFR5cGUgPyBkZWZhdWx0VHlwZS5kZWZhdWx0IHx8IDAgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlJDEoZG9tRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gKChpc0NTU1ZhcmlhYmxlJDEoa2V5KVxuICAgICAgICAgICAgICAgID8gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSlcbiAgICAgICAgICAgICAgICA6IGNvbXB1dGVkU3R5bGVba2V5XSkgfHwgMCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNvcnROb2RlUG9zaXRpb246IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiByZXR1cm5zIGEgYml0bWFzaywgYnkgdXNpbmcgdGhlIGJpdHdpc2UgJlxuICAgICAgICAgKiB3ZSdyZSByZXR1cm5pbmcgdHJ1ZSBpZiAyIGluIHRoYXQgYml0bWFzayBpcyBzZXQgdG8gdHJ1ZS4gMiBpcyBzZXRcbiAgICAgICAgICogdG8gdHJ1ZSBpZiBiIHByZWNlZWRzIGEuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDIgPyAxIDogLTE7XG4gICAgfSxcbiAgICBnZXRCYXNlVGFyZ2V0OiBmdW5jdGlvbiAocHJvcHMsIGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSBwcm9wcy5zdHlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV07XG4gICAgfSxcbiAgICBtZWFzdXJlVmlld3BvcnRCb3g6IGZ1bmN0aW9uIChlbGVtZW50LCBfYSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtUGFnZVBvaW50ID0gX2EudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICByZXR1cm4gbWVhc3VyZVZpZXdwb3J0Qm94KGVsZW1lbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgdHJhbnNmb3JtIG9uIHRoZSBjdXJyZW50IEVsZW1lbnQuIFRoaXMgaXMgY2FsbGVkIGFzIHBhcnRcbiAgICAgKiBvZiBhIGJhdGNoZWQgcHJvY2VzcyBhY3Jvc3MgdGhlIGVudGlyZSBsYXlvdXQgdHJlZS4gVG8gcmVtb3ZlIHRoaXMgd3JpdGVcbiAgICAgKiBjeWNsZSBpdCdkIGJlIGludGVyZXN0aW5nIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIFwidW5kb1wiIGFsbCB0aGUgY3VycmVudFxuICAgICAqIGxheW91dCB0cmFuc2Zvcm1zIHVwIHRoZSB0cmVlIGluIHRoZSBzYW1lIHdheSB0aGlzLmdldEJvdW5kaW5nQm94V2l0aG91dFRyYW5zZm9ybXNcbiAgICAgKiB3b3Jrc1xuICAgICAqL1xuICAgIHJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoZWxlbWVudCwgZG9tRWxlbWVudCwgcHJvcHMpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gcHJvcHMudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgIGRvbUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpXG4gICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3aGF0ZXZlciBoYXBwZW5zIG5leHQsIHdlIHJlc3RvcmUgb3VyIHRyYW5zZm9ybSBvbiB0aGUgbmV4dCBmcmFtZVxuICAgICAgICBlbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfSxcbiAgICByZXN0b3JlVHJhbnNmb3JtOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG11dGFibGVTdGF0ZSkge1xuICAgICAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSBtdXRhYmxlU3RhdGUuc3R5bGUudHJhbnNmb3JtO1xuICAgIH0sXG4gICAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGU6IGZ1bmN0aW9uIChrZXksIF9hKSB7XG4gICAgICAgIHZhciB2YXJzID0gX2EudmFycywgc3R5bGUgPSBfYS5zdHlsZTtcbiAgICAgICAgZGVsZXRlIHZhcnNba2V5XTtcbiAgICAgICAgZGVsZXRlIHN0eWxlW2tleV07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBIVE1MIGFuZCBGcmFtZXItc3BlY2lmaWMgdmFsdWUgdHlwZXMgbGlrZSBgcHhgLT5gJWAgYW5kIGBDb2xvcmBcbiAgICAgKiBjYW4gYmUgYW5pbWF0ZWQgYnkgTW90aW9uLlxuICAgICAqL1xuICAgIG1ha2VUYXJnZXRBbmltYXRhYmxlOiBmdW5jdGlvbiAoZWxlbWVudCwgX2EsIF9iLCBpc01vdW50ZWQpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVZhbHVlcyA9IF9iLnRyYW5zZm9ybVZhbHVlcztcbiAgICAgICAgaWYgKGlzTW91bnRlZCA9PT0gdm9pZCAwKSB7IGlzTW91bnRlZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBfYS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kID0gX2EudHJhbnNpdGlvbkVuZCwgdGFyZ2V0ID0gdHNsaWIuX19yZXN0KF9hLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgICAgIHZhciBvcmlnaW4gPSBnZXRPcmlnaW4odGFyZ2V0LCB0cmFuc2l0aW9uIHx8IHt9LCBlbGVtZW50KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIEZyYW1lciBoYXMgcHJvdmlkZWQgYSBmdW5jdGlvbiB0byBjb252ZXJ0IGBDb2xvcmAgZXRjIHZhbHVlIHR5cGVzLCBjb252ZXJ0IHRoZW1cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0cmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uRW5kKVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgPSB0cmFuc2Zvcm1WYWx1ZXModHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRyYW5zZm9ybVZhbHVlcyh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbilcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSB0cmFuc2Zvcm1WYWx1ZXMob3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgICBjaGVja1RhcmdldEZvck5ld1ZhbHVlcyhlbGVtZW50LCB0YXJnZXQsIG9yaWdpbik7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VEb21WYXJpYW50KGVsZW1lbnQsIHRhcmdldCwgb3JpZ2luLCB0cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgPSBwYXJzZWQudHJhbnNpdGlvbkVuZDtcbiAgICAgICAgICAgIHRhcmdldCA9IHBhcnNlZC50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9LCB0YXJnZXQpO1xuICAgIH0sXG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMSxcbiAgICBidWlsZDogZnVuY3Rpb24gKGVsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmlzVmlzaWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5zdHlsZS52aXNpYmlsaXR5ID0gZWxlbWVudC5pc1Zpc2libGVcbiAgICAgICAgICAgICAgICA/IFwidmlzaWJsZVwiXG4gICAgICAgICAgICAgICAgOiBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkSFRNTFN0eWxlcyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgfSxcbiAgICByZW5kZXI6IHJlbmRlckhUTUwsXG59O1xudmFyIGh0bWxWaXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudChodG1sQ29uZmlnKTtcblxudmFyIHN2Z1Zpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBodG1sQ29uZmlnKSwgeyBnZXRCYXNlVGFyZ2V0OiBmdW5jdGlvbiAocHJvcHMsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICB9LCByZWFkVmFsdWVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChkb21FbGVtZW50LCBrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoKF9hID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVmYXVsdCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSAhY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXk7XG4gICAgICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIH0sIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLCBidWlsZDogZnVuY3Rpb24gKF9lbGVtZW50LCByZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcykge1xuICAgICAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9LCByZW5kZXI6IHJlbmRlclNWRyB9KSk7XG5cbnZhciBjcmVhdGVEb21WaXN1YWxFbGVtZW50ID0gZnVuY3Rpb24gKENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgID8gc3ZnVmlzdWFsRWxlbWVudChvcHRpb25zLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9KVxuICAgICAgICA6IGh0bWxWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IHRydWUgfSk7XG59O1xuXG5mdW5jdGlvbiBwaXhlbHNUb1BlcmNlbnQocGl4ZWxzLCBheGlzKSB7XG4gICAgaWYgKGF4aXMubWF4ID09PSBheGlzLm1pbilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChwaXhlbHMgLyAoYXhpcy5tYXggLSBheGlzLm1pbikpICogMTAwO1xufVxuLyoqXG4gKiBXZSBhbHdheXMgY29ycmVjdCBib3JkZXJSYWRpdXMgYXMgYSBwZXJjZW50YWdlIHJhdGhlciB0aGFuIHBpeGVscyB0byByZWR1Y2UgcGFpbnRzLlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBhcmUgcHJvamVjdGluZyBhIGJveCB0aGF0IGlzIDEwMHB4IHdpZGUgd2l0aCBhIDEwcHggYm9yZGVyUmFkaXVzXG4gKiBpbnRvIGEgYm94IHRoYXQgaXMgMjAwcHggd2lkZSB3aXRoIGEgMjBweCBib3JkZXJSYWRpdXMsIHRoYXQgaXMgYWN0dWFsbHkgYSAxMCVcbiAqIGJvcmRlclJhZGl1cyBpbiBib3RoIHN0YXRlcy4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGl4ZWxzIHRoYXQgd2lsbCB0cmlnZ2VyXG4gKiBhIHBhaW50IGVhY2ggdGltZS4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGVyY2VudGFnZSB3ZSdsbCBhdm9pZCBhIHBhaW50LlxuICovXG52YXIgY29ycmVjdEJvcmRlclJhZGl1cyA9IHtcbiAgICBjb3JyZWN0OiBmdW5jdGlvbiAobGF0ZXN0LCBub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS50YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGF0ZXN0IGlzIGEgc3RyaW5nLCBpZiBpdCdzIGEgcGVyY2VudGFnZSB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5IGFzIGl0J3NcbiAgICAgICAgICogZ29pbmcgdG8gYmUgc3RyZXRjaGVkIGFwcHJvcHJpYXRlbHkuIE90aGVyd2lzZSwgaWYgaXQncyBhIHBpeGVsLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBsYXRlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZVZhbHVlVHlwZXMucHgudGVzdChsYXRlc3QpKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0ID0gcGFyc2VGbG9hdChsYXRlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhdGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGF0ZXN0IGlzIGEgbnVtYmVyLCBpdCdzIGEgcGl4ZWwgdmFsdWUuIFdlIHVzZSB0aGUgY3VycmVudCB2aWV3cG9ydEJveCB0byBjYWxjdWxhdGUgdGhhdFxuICAgICAgICAgKiBwaXhlbCB2YWx1ZSBhcyBhIHBlcmNlbnRhZ2Ugb2YgZWFjaCBheGlzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgeCA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LngpO1xuICAgICAgICB2YXIgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LnkpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoeCwgXCIlIFwiKS5jb25jYXQoeSwgXCIlXCIpO1xuICAgIH0sXG59O1xuXG52YXIgdmFyVG9rZW4gPSBcIl8kY3NzXCI7XG52YXIgY29ycmVjdEJveFNoYWRvdyA9IHtcbiAgICBjb3JyZWN0OiBmdW5jdGlvbiAobGF0ZXN0LCBfYSkge1xuICAgICAgICB2YXIgdHJlZVNjYWxlID0gX2EudHJlZVNjYWxlLCBwcm9qZWN0aW9uRGVsdGEgPSBfYS5wcm9qZWN0aW9uRGVsdGE7XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGxhdGVzdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG5lZWQgdG8gZmlyc3Qgc3RyaXAgYW5kIHN0b3JlIENTUyB2YXJpYWJsZXMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNvbnRhaW5zQ1NTVmFyaWFibGVzID0gbGF0ZXN0LmluY2x1ZGVzKFwidmFyKFwiKTtcbiAgICAgICAgdmFyIGNzc1ZhcmlhYmxlcyA9IFtdO1xuICAgICAgICBpZiAoY29udGFpbnNDU1NWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGxhdGVzdCA9IGxhdGVzdC5yZXBsYWNlKGNzc1ZhcmlhYmxlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGNzc1ZhcmlhYmxlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyVG9rZW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZG93ID0gc3R5bGVWYWx1ZVR5cGVzLmNvbXBsZXgucGFyc2UobGF0ZXN0KTtcbiAgICAgICAgLy8gVE9ETzogRG9lc24ndCBzdXBwb3J0IG11bHRpcGxlIHNoYWRvd3NcbiAgICAgICAgaWYgKHNoYWRvdy5sZW5ndGggPiA1KVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBzdHlsZVZhbHVlVHlwZXMuY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcihsYXRlc3QpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdHlwZW9mIHNoYWRvd1swXSAhPT0gXCJudW1iZXJcIiA/IDEgOiAwO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJhbGwgY29udGV4dCBzY2FsZVxuICAgICAgICB2YXIgeFNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICAgICAgdmFyIHlTY2FsZSA9IHByb2plY3Rpb25EZWx0YS55LnNjYWxlICogdHJlZVNjYWxlLnk7XG4gICAgICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHdlJ2QgY29ycmVjdCB4IGFuZCB5IHNjYWxlcyBpbmRpdmlkdWFsbHksIGJ1dCBiZWNhdXNlIGJsdXIgYW5kXG4gICAgICAgICAqIHNwcmVhZCBhcHBseSB0byBib3RoIHdlIGhhdmUgdG8gdGFrZSBhIHNjYWxlIGF2ZXJhZ2UgYW5kIGFwcGx5IHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICogV2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSB0aGUgb3V0Y29tZSBvZiB0aGlzIGJ5IGluY29ycG9yYXRpbmcgdGhlIHJhdGlvIGJldHdlZW5cbiAgICAgICAgICogdGhlIHR3byBzY2FsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXZlcmFnZVNjYWxlID0gcG9wbW90aW9uLm1peCh4U2NhbGUsIHlTY2FsZSwgMC41KTtcbiAgICAgICAgLy8gQmx1clxuICAgICAgICBpZiAodHlwZW9mIHNoYWRvd1syICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNoYWRvd1syICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgICAgIC8vIFNwcmVhZFxuICAgICAgICBpZiAodHlwZW9mIHNoYWRvd1szICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNoYWRvd1szICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0ZW1wbGF0ZShzaGFkb3cpO1xuICAgICAgICBpZiAoY29udGFpbnNDU1NWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHZhciBpXzEgPSAwO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UodmFyVG9rZW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzVmFyaWFibGUgPSBjc3NWYXJpYWJsZXNbaV8xXTtcbiAgICAgICAgICAgICAgICBpXzErKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3NzVmFyaWFibGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG59O1xuXG52YXIgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVhc3VyZUxheW91dFdpdGhDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgb25seSBtb3VudHMgcHJvamVjdGlvbiBub2RlcyBmb3IgY29tcG9uZW50cyB0aGF0XG4gICAgICogbmVlZCBtZWFzdXJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZG8gaXQgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgICogaW4gb3JkZXIgdG8gaW5jb3Jwb3JhdGUgdHJhbnNmb3Jtc1xuICAgICAqL1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCA9IF9hLmxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cCA9IF9hLnN3aXRjaExheW91dEdyb3VwLCBsYXlvdXRJZCA9IF9hLmxheW91dElkO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgYWRkU2NhbGVDb3JyZWN0b3IoZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAgPT09IG51bGwgfHwgbGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLmFkZChwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICgoc3dpdGNoTGF5b3V0R3JvdXAgPT09IG51bGwgfHwgc3dpdGNoTGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyKSAmJiBsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uQ29tcGxldGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNldE9wdGlvbnModHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHByb2plY3Rpb24ub3B0aW9ucyksIHsgb25FeGl0Q29tcGxldGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNhZmVUb1JlbW92ZSgpOyB9IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbGF5b3V0RGVwZW5kZW5jeSA9IF9hLmxheW91dERlcGVuZGVuY3ksIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50LCBkcmFnID0gX2EuZHJhZywgaXNQcmVzZW50ID0gX2EuaXNQcmVzZW50O1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBXZSB1c2UgdGhpcyBkYXRhIGluIHJlbGVnYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvXG4gICAgICAgICAqIHByb21vdGUgYSBwcmV2aW91cyBlbGVtZW50LiBUaGVyZSdzIG5vIGd1YXJhbnRlZSBpdHMgcHJlc2VuY2UgZGF0YVxuICAgICAgICAgKiB3aWxsIGhhdmUgdXBkYXRlZCBieSB0aGlzIHBvaW50IC0gaWYgYSBidWcgbGlrZSB0aGlzIGFyaXNlcyBpdCB3aWxsXG4gICAgICAgICAqIGhhdmUgdG8gYmUgdGhhdCB3ZSBtYXJrRm9yUmVsZWdhdGlvbiBhbmQgdGhlbiBmaW5kIGEgbmV3IGxlYWQgc29tZSBvdGhlciB3YXksXG4gICAgICAgICAqIHBlcmhhcHMgaW4gZGlkVXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0aW9uLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICAgICAgaWYgKGRyYWcgfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5sYXlvdXREZXBlbmRlbmN5ICE9PSBsYXlvdXREZXBlbmRlbmN5IHx8XG4gICAgICAgICAgICBsYXlvdXREZXBlbmRlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ud2lsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzLmlzUHJlc2VudCAhPT0gaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wcm9tb3RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghcHJvamVjdGlvbi5yZWxlZ2F0ZSgpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlcmUncyBhbm90aGVyIHN0YWNrIG1lbWJlciB0YWtpbmcgb3ZlciBmcm9tIHRoaXMgb25lLFxuICAgICAgICAgICAgICAgICAqIGl0J3MgaW4gY2hhcmdlIG9mIHRoZSBleGl0IGFuaW1hdGlvbiBhbmQgdGhlcmVmb3JlIHNob3VsZFxuICAgICAgICAgICAgICAgICAqIGJlIGluIGNoYXJnZSBvZiB0aGUgc2FmZSB0byByZW1vdmUuIE90aGVyd2lzZSB3ZSBjYWxsIGl0IGhlcmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucG9zdFJlbmRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gcHJvamVjdGlvbi5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5wcm9wcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAoIXByb2plY3Rpb24uY3VycmVudEFuaW1hdGlvbiAmJiBwcm9qZWN0aW9uLmlzTGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwID0gX2EubGF5b3V0R3JvdXAsIHByb21vdGVDb250ZXh0ID0gX2Euc3dpdGNoTGF5b3V0R3JvdXA7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5zY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCk7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAgPT09IG51bGwgfHwgbGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLnJlbW92ZShwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9tb3RlQ29udGV4dCA9PT0gbnVsbCB8fCBwcm9tb3RlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZUNvbnRleHQuZGVyZWdpc3RlcilcbiAgICAgICAgICAgICAgICBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLnNhZmVUb1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhZmVUb1JlbW92ZSA9IHRoaXMucHJvcHMuc2FmZVRvUmVtb3ZlO1xuICAgICAgICBzYWZlVG9SZW1vdmUgPT09IG51bGwgfHwgc2FmZVRvUmVtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzYWZlVG9SZW1vdmUoKTtcbiAgICB9O1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQ7XG59KFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpKTtcbmZ1bmN0aW9uIE1lYXN1cmVMYXlvdXQocHJvcHMpIHtcbiAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQodXNlUHJlc2VuY2UoKSwgMiksIGlzUHJlc2VudCA9IF9hWzBdLCBzYWZlVG9SZW1vdmUgPSBfYVsxXTtcbiAgICB2YXIgbGF5b3V0R3JvdXAgPSBSZWFjdC51c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQsIHRzbGliLl9fYXNzaWduKHt9LCBwcm9wcywgeyBsYXlvdXRHcm91cDogbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiBSZWFjdC51c2VDb250ZXh0KFN3aXRjaExheW91dEdyb3VwQ29udGV4dCksIGlzUHJlc2VudDogaXNQcmVzZW50LCBzYWZlVG9SZW1vdmU6IHNhZmVUb1JlbW92ZSB9KSkpO1xufVxudmFyIGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gICAgYm9yZGVyUmFkaXVzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY29ycmVjdEJvcmRlclJhZGl1cyksIHsgYXBwbHlUbzogW1xuICAgICAgICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICAgICAgICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgICAgICAgXSB9KSxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm94U2hhZG93OiBjb3JyZWN0Qm94U2hhZG93LFxufTtcblxudmFyIGxheW91dEZlYXR1cmVzID0ge1xuICAgIG1lYXN1cmVMYXlvdXQ6IE1lYXN1cmVMYXlvdXQsXG59O1xuXG4vKipcbiAqIEFuaW1hdGUgYSBzaW5nbGUgdmFsdWUgb3IgYSBgTW90aW9uVmFsdWVgLlxuICpcbiAqIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBlaXRoZXIgYSBgTW90aW9uVmFsdWVgIHRvIGFuaW1hdGUsIG9yIGFuIGluaXRpYWwgYW5pbWF0aW9uIHZhbHVlLlxuICpcbiAqIFRoZSBzZWNvbmQgaXMgZWl0aGVyIGEgdmFsdWUgdG8gYW5pbWF0ZSB0bywgb3IgYW4gYXJyYXkgb2Yga2V5ZnJhbWVzIHRvIGFuaW1hdGUgdGhyb3VnaC5cbiAqXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgY2FuIGJlIGVpdGhlciB0d2VlbiBvciBzcHJpbmcgb3B0aW9ucywgYW5kIG9wdGlvbmFsIGxpZmVjeWNsZSBtZXRob2RzOiBgb25VcGRhdGVgLCBgb25QbGF5YCwgYG9uQ29tcGxldGVgLCBgb25SZXBlYXRgIGFuZCBgb25TdG9wYC5cbiAqXG4gKiBSZXR1cm5zIGBBbmltYXRpb25QbGF5YmFja0NvbnRyb2xzYCwgY3VycmVudGx5IGp1c3QgYSBgc3RvcGAgbWV0aG9kLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHggPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICpcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIGNvbnN0IGNvbnRyb2xzID0gYW5pbWF0ZSh4LCAxMDAsIHtcbiAqICAgICB0eXBlOiBcInNwcmluZ1wiLFxuICogICAgIHN0aWZmbmVzczogMjAwMCxcbiAqICAgICBvbkNvbXBsZXRlOiB2ID0+IHt9XG4gKiAgIH0pXG4gKlxuICogICByZXR1cm4gY29udHJvbHMuc3RvcFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShmcm9tLCB0bywgdHJhbnNpdGlvbikge1xuICAgIGlmICh0cmFuc2l0aW9uID09PSB2b2lkIDApIHsgdHJhbnNpdGlvbiA9IHt9OyB9XG4gICAgdmFyIHZhbHVlID0gaXNNb3Rpb25WYWx1ZShmcm9tKSA/IGZyb20gOiBtb3Rpb25WYWx1ZShmcm9tKTtcbiAgICBzdGFydEFuaW1hdGlvbihcIlwiLCB2YWx1ZSwgdG8sIHRyYW5zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLnN0b3AoKTsgfSxcbiAgICAgICAgaXNBbmltYXRpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlLmlzQW5pbWF0aW5nKCk7IH0sXG4gICAgfTtcbn1cblxudmFyIGJvcmRlcnMgPSBbXCJUb3BMZWZ0XCIsIFwiVG9wUmlnaHRcIiwgXCJCb3R0b21MZWZ0XCIsIFwiQm90dG9tUmlnaHRcIl07XG52YXIgbnVtQm9yZGVycyA9IGJvcmRlcnMubGVuZ3RoO1xudmFyIGFzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG59O1xudmFyIGlzUHggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHN0eWxlVmFsdWVUeXBlcy5weC50ZXN0KHZhbHVlKTtcbn07XG5mdW5jdGlvbiBtaXhWYWx1ZXModGFyZ2V0LCBmb2xsb3csIGxlYWQsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHNob3VsZENyb3NzZmFkZU9wYWNpdHkpIHtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHkgPSBwb3Btb3Rpb24ubWl4KDAsIFxuICAgICAgICAvLyAoZm9sbG93Py5vcGFjaXR5IGFzIG51bWJlcikgPz8gMCxcbiAgICAgICAgLy8gVE9ETyBSZWluc3RhdGUgdGhpcyBpZiBvbmx5IGNoaWxkXG4gICAgICAgIChfYSA9IGxlYWQub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSwgZWFzZUNyb3NzZmFkZUluKHByb2dyZXNzKSk7XG4gICAgICAgIHRhcmdldC5vcGFjaXR5RXhpdCA9IHBvcG1vdGlvbi5taXgoKF9iID0gZm9sbG93Lm9wYWNpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEsIDAsIGVhc2VDcm9zc2ZhZGVPdXQocHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPbmx5TWVtYmVyKSB7XG4gICAgICAgIHRhcmdldC5vcGFjaXR5ID0gcG9wbW90aW9uLm1peCgoX2MgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSwgKF9kID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxLCBwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1peCBib3JkZXIgcmFkaXVzXG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Cb3JkZXJzOyBpKyspIHtcbiAgICAgICAgdmFyIGJvcmRlckxhYmVsID0gXCJib3JkZXJcIi5jb25jYXQoYm9yZGVyc1tpXSwgXCJSYWRpdXNcIik7XG4gICAgICAgIHZhciBmb2xsb3dSYWRpdXMgPSBnZXRSYWRpdXMoZm9sbG93LCBib3JkZXJMYWJlbCk7XG4gICAgICAgIHZhciBsZWFkUmFkaXVzID0gZ2V0UmFkaXVzKGxlYWQsIGJvcmRlckxhYmVsKTtcbiAgICAgICAgaWYgKGZvbGxvd1JhZGl1cyA9PT0gdW5kZWZpbmVkICYmIGxlYWRSYWRpdXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb2xsb3dSYWRpdXMgfHwgKGZvbGxvd1JhZGl1cyA9IDApO1xuICAgICAgICBsZWFkUmFkaXVzIHx8IChsZWFkUmFkaXVzID0gMCk7XG4gICAgICAgIHZhciBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGxlYWRSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGlzUHgoZm9sbG93UmFkaXVzKSA9PT0gaXNQeChsZWFkUmFkaXVzKTtcbiAgICAgICAgaWYgKGNhbk1peCkge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KHBvcG1vdGlvbi5taXgoYXNOdW1iZXIoZm9sbG93UmFkaXVzKSwgYXNOdW1iZXIobGVhZFJhZGl1cyksIHByb2dyZXNzKSwgMCk7XG4gICAgICAgICAgICBpZiAoc3R5bGVWYWx1ZVR5cGVzLnBlcmNlbnQudGVzdChsZWFkUmFkaXVzKSB8fCBzdHlsZVZhbHVlVHlwZXMucGVyY2VudC50ZXN0KGZvbGxvd1JhZGl1cykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdICs9IFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IGxlYWRSYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IHJvdGF0aW9uXG4gICAgICovXG4gICAgaWYgKGZvbGxvdy5yb3RhdGUgfHwgbGVhZC5yb3RhdGUpIHtcbiAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IHBvcG1vdGlvbi5taXgoZm9sbG93LnJvdGF0ZSB8fCAwLCBsZWFkLnJvdGF0ZSB8fCAwLCBwcm9ncmVzcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmFkaXVzKHZhbHVlcywgcmFkaXVzTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdmFsdWVzW3JhZGl1c05hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZXMuYm9yZGVyUmFkaXVzO1xufVxuLy8gLyoqXG4vLyAgKiBXZSBvbmx5IHdhbnQgdG8gbWl4IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIHRoZXJlJ3MgYSBmb2xsb3cgZWxlbWVudFxuLy8gICogdGhhdCB3ZSdyZSBub3QgY3Jvc3NmYWRpbmcgb3BhY2l0eSBiZXR3ZWVuLiBGb3IgaW5zdGFuY2Ugd2l0aCBzd2l0Y2hcbi8vICAqIEFuaW1hdGVTaGFyZWRMYXlvdXQgYW5pbWF0aW9ucywgdGhpcyBoZWxwcyB0aGUgaWxsdXNpb24gb2YgYSBjb250aW51b3VzXG4vLyAgKiBlbGVtZW50IGJlaW5nIGFuaW1hdGVkIGJ1dCBhbHNvIGN1dHMgZG93biBvbiB0aGUgbnVtYmVyIG9mIHBhaW50cyB0cmlnZ2VyZWRcbi8vICAqIGZvciBlbGVtZW50cyB3aGVyZSBvcGFjaXR5IGlzIGRvaW5nIHRoYXQgd29yayBmb3IgdXMuXG4vLyAgKi9cbi8vIGlmIChcbi8vICAgICAhaGFzRm9sbG93RWxlbWVudCAmJlxuLy8gICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yICYmXG4vLyAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvclxuLy8gKSB7XG4vLyAgICAgLyoqXG4vLyAgICAgICogVGhpcyBpc24ndCBpZGVhbCBwZXJmb3JtYW5jZS13aXNlIGFzIG1peENvbG9yIGlzIGNyZWF0aW5nIGEgbmV3IGZ1bmN0aW9uIGV2ZXJ5IGZyYW1lLlxuLy8gICAgICAqIFdlIGNvdWxkIHByb2JhYmx5IGNyZWF0ZSBhIG1peGVyIHRoYXQgcnVucyBhdCB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvbiBidXRcbi8vICAgICAgKiB0aGUgaWRlYSBiZWhpbmQgdGhlIGNyb3NzZmFkZXIgaXMgdGhhdCBpdCBydW5zIGR5bmFtaWNhbGx5IGJldHdlZW4gdHdvIHBvdGVudGlhbGx5XG4vLyAgICAgICogY2hhbmdpbmcgdGFyZ2V0cyAoaWUgb3BhY2l0eSBvciBib3JkZXJSYWRpdXMgbWF5IGJlIGFuaW1hdGluZyBpbmRlcGVuZGVudGx5IHZpYSB2YXJpYW50cylcbi8vICAgICAgKi9cbi8vICAgICBsZWFkU3RhdGUuYmFja2dyb3VuZENvbG9yID0gZm9sbG93U3RhdGUuYmFja2dyb3VuZENvbG9yID0gbWl4Q29sb3IoXG4vLyAgICAgICAgIGxhdGVzdEZvbGxvd1ZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgYXMgc3RyaW5nLFxuLy8gICAgICAgICBsYXRlc3RMZWFkVmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmdcbi8vICAgICApKHApXG4vLyB9XG52YXIgZWFzZUNyb3NzZmFkZUluID0gY29tcHJlc3MoMCwgMC41LCBwb3Btb3Rpb24uY2lyY091dCk7XG52YXIgZWFzZUNyb3NzZmFkZU91dCA9IGNvbXByZXNzKDAuNSwgMC45NSwgcG9wbW90aW9uLmxpbmVhcik7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vIENvdWxkIHJlcGxhY2UgaWZzIHdpdGggY2xhbXBcbiAgICAgICAgaWYgKHAgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHAgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGVhc2luZyhwb3Btb3Rpb24ucHJvZ3Jlc3MobWluLCBtYXgsIHApKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJlc2V0IGFuIGF4aXMgdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUF4aXNJbnRvKGF4aXMsIG9yaWdpbkF4aXMpIHtcbiAgICBheGlzLm1pbiA9IG9yaWdpbkF4aXMubWluO1xuICAgIGF4aXMubWF4ID0gb3JpZ2luQXhpcy5tYXg7XG59XG4vKipcbiAqIFJlc2V0IGEgYm94IHRvIHRoZSBwcm92aWRlZCBvcmlnaW4gYm94LlxuICpcbiAqIFRoaXMgaXMgYSBtdXRhdGl2ZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvcHlCb3hJbnRvKGJveCwgb3JpZ2luQm94KSB7XG4gICAgY29weUF4aXNJbnRvKGJveC54LCBvcmlnaW5Cb3gueCk7XG4gICAgY29weUF4aXNJbnRvKGJveC55LCBvcmlnaW5Cb3gueSk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhIHBvaW50LiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseVBvaW50RGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBwb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCAxIC8gc2NhbGUsIG9yaWdpblBvaW50KTtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIFJlbW92ZSBhIGRlbHRhIGZyb20gYW4gYXhpcy4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzRGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luLCBib3hTY2FsZSwgb3JpZ2luQXhpcywgc291cmNlQXhpcykge1xuICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkgeyB0cmFuc2xhdGUgPSAwOyB9XG4gICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxOyB9XG4gICAgaWYgKG9yaWdpbiA9PT0gdm9pZCAwKSB7IG9yaWdpbiA9IDAuNTsgfVxuICAgIGlmIChvcmlnaW5BeGlzID09PSB2b2lkIDApIHsgb3JpZ2luQXhpcyA9IGF4aXM7IH1cbiAgICBpZiAoc291cmNlQXhpcyA9PT0gdm9pZCAwKSB7IHNvdXJjZUF4aXMgPSBheGlzOyB9XG4gICAgaWYgKHN0eWxlVmFsdWVUeXBlcy5wZXJjZW50LnRlc3QodHJhbnNsYXRlKSkge1xuICAgICAgICB0cmFuc2xhdGUgPSBwYXJzZUZsb2F0KHRyYW5zbGF0ZSk7XG4gICAgICAgIHZhciByZWxhdGl2ZVByb2dyZXNzID0gcG9wbW90aW9uLm1peChzb3VyY2VBeGlzLm1pbiwgc291cmNlQXhpcy5tYXgsIHRyYW5zbGF0ZSAvIDEwMCk7XG4gICAgICAgIHRyYW5zbGF0ZSA9IHJlbGF0aXZlUHJvZ3Jlc3MgLSBzb3VyY2VBeGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2xhdGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgb3JpZ2luUG9pbnQgPSBwb3Btb3Rpb24ubWl4KG9yaWdpbkF4aXMubWluLCBvcmlnaW5BeGlzLm1heCwgb3JpZ2luKTtcbiAgICBpZiAoYXhpcyA9PT0gb3JpZ2luQXhpcylcbiAgICAgICAgb3JpZ2luUG9pbnQgLT0gdHJhbnNsYXRlO1xuICAgIGF4aXMubWluID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zZm9ybXMgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNUcmFuc2Zvcm1zIGluIHJldmVyc2VcbiAqIGFuZCBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gbW90aW9uIHZhbHVlcyBhbmQgcmVtb3ZlQXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGF4aXMsIHRyYW5zZm9ybXMsIF9hLCBvcmlnaW4sIHNvdXJjZUF4aXMpIHtcbiAgICB2YXIgX2IgPSB0c2xpYi5fX3JlYWQoX2EsIDMpLCBrZXkgPSBfYlswXSwgc2NhbGVLZXkgPSBfYlsxXSwgb3JpZ2luS2V5ID0gX2JbMl07XG4gICAgcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIHRyYW5zZm9ybXNbb3JpZ2luS2V5XSwgdHJhbnNmb3Jtcy5zY2FsZSwgb3JpZ2luLCBzb3VyY2VBeGlzKTtcbn1cbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBtb3Rpb24gdmFsdWVzIHdlIHdhbnQgdG8gYXBwbHkgYXMgdHJhbnNsYXRpb24sIHNjYWxlIGFuZCBvcmlnaW4uXG4gKi9cbnZhciB4S2V5cyA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xudmFyIHlLZXlzID0gW1wieVwiLCBcInNjYWxlWVwiLCBcIm9yaWdpbllcIl07XG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zZm9ybXMgZnJvbSBhbiBib3guIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5QXhpc0JveCBpbiByZXZlcnNlXG4gKiBhbmQgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIG1vdGlvbiB2YWx1ZXMgYW5kIHJlbW92ZUF4aXNEZWx0YVxuICovXG5mdW5jdGlvbiByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveCwgdHJhbnNmb3Jtcywgb3JpZ2luQm94LCBzb3VyY2VCb3gpIHtcbiAgICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueCwgdHJhbnNmb3JtcywgeEtleXMsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC54LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueCk7XG4gICAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LnksIHRyYW5zZm9ybXMsIHlLZXlzLCBvcmlnaW5Cb3ggPT09IG51bGwgfHwgb3JpZ2luQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5Cb3gueSwgc291cmNlQm94ID09PSBudWxsIHx8IHNvdXJjZUJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlQm94LnkpO1xufVxuXG5mdW5jdGlvbiBpc0F4aXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gZGVsdGEudHJhbnNsYXRlID09PSAwICYmIGRlbHRhLnNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gaXNBeGlzRGVsdGFaZXJvKGRlbHRhLngpICYmIGlzQXhpc0RlbHRhWmVybyhkZWx0YS55KTtcbn1cbmZ1bmN0aW9uIGJveEVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLngubWluID09PSBiLngubWluICYmXG4gICAgICAgIGEueC5tYXggPT09IGIueC5tYXggJiZcbiAgICAgICAgYS55Lm1pbiA9PT0gYi55Lm1pbiAmJlxuICAgICAgICBhLnkubWF4ID09PSBiLnkubWF4KTtcbn1cblxudmFyIE5vZGVTdGFjayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlU3RhY2soKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgIH1cbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH07XG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZW1vdmVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZMZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmxlYWQpIHtcbiAgICAgICAgICAgIHZhciBwcmV2TGVhZCA9IHRoaXMubWVtYmVyc1t0aGlzLm1lbWJlcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnJlbGVnYXRlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZGV4T2ZOb2RlID0gdGhpcy5tZW1iZXJzLmZpbmRJbmRleChmdW5jdGlvbiAobWVtYmVyKSB7IHJldHVybiBub2RlID09PSBtZW1iZXI7IH0pO1xuICAgICAgICBpZiAoaW5kZXhPZk5vZGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBuZXh0IHByb2plY3Rpb24gbm9kZSB0aGF0IGlzIHByZXNlbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBwcmV2TGVhZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4T2ZOb2RlOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG1lbWJlciA9IHRoaXMubWVtYmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtZW1iZXIuaXNQcmVzZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXZMZWFkID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnByb21vdGUgPSBmdW5jdGlvbiAobm9kZSwgcHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHByZXZMZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICBpZiAobm9kZSA9PT0gcHJldkxlYWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucHJldkxlYWQgPSBwcmV2TGVhZDtcbiAgICAgICAgdGhpcy5sZWFkID0gbm9kZTtcbiAgICAgICAgbm9kZS5zaG93KCk7XG4gICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgcHJldkxlYWQuaW5zdGFuY2UgJiYgcHJldkxlYWQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIG5vZGUuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIG5vZGUucmVzdW1lRnJvbSA9IHByZXZMZWFkO1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlRm9sbG93T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVzdW1lRnJvbS5wcmVzZXJ2ZU9wYWNpdHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZMZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdCA9IHByZXZMZWFkLnNuYXBzaG90O1xuICAgICAgICAgICAgICAgIG5vZGUuc25hcHNob3QubGF0ZXN0VmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgcHJldkxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IHByZXZMZWFkLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgICAgICBub2RlLnNuYXBzaG90LmlzU2hhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2EgPSBub2RlLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcm9zc2ZhZGUgPSBub2RlLm9wdGlvbnMuY3Jvc3NmYWRlO1xuICAgICAgICAgICAgaWYgKGNyb3NzZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGVhZC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86XG4gICAgICAgICAgICAgKiAgIC0gVGVzdCBib3JkZXIgcmFkaXVzIHdoZW4gcHJldmlvdXMgbm9kZSB3YXMgZGVsZXRlZFxuICAgICAgICAgICAgICogICAtIGJveFNoYWRvdyBtaXhpbmdcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gc2Nyb2xsZWQgY29udGFpbmVyIGFuZCBlbGVtZW50IEIgKHNjcm9sbCBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiB0cmFuc2Zvcm1lZCBjb250YWluZXIgYW5kIGVsZW1lbnQgQiAodHJhbnNmb3JtIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHNjcm9sbGVkIHBhZ2UgYW5kIGVsZW1lbnQgQiAoc2Nyb2xsIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAtLS1cbiAgICAgICAgICAgICAqICAgLSBDcm9zc2ZhZGUgb3BhY2l0eSBvZiByb290IG5vZGVzXG4gICAgICAgICAgICAgKiAgIC0gbGF5b3V0SWQgY2hhbmdlcyBhZnRlciBhbmltYXRpb25cbiAgICAgICAgICAgICAqICAgLSBsYXlvdXRJZCBjaGFuZ2VzIG1pZCBhbmltYXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLmV4aXRBbmltYXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBub2RlLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICAoX2UgPSAoX2MgPSBub2RlLnJlc3VtaW5nRnJvbSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZCA9IF9jLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5zY2hlZHVsZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuaW5zdGFuY2UgJiYgbm9kZS5zY2hlZHVsZVJlbmRlcihmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYW55IGxlYWRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgdGhpcyByZW5kZXIgdG8gcHJldmVudCB0aGVtIGZyb20gYmVpbmdcbiAgICAgKiB1c2VkIGluIGZ1dHVyZSBhbmltYXRpb25zIGFuZCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAqL1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUucmVtb3ZlTGVhZFNuYXBzaG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sZWFkICYmIHRoaXMubGVhZC5zbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhpcy5sZWFkLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZVN0YWNrO1xufSgpKTtcblxudmFyIGlkZW50aXR5UHJvamVjdGlvbiA9IFwidHJhbnNsYXRlM2QoMHB4LCAwcHgsIDApIHNjYWxlKDEsIDEpIHNjYWxlKDEsIDEpXCI7XG5mdW5jdGlvbiBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0oZGVsdGEsIHRyZWVTY2FsZSwgbGF0ZXN0VHJhbnNmb3JtKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zbGF0aW9ucyB3ZSB1c2UgdG8gY2FsY3VsYXRlIGFyZSBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQnV0IHdoZW4gd2UgYXBwbHkgc2NhbGVzLCB3ZSBhbHNvIHNjYWxlIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIGFuIGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgKiBGb3IgaW5zdGFuY2UgaWYgd2UgaGF2ZSBhIHRyZWVTY2FsZSAodGhlIGN1bG1pbmF0aW9uIG9mIGFsbCBwYXJlbnQgc2NhbGVzKSBvZiAwLjUgYW5kIHdlIG5lZWRcbiAgICAgKiB0byBtb3ZlIGFuIGVsZW1lbnQgMTAwIHBpeGVscywgd2UgYWN0dWFsbHkgbmVlZCB0byBtb3ZlIGl0IDIwMCBpbiB3aXRoaW4gdGhhdCBzY2FsZWQgc3BhY2UuXG4gICAgICovXG4gICAgdmFyIHhUcmFuc2xhdGUgPSBkZWx0YS54LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICAgIHZhciB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoeFRyYW5zbGF0ZSwgXCJweCwgXCIpLmNvbmNhdCh5VHJhbnNsYXRlLCBcInB4LCAwKSBcIik7XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvbiBmb3IgdGhlIHRyZWUgdHJhbnNmb3JtLlxuICAgICAqIFRoaXMgd2lsbCBhcHBseSBzY2FsZSB0byB0aGUgc2NyZWVuLW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0gKz0gXCJzY2FsZShcIi5jb25jYXQoMSAvIHRyZWVTY2FsZS54LCBcIiwgXCIpLmNvbmNhdCgxIC8gdHJlZVNjYWxlLnksIFwiKSBcIik7XG4gICAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgcm90YXRlID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZSwgcm90YXRlWCA9IGxhdGVzdFRyYW5zZm9ybS5yb3RhdGVYLCByb3RhdGVZID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZVk7XG4gICAgICAgIGlmIChyb3RhdGUpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCJkZWcpIFwiKTtcbiAgICAgICAgaWYgKHJvdGF0ZVgpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCJyb3RhdGVYKFwiLmNvbmNhdChyb3RhdGVYLCBcImRlZykgXCIpO1xuICAgICAgICBpZiAocm90YXRlWSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBcInJvdGF0ZVkoXCIuY29uY2F0KHJvdGF0ZVksIFwiZGVnKSBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHNjYWxlIHRvIG1hdGNoIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IHRvIHRoZSBzaXplIHdlIHdhbnQgaXQuXG4gICAgICogVGhpcyB3aWxsIGFwcGx5IHNjYWxlIHRvIHRoZSBlbGVtZW50LW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICB2YXIgZWxlbWVudFNjYWxlWCA9IGRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICB2YXIgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICB0cmFuc2Zvcm0gKz0gXCJzY2FsZShcIi5jb25jYXQoZWxlbWVudFNjYWxlWCwgXCIsIFwiKS5jb25jYXQoZWxlbWVudFNjYWxlWSwgXCIpXCIpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPT09IGlkZW50aXR5UHJvamVjdGlvbiA/IFwibm9uZVwiIDogdHJhbnNmb3JtO1xufVxuXG52YXIgY29tcGFyZUJ5RGVwdGggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmRlcHRoIC0gYi5kZXB0aDtcbn07XG5cbnZhciBGbGF0VHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGbGF0VHJlZSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgRmxhdFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuICAgIEZsYXRUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmVtb3ZlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgfTtcbiAgICBGbGF0VHJlZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmlzRGlydHkgJiYgdGhpcy5jaGlsZHJlbi5zb3J0KGNvbXBhcmVCeURlcHRoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gRmxhdFRyZWU7XG59KCkpO1xuXG4vKipcbiAqIFdlIHVzZSAxMDAwIGFzIHRoZSBhbmltYXRpb24gdGFyZ2V0IGFzIDAtMTAwMCBtYXBzIGJldHRlciB0byBwaXhlbHMgdGhhbiAwLTFcbiAqIHdoaWNoIGhhcyBhIG5vdGljZWFibGUgZGlmZmVyZW5jZSBpbiBzcHJpbmcgYW5pbWF0aW9uc1xuICovXG52YXIgYW5pbWF0aW9uVGFyZ2V0ID0gMTAwMDtcbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3Rpb25Ob2RlKF9hKSB7XG4gICAgdmFyIGF0dGFjaFJlc2l6ZUxpc3RlbmVyID0gX2EuYXR0YWNoUmVzaXplTGlzdGVuZXIsIGRlZmF1bHRQYXJlbnQgPSBfYS5kZWZhdWx0UGFyZW50LCBtZWFzdXJlU2Nyb2xsID0gX2EubWVhc3VyZVNjcm9sbCwgY2hlY2tJc1Njcm9sbFJvb3QgPSBfYS5jaGVja0lzU2Nyb2xsUm9vdCwgcmVzZXRUcmFuc2Zvcm0gPSBfYS5yZXNldFRyYW5zZm9ybTtcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9qZWN0aW9uTm9kZShpZCwgbGF0ZXN0VmFsdWVzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAobGF0ZXN0VmFsdWVzID09PSB2b2lkIDApIHsgbGF0ZXN0VmFsdWVzID0ge307IH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBkZWZhdWx0UGFyZW50ID09PSBudWxsIHx8IGRlZmF1bHRQYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRQYXJlbnQoKTsgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIFNldCBjb250YWluaW5nIGFsbCB0aGlzIGNvbXBvbmVudCdzIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgdG8gaXRlcmF0ZVxuICAgICAgICAgICAgICogdGhyb3VnaCB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogVGhpcyBjb3VsZCBiZSBmYXN0ZXIgdG8gaXRlcmF0ZSBhcyBhIGZsYXQgYXJyYXkgc3RvcmVkIG9uIHRoZSByb290IG5vZGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9wdGlvbnMgZm9yIHRoZSBub2RlLiBXZSB1c2UgdGhpcyB0byBjb25maWd1cmUgd2hhdCBraW5kIG9mIGxheW91dCBhbmltYXRpb25zXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgcGVyZm9ybSAoaWYgYW55KS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHVzZSB0aGlzIHRvIGRldGVjdCB3aGVuIGl0cyBzYWZlIHRvIHNodXQgZG93biBwYXJ0IG9mIGEgcHJvamVjdGlvbiB0cmVlLlxuICAgICAgICAgICAgICogV2UgaGF2ZSB0byBrZWVwIHByb2plY3RpbmcgY2hpbGRyZW4gZm9yIHNjYWxlIGNvcnJlY3Rpb24gYW5kIHJlbGF0aXZlIHByb2plY3Rpb25cbiAgICAgICAgICAgICAqIHVudGlsIGFsbCB0aGVpciBwYXJlbnRzIHN0b3AgcGVyZm9ybWluZyBsYXlvdXQgYW5pbWF0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gdHJ1ZSBpZiB3ZSB0aGluayB0aGlzIGxheW91dCBoYXMgYmVlbiBjaGFuZ2VkLiBXZSBjYW4ndCBhbHdheXMga25vdyB0aGlzLFxuICAgICAgICAgICAgICogY3VycmVudGx5IHdlIHNldCBpdCB0byB0cnVlIGV2ZXJ5IHRpbWUgYSBjb21wb25lbnQgcmVuZGVycywgb3IgaWYgaXQgaGFzIGEgbGF5b3V0RGVwZW5kZW5jeVxuICAgICAgICAgICAgICogaWYgdGhhdCBoYXMgY2hhbmdlZCBiZXR3ZWVuIHJlbmRlcnMuIEFkZGl0aW9uYWxseSwgY29tcG9uZW50cyBjYW4gYmUgZ3JvdXBlZCBieSBMYXlvdXRHcm91cFxuICAgICAgICAgICAgICogYW5kIGlmIG9uZSBub2RlIGlzIGRpcnRpZWQsIHRoZXkgYWxsIGFyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJsb2NrIGxheW91dCB1cGRhdGVzIGZvciBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9ucyB0aHJvdWdob3V0IHRoZSB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRvIHRydWUgYmV0d2VlbiB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGB3aWxsVXBkYXRlYCBjYWxsIGFuZCB0aGUgZW5kIG9mIHRoZSBgZGlkVXBkYXRlYFxuICAgICAgICAgICAgICogY2FsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gU1ZHIGVsZW1lbnQgd2UgY3VycmVudGx5IGRpc2FibGUgcHJvamVjdGlvbiB0cmFuc2Zvcm1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIChkdXJpbmcgcHJvbW90aW9uKSBpZiBhIG5vZGUgZG9pbmcgYW4gaW5zdGFudCBsYXlvdXQgdHJhbnNpdGlvbiBuZWVkcyB0byByZXNldFxuICAgICAgICAgICAgICogaXRzIHByb2plY3Rpb24gc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZ3Mgd2hldGhlciB0aGlzIG5vZGUgc2hvdWxkIGhhdmUgaXRzIHRyYW5zZm9ybSByZXNldCBwcmlvciB0byBtZWFzdXJpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY2FsY3VsYXRlZCBjb250ZXh0dWFsL2FjY3VtdWxhdGVkL3RyZWUgc2NhbGUuXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYmUgdXNlZCB0byBzY2FsZSBjYWxjdWxjYXRlZCBwcm9qZWN0aW9uIHRyYW5zZm9ybXMsIGFzIHRoZXNlIGFyZVxuICAgICAgICAgICAgICogY2FsY3VsYXRlZCBpbiBzY3JlZW4tc3BhY2UgYnV0IG5lZWQgdG8gYmUgc2NhbGVkIGZvciBlbGVtZW50cyB0byBhY3R1YWxseVxuICAgICAgICAgICAgICogbWFrZSBpdCB0byB0aGVpciBjYWxjdWxhdGVkIGRlc3RpbmF0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBMYXp5LWluaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVXBkYXRlRmFpbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2gocmVzb2x2ZVRhcmdldERlbHRhKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5mb3JFYWNoKGNhbGNQcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNoYXJlZCBsYXlvdXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyBPbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCB8fCBwYXJlbnQgOiB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGFyZW50ID8gdHNsaWIuX19zcHJlYWRBcnJheSh0c2xpYi5fX3NwcmVhZEFycmF5KFtdLCB0c2xpYi5fX3JlYWQocGFyZW50LnBhdGgpLCBmYWxzZSksIFtwYXJlbnRdLCBmYWxzZSkgOiBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgICAgICAgaWQgJiYgdGhpcy5yb290LnJlZ2lzdGVyUG90ZW50aWFsTm9kZShpZCwgdGhpcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aFtpXS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSBuZXcgRmxhdFRyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMuc2V0KG5hbWUsIG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSkuYWRkKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUubm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uTWFuYWdlciA9IHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NYW5hZ2VyID09PSBudWxsIHx8IHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbk1hbmFnZXIubm90aWZ5LmFwcGx5KHN1YnNjcmlwdGlvbk1hbmFnZXIsIHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlZ2lzdGVyUG90ZW50aWFsTm9kZSA9IGZ1bmN0aW9uIChpZCwgbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5zZXQoaWQsIG5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlmZWN5Y2xlc1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBpc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0RGlydHkgPT09IHZvaWQgMCkgeyBpc0xheW91dERpcnR5ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPVxuICAgICAgICAgICAgICAgIGluc3RhbmNlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBpbnN0YW5jZS50YWdOYW1lICE9PSBcInN2Z1wiO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBsYXlvdXRJZCA9IF9iLmxheW91dElkLCBsYXlvdXQgPSBfYi5sYXlvdXQsIHZpc3VhbEVsZW1lbnQgPSBfYi52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgIXZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pZCAmJiB0aGlzLnJvb3QucG90ZW50aWFsTm9kZXMuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0RGlydHkgJiYgKGxheW91dCB8fCBsYXlvdXRJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dGFjaFJlc2l6ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuYmxvY2tUaW1lb3V0XzE7XG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZVVuYmxvY2tVcGRhdGVfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyKGluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHVuYmxvY2tUaW1lb3V0XzEpO1xuICAgICAgICAgICAgICAgICAgICB1bmJsb2NrVGltZW91dF8xID0gd2luZG93LnNldFRpbWVvdXQocmVzaXplVW5ibG9ja1VwZGF0ZV8xLCAyNTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5mb3JFYWNoKGZpbmlzaEFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSByZWdpc3RlciB0aGUgaGFuZGxlciBpZiBpdCByZXF1aXJlcyBsYXlvdXQgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIChsYXlvdXRJZCB8fCBsYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBfYS5kZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCA9IF9hLmhhc0xheW91dENoYW5nZWQsIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IF9hLmhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCwgbmV3TGF5b3V0ID0gX2EubGF5b3V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBoZXJlIGlmIGFuIGFuaW1hdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dFRyYW5zaXRpb24gPSAoX2MgPSAoX2IgPSBfdGhpcy5vcHRpb25zLnRyYW5zaXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdExheW91dFRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKSwgb25MYXlvdXRBbmltYXRpb25TdGFydCA9IF9nLm9uTGF5b3V0QW5pbWF0aW9uU3RhcnQsIG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUgPSBfZy5vbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHRhcmdldCBsYXlvdXQgb2YgdGhlIGVsZW1lbnQgbWlnaHQgc3RheSB0aGUgc2FtZSxcbiAgICAgICAgICAgICAgICAgICAgICogYnV0IGl0cyBwb3NpdGlvbiByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldENoYW5nZWQgPSAhX3RoaXMudGFyZ2V0TGF5b3V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhYm94RXF1YWxzKF90aGlzLnRhcmdldExheW91dCwgbmV3TGF5b3V0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGxheW91dCBoYXNuJ3Qgc2VlbWVkIHRvIGhhdmUgY2hhbmdlZCwgaXQgbWlnaHQgYmUgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogZWxlbWVudCBpcyB2aXN1YWxseSBpbiB0aGUgc2FtZSBwbGFjZSBpbiB0aGUgZG9jdW1lbnQgYnV0IGl0cyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGhhcyBpbmRlZWQgY2hhbmdlZC4gU28gaGVyZSB3ZSBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gIWhhc0xheW91dENoYW5nZWQgJiYgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKChfZCA9IF90aGlzLnJlc3VtZUZyb20pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChoYXNMYXlvdXRDaGFuZ2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldENoYW5nZWQgfHwgIV90aGlzLmN1cnJlbnRBbmltYXRpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bWluZ0Zyb20gPSBfdGhpcy5yZXN1bWVGcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtaW5nRnJvbS5yZXN1bWluZ0Zyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZ2V0VmFsdWVUcmFuc2l0aW9uKGxheW91dFRyYW5zaXRpb24sIFwibGF5b3V0XCIpKSwgeyBvblBsYXk6IG9uTGF5b3V0QW5pbWF0aW9uU3RhcnQsIG9uQ29tcGxldGU6IG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLnR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0QW5pbWF0aW9uKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBjaGFuZ2VkIGFuZCB3ZSBoYXZlIGFuIGFuaW1hdGlvbiB0aGF0IGhhc24ndCBzdGFydGVkIHlldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGZpbmlzaCBpdCBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgYW5pbWF0aW5nIGZyb20gYSBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhdCB3YXMgcHJvYmFibHkgbmV2ZXIgY29tbWl0ZWQgdG8gc2NyZWVuIGFuZCBsb29rIGxpa2UgYSBqdW1weSBib3guXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzTGF5b3V0Q2hhbmdlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvblByb2dyZXNzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmluaXNoQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xlYWQoKSAmJiAoKF9mID0gKF9lID0gX3RoaXMub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGFyZ2V0TGF5b3V0ID0gbmV3TGF5b3V0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0SWQgJiYgdGhpcy53aWxsVXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGlsZHJlbi5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3luYy5jYW5jZWxTeW5jLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvbmx5IG9uIHRoZSByb290XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5ibG9ja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnVuYmxvY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaXNVcGRhdGVCbG9ja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkIHx8IHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgfHxcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHx8XG4gICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc3RhcnRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1VwZGF0ZUJsb2NrZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5ub2RlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2gocmVzZXRSb3RhdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS53aWxsVXBkYXRlID0gZnVuY3Rpb24gKHNob3VsZE5vdGlmeUxpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5TGlzdGVuZXJzID09PSB2b2lkIDApIHsgc2hvdWxkTm90aWZ5TGlzdGVuZXJzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5pc1VwZGF0ZUJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhdGhpcy5yb290LmlzVXBkYXRpbmcgJiYgdGhpcy5yb290LnN0YXJ0VXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIG5vZGUuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRPRE86IENoZWNrIHdlIGhhdmVuJ3QgdXBkYXRlZCB0aGUgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICogc2luY2UgdGhlIGxhc3QgZGlkVXBkYXRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZCA9IHRoaXMub3B0aW9ucywgbGF5b3V0SWQgPSBfZC5sYXlvdXRJZCwgbGF5b3V0ID0gX2QubGF5b3V0O1xuICAgICAgICAgICAgaWYgKGxheW91dElkID09PSB1bmRlZmluZWQgJiYgIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2MgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGUgPT09IG51bGwgfHwgdHJhbnNmb3JtVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgIHNob3VsZE5vdGlmeUxpc3RlbmVycyAmJiB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIndpbGxVcGRhdGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5kaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlV2FzQmxvY2tlZCA9IHRoaXMuaXNVcGRhdGVCbG9ja2VkKCk7XG4gICAgICAgICAgICAvLyBXaGVuIGRvaW5nIGFuIGluc3RhbnQgdHJhbnNpdGlvbiwgd2Ugc2tpcCB0aGUgbGF5b3V0IHVwZGF0ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBzaG91bGQgc3RpbGwgY2xlYW4gdXAgdGhlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBzbmFwc2hvdCBjb3VsZCBiZSB0YWtlbiBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAodXBkYXRlV2FzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5ibG9ja1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1VwZGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWFyY2ggZm9yIGFuZCBtb3VudCBuZXdseS1hZGRlZCBwcm9qZWN0aW9uIGVsZW1lbnRzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IEV2ZXJ5IHRpbWUgYSBuZXcgY29tcG9uZW50IGlzIHJlbmRlcmVkIHdlIGNvdWxkIHNlYXJjaCB1cCB0aGUgdHJlZSBmb3JcbiAgICAgICAgICAgICAqIHRoZSBjbG9zZXN0IG1vdW50ZWQgbm9kZSBhbmQgcXVlcnkgZnJvbSB0aGVyZSByYXRoZXIgdGhhbiBkb2N1bWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG90ZW50aWFsTm9kZXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuZm9yRWFjaChtb3VudE5vZGVFYXJseSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gocmVzZXRUcmFuc2Zvcm1TdHlsZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlYWQgPT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXlvdXQgbWVhc3VyZW1lbnRzIG9mIHVwZGF0ZWQgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCh1cGRhdGVMYXlvdXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIHRoYXQgdGhlIGxheW91dCBpcyB1cGRhdGVkXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobm90aWZ5TGF5b3V0VXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgIC8vIEZsdXNoIGFueSBzY2hlZHVsZWQgdXBkYXRlc1xuICAgICAgICAgICAgc3luYy5mbHVzaFN5bmMudXBkYXRlKCk7XG4gICAgICAgICAgICBzeW5jLmZsdXNoU3luYy5wcmVSZW5kZXIoKTtcbiAgICAgICAgICAgIHN5bmMuZmx1c2hTeW5jLnJlbmRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY2xlYXJBbGxTbmFwc2hvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJTbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLmZvckVhY2gocmVtb3ZlTGVhZFNuYXBzaG90cyk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wcmVSZW5kZXIodGhpcy51cGRhdGVQcm9qZWN0aW9uLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHVubW91bnRpbmcgbm9kZSBpcyBpbiBhIGxheW91dEdyb3VwIGFuZCBkaWQgdHJpZ2dlciBhIHdpbGxVcGRhdGUsXG4gICAgICAgICAgICAgKiB3ZSBtYW51YWxseSBjYWxsIGRpZFVwZGF0ZSB0byBnaXZlIGEgY2hhbmNlIHRvIHRoZSBzaWJsaW5ncyB0byBhbmltYXRlLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlLCBjbGVhbnVwIGFsbCBzbmFwc2hvdHMgdG8gcHJldmVudHMgZnV0dXJlIG5vZGVzIGZyb20gcmV1c2luZyB0aGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5wb3N0UmVuZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucm9vdC5jaGVja1VwZGF0ZUZhaWxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIG1lYXN1cmVtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnVwZGF0ZVNuYXBzaG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc25hcHNob3QgfHwgIXRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG1lYXN1cmVkID0gdGhpcy5tZWFzdXJlKCk7XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5yZW1vdmVUcmFuc2Zvcm0odGhpcy5yZW1vdmVFbGVtZW50U2Nyb2xsKG1lYXN1cmVkKSk7XG4gICAgICAgICAgICByb3VuZEJveChsYXlvdXQpO1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlZDogbWVhc3VyZWQsXG4gICAgICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gVE9ETzogSW5jb3Jwb3JhdGUgaW50byBhIGZvcndhcmRlZCBzY3JvbGwgb2Zmc2V0XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmFsd2F5c01lYXN1cmVMYXlvdXQgJiYgdGhpcy5pc0xlYWQoKSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIGEgbm9kZSBpcyBtb3VudGVkLCBpdCBzaW1wbHkgcmVzdW1lcyBmcm9tIHRoZSBwcmV2TGVhZCdzXG4gICAgICAgICAgICAgKiBzbmFwc2hvdCBpbnN0ZWFkIG9mIHRha2luZyBhIG5ldyBvbmUsIGJ1dCB0aGUgYW5jZXN0b3JzIHNjcm9sbFxuICAgICAgICAgICAgICogbWlnaHQgaGF2ZSB1cGRhdGVkIHdoaWxlIHRoZSBwcmV2TGVhZCBpcyB1bm1vdW50ZWQuIFdlIG5lZWQgdG9cbiAgICAgICAgICAgICAqIHVwZGF0ZSB0aGUgc2Nyb2xsIGFnYWluIHRvIG1ha2Ugc3VyZSB0aGUgbGF5b3V0IHdlIG1lYXN1cmUgaXNcbiAgICAgICAgICAgICAqIHVwIHRvIGRhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtZUZyb20gJiYgIXRoaXMucmVzdW1lRnJvbS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtZWFzdXJlZCA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICAgICAgcm91bmRCb3gobWVhc3VyZWQpO1xuICAgICAgICAgICAgdmFyIHByZXZMYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0ge1xuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiBtZWFzdXJlZCxcbiAgICAgICAgICAgICAgICBhY3R1YWw6IHRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChtZWFzdXJlZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDb3JyZWN0ZWQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIm1lYXN1cmVcIiwgdGhpcy5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm90aWZ5TGF5b3V0TWVhc3VyZSh0aGlzLmxheW91dC5hY3R1YWwsIHByZXZMYXlvdXQgPT09IG51bGwgfHwgcHJldkxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkxheW91dC5hY3R1YWwpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudXBkYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxSb290ID0gY2hlY2tJc1Njcm9sbFJvb3QodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwgPSBtZWFzdXJlU2Nyb2xsKHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXJlc2V0VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc1Jlc2V0UmVxdWVzdGVkID0gdGhpcy5pc0xheW91dERpcnR5IHx8IHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm07XG4gICAgICAgICAgICB2YXIgaGFzUHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbkRlbHRhICYmICFpc0RlbHRhWmVybyh0aGlzLnByb2plY3Rpb25EZWx0YSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlID09PSBudWxsIHx8IHRyYW5zZm9ybVRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIik7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkID0gdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSAhPT0gdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1Jlc2V0UmVxdWVzdGVkICYmXG4gICAgICAgICAgICAgICAgKGhhc1Byb2plY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSB8fFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQpKSB7XG4gICAgICAgICAgICAgICAgcmVzZXRUcmFuc2Zvcm0odGhpcy5pbnN0YW5jZSwgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLm1lYXN1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlzdWFsRWxlbWVudCA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIHZhciBib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHZpZXdwb3J0IHNjcm9sbCB0byBnaXZlIHBhZ2UtcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHZhciBzY3JvbGwgPSB0aGlzLnJvb3Quc2Nyb2xsO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LngsIHNjcm9sbC54KTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC55LCBzY3JvbGwueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94O1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVtb3ZlRWxlbWVudFNjcm9sbCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICAgICAgICAgIHZhciBib3hXaXRob3V0U2Nyb2xsID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQZXJmb3JtYW5jZSBUT0RPOiBLZWVwIGEgY3VtdWxhdGl2ZSBzY3JvbGwgb2Zmc2V0IGRvd24gdGhlIHRyZWVcbiAgICAgICAgICAgICAqIHJhdGhlciB0aGFuIGxvb3AgYmFjayB1cCB0aGUgcGF0aC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsXzEgPSBub2RlLnNjcm9sbCwgb3B0aW9ucyA9IG5vZGUub3B0aW9ucywgaXNTY3JvbGxSb290ID0gbm9kZS5pc1Njcm9sbFJvb3Q7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMucm9vdCAmJiBzY3JvbGxfMSAmJiBvcHRpb25zLmxheW91dFNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIG5ldyBzY3JvbGwgcm9vdCwgd2Ugd2FudCB0byByZW1vdmUgYWxsIHByZXZpb3VzIHNjcm9sbHNcbiAgICAgICAgICAgICAgICAgICAgICogZnJvbSB0aGUgdmlld3BvcnQgYm94LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290U2Nyb2xsID0gdGhpcy5yb290LnNjcm9sbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVW5kbyB0aGUgYXBwbGljYXRpb24gb2YgcGFnZSBzY3JvbGwgdGhhdCB3YXMgb3JpZ2luYWxseSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogdG8gdGhlIG1lYXN1cmVkIGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgLXJvb3RTY3JvbGwueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIC1yb290U2Nyb2xsLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCBzY3JvbGxfMS54KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIHNjcm9sbF8xLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3hXaXRob3V0U2Nyb2xsO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYm94LCB0cmFuc2Zvcm1Pbmx5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtT25seSA9PT0gdm9pZCAwKSB7IHRyYW5zZm9ybU9ubHkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byh3aXRoVHJhbnNmb3JtcywgYm94KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Pbmx5ICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogLW5vZGUuc2Nyb2xsLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwueSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3JtcywgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhUcmFuc2Zvcm1zO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVtb3ZlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGJveCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGJveFdpdGhvdXRUcmFuc2Zvcm0gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRUcmFuc2Zvcm0sIGJveCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBoYXNTY2FsZShub2RlLmxhdGVzdFZhbHVlcykgJiYgbm9kZS51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VCb3ggPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUJveCA9IG5vZGUubWVhc3VyZSgpO1xuICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHNvdXJjZUJveCwgbm9kZUJveCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCBub2RlLmxhdGVzdFZhbHVlcywgKF9hID0gbm9kZS5zbmFwc2hvdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dCwgc291cmNlQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFRyYW5zZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc2V0VGFyZ2V0RGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpLCB7IGNyb3NzZmFkZTogKF9hID0gb3B0aW9ucy5jcm9zc2ZhZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5jbGVhck1lYXN1cmVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRnJhbWUgY2FsY3VsYXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzb2x2ZVRhcmdldERlbHRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBsYXlvdXQgPSBfYi5sYXlvdXQsIGxheW91dElkID0gX2IubGF5b3V0SWQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gbGF5b3V0LCB3ZSBjYW4ndCBwZXJmb3JtIHByb2plY3Rpb24sIHNvIGVhcmx5IHJldHVyblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGRvbid0IGhhdmUgYSB0YXJnZXREZWx0YSBidXQgZG8gaGF2ZSBhIGxheW91dCwgd2UgY2FuIGF0dGVtcHQgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICogYSByZWxhdGl2ZVBhcmVudC4gVGhpcyB3aWxsIGFsbG93IGEgY29tcG9uZW50IHRvIHBlcmZvcm0gc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICogZXZlbiBpZiBubyBhbmltYXRpb24gaGFzIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIFRPRE8gSWYgdGhpcyBpcyB1bnN1Y2Nlc3NmdWwgdGhpcyBjdXJyZW50bHkgaGFwcGVucyBldmVyeSBmcmFtZVxuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldERlbHRhICYmICF0aGlzLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIHNlbWktcmVwZXRpdGlvbiBvZiBmdXJ0aGVyIGRvd24gdGhpcyBmdW5jdGlvbiwgbWFrZSBEUllcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlUGFyZW50ICYmIHRoaXMucmVsYXRpdmVQYXJlbnQubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLmxheW91dC5hY3R1YWwsIHRoaXMucmVsYXRpdmVQYXJlbnQubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyByZWxhdGl2ZSB0YXJnZXQgb3Igbm8gdGFyZ2V0IGRlbHRhIG91ciB0YXJnZXQgaXNuJ3QgdmFsaWRcbiAgICAgICAgICAgICAqIGZvciB0aGlzIGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVUYXJnZXQgJiYgIXRoaXMudGFyZ2V0RGVsdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMYXp5LWluaXQgdGFyZ2V0IGRhdGEgc3RydWN0dXJlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UndmUgZ290IGEgcmVsYXRpdmUgYm94IGZvciB0aGlzIGNvbXBvbmVudCwgcmVzb2x2ZSBpdCBpbnRvIGEgdGFyZ2V0IHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnJlbGF0aXZlUGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZUJveCh0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3ZlIG9ubHkgZ290IGEgdGFyZ2V0RGVsdGEsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXREZWx0YSkge1xuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0odGhpcy5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseUJveERlbHRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldERlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG5vIHRhcmdldCwgdXNlIG93biBsYXlvdXQgYXMgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gdG9sZCB0byBhdHRlbXB0IHRvIHJlc29sdmUgYSByZWxhdGl2ZSB0YXJnZXQsIGRvIHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbih0aGlzLnJlbGF0aXZlUGFyZW50LnJlc3VtaW5nRnJvbSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5yZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy50YXJnZXQsIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8IGhhc1RyYW5zZm9ybSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRoaXMucGFyZW50LnJlbGF0aXZlVGFyZ2V0IHx8IHRoaXMucGFyZW50LnRhcmdldERlbHRhKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY2FsY1Byb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGxheW91dCA9IF9iLmxheW91dCwgbGF5b3V0SWQgPSBfYi5sYXlvdXRJZDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBzZWN0aW9uIG9mIHRoZSB0cmVlIGlzbid0IGFuaW1hdGluZyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGRlbGV0ZSBvdXIgdGFyZ2V0IHNvdXJjZXMgZm9yIHRoZSBmb2xsb3dpbmcgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gQm9vbGVhbigoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RyZWVBbmltYXRpbmcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RyZWVBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc2V0IHRoZSBjb3JyZWN0ZWQgYm94IHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBib3gsIGFzIHdlJ3JlIHRoZW4gZ29pbmdcbiAgICAgICAgICAgICAqIHRvIHBlcmZvcm0gbXV0YXRpdmUgb3BlcmF0aW9ucyBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29weUJveEludG8odGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGx5IGFsbCB0aGUgcGFyZW50IGRlbHRhcyB0byB0aGlzIGJveCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0ZWQgYm94LiBUaGlzXG4gICAgICAgICAgICAgKiBpcyB0aGUgbGF5b3V0IGJveCwgYXMgaXQgd2lsbCBhcHBlYXIgb24gc2NyZWVuIGFzIGEgcmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1zIG9mIGl0cyBwYXJlbnRzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhcHBseVRyZWVEZWx0YXModGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMudHJlZVNjYWxlLCB0aGlzLnBhdGgsIEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGxlYWQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0gPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZUcmVlU2NhbGVYID0gdGhpcy50cmVlU2NhbGUueDtcbiAgICAgICAgICAgIHZhciBwcmV2VHJlZVNjYWxlWSA9IHRoaXMudHJlZVNjYWxlLnk7XG4gICAgICAgICAgICB2YXIgcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gPSB0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIHRhcmdldCBib3ggYmVmb3JlIHVzZXItc2V0IHRyYW5zZm9ybXMgd2VyZSBhcHBsaWVkLlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGFsbG93IHVzIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdGVkIGJvcmRlclJhZGl1cyBhbmQgYm94U2hhZG93IHRvIGNvbXBlbnNhdGVcbiAgICAgICAgICAgICAqIGZvciBvdXIgbGF5b3V0IHJlcHJvamVjdGlvbiwgYnV0IHN0aWxsIGFsbG93IHRoZW0gdG8gYmUgc2NhbGVkIGNvcnJlY3RseSBieSB0aGUgdXNlci5cbiAgICAgICAgICAgICAqIEl0IG1pZ2h0IGJlIHRoYXQgdG8gc2ltcGxpZnkgdGhpcyB3ZSBtYXkgd2FudCB0byBhY2NlcHQgdGhhdCB1c2VyLXNldCBzY2FsZSBpcyBhbHNvIGNvcnJlY3RlZFxuICAgICAgICAgICAgICogYW5kIHdlIHdvdWxkbid0IGhhdmUgdG8ga2VlcCBhbmQgY2FsYyBib3RoIGRlbHRhcywgT1Igd2UgY291bGQgc3VwcG9ydCBhIHVzZXIgc2V0dGluZ1xuICAgICAgICAgICAgICogdG8gYWxsb3cgcGVvcGxlIHRvIGNob29zZSB3aGV0aGVyIHRoZXNlIHN0eWxlcyBhcmUgY29ycmVjdGVkIGJhc2VkIG9uIGp1c3QgdGhlXG4gICAgICAgICAgICAgKiBsYXlvdXQgcmVwcm9qZWN0aW9uIG9yIHRoZSBmaW5hbCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldCwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhLCB0aGlzLnRyZWVTY2FsZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtICE9PSBwcmV2UHJvamVjdGlvblRyYW5zZm9ybSB8fFxuICAgICAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlLnggIT09IHByZXZUcmVlU2NhbGVYIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUueSAhPT0gcHJldlRyZWVTY2FsZVkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwicHJvamVjdGlvblVwZGF0ZVwiLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2hlZHVsZSByZW5kZXJcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2hlZHVsZSByZW5kZXJcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNjaGVkdWxlUmVuZGVyID0gZnVuY3Rpb24gKG5vdGlmeUFsbCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAobm90aWZ5QWxsID09PSB2b2lkIDApIHsgbm90aWZ5QWxsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5zY2hlZHVsZVJlbmRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICAgICAgbm90aWZ5QWxsICYmICgoX2MgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zY2hlZHVsZVJlbmRlcigpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSAmJiAhdGhpcy5yZXN1bWluZ0Zyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNldEFuaW1hdGlvbk9yaWdpbiA9IGZ1bmN0aW9uIChkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID09PSB2b2lkIDApIHsgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90TGF0ZXN0VmFsdWVzID0gKHNuYXBzaG90ID09PSBudWxsIHx8IHNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbmFwc2hvdC5sYXRlc3RWYWx1ZXMpIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG1peGVkVmFsdWVzID0gdHNsaWIuX19hc3NpZ24oe30sIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gIWhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIHZhciBpc1NoYXJlZExheW91dEFuaW1hdGlvbiA9IHNuYXBzaG90ID09PSBudWxsIHx8IHNuYXBzaG90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbmFwc2hvdC5pc1NoYXJlZDtcbiAgICAgICAgICAgIHZhciBpc09ubHlNZW1iZXIgPSAoKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lbWJlcnMubGVuZ3RoKSB8fCAwKSA8PSAxO1xuICAgICAgICAgICAgdmFyIHNob3VsZENyb3NzZmFkZU9wYWNpdHkgPSBCb29sZWFuKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzT25seU1lbWJlciAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jcm9zc2ZhZGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wYXRoLnNvbWUoaGFzT3BhY2l0eUNyb3NzZmFkZSkpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhID0gZnVuY3Rpb24gKGxhdGVzdCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBsYXRlc3QgLyAxMDAwO1xuICAgICAgICAgICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS54LCBkZWx0YS54LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLnksIGRlbHRhLnksIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUYXJnZXREZWx0YSh0YXJnZXREZWx0YSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxheW91dCAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gX3RoaXMucmVsYXRpdmVQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlTGF5b3V0LCBfdGhpcy5sYXlvdXQuYWN0dWFsLCBfdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWl4Qm94KF90aGlzLnJlbGF0aXZlVGFyZ2V0LCBfdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgcmVsYXRpdmVMYXlvdXQsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvblZhbHVlcyA9IG1peGVkVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICBtaXhWYWx1ZXMobWl4ZWRWYWx1ZXMsIHNuYXBzaG90TGF0ZXN0VmFsdWVzLCBfdGhpcy5sYXRlc3RWYWx1ZXMsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKDApO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc3RhcnRBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvblN0YXJ0XCIpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzeW5jLmNhbmNlbFN5bmMudXBkYXRlKHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uIGluIHRoZSBuZXh0IGZyYW1lIHRvIGhhdmUgYSBmcmFtZSB3aXRoIHByb2dyZXNzIDAsXG4gICAgICAgICAgICAgKiB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydGVkLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIGNvcnJlY3RseSBmb3IgaW5zdGFudCB0cmFuc2l0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0udXBkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGUoMCwgYW5pbWF0aW9uVGFyZ2V0LCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgb25VcGRhdGU6IGZ1bmN0aW9uIChsYXRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1peFRhcmdldERlbHRhKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBsYXRlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IF90aGlzLmN1cnJlbnRBbmltYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmNvbXBsZXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5wcmVzZXJ2ZU9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leGl0QW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvbkNvbXBsZXRlXCIpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZmluaXNoQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubWl4VGFyZ2V0RGVsdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGFuaW1hdGlvblRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRMZWFkKCksIHRhcmdldFdpdGhUcmFuc2Zvcm1zID0gX2EudGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCA9IF9hLnRhcmdldCwgbGF5b3V0ID0gX2EubGF5b3V0LCBsYXRlc3RWYWx1ZXMgPSBfYS5sYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFdpdGhUcmFuc2Zvcm1zIHx8ICF0YXJnZXQgfHwgIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb3B5Qm94SW50byh0YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgdGhlIGxhdGVzdCB1c2VyLXNldCB0cmFuc2Zvcm1zIHRvIHRoZSB0YXJnZXRCb3ggdG8gcHJvZHVjZSB0aGUgdGFyZ2V0Qm94RmluYWwuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRoZSBmaW5hbCBib3ggdGhhdCB3ZSB3aWxsIHRoZW4gcHJvamVjdCBpbnRvIGJ5IGNhbGN1bGF0aW5nIGEgdHJhbnNmb3JtIGRlbHRhIGFuZFxuICAgICAgICAgICAgICogYXBwbHlpbmcgaXQgdG8gdGhlIGNvcnJlY3RlZCBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyYW5zZm9ybUJveCh0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjb3JyZWN0ZWQgYm94IGFuZCB0aGUgZmluYWwgdGFyZ2V0IGJveCwgYWZ0ZXJcbiAgICAgICAgICAgICAqIHVzZXItc2V0IHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoaXMgd2lsbCBiZSB1c2VkIGJ5IHRoZSByZW5kZXJlciB0b1xuICAgICAgICAgICAgICogY3JlYXRlIGEgdHJhbnNmb3JtIHN0eWxlIHRoYXQgd2lsbCByZXByb2plY3QgdGhlIGVsZW1lbnQgZnJvbSBpdHMgYWN0dWFsIGxheW91dFxuICAgICAgICAgICAgICogaW50byB0aGUgZGVzaXJlZCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlZ2lzdGVyU2hhcmVkTm9kZSA9IGZ1bmN0aW9uIChsYXlvdXRJZCwgbm9kZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVkTm9kZXMuaGFzKGxheW91dElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMuc2V0KGxheW91dElkLCBuZXcgTm9kZVN0YWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zaGFyZWROb2Rlcy5nZXQobGF5b3V0SWQpO1xuICAgICAgICAgICAgc3RhY2suYWRkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5wcm9tb3RlKHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAoX2EgPSBub2RlLm9wdGlvbnMuaW5pdGlhbFByb21vdGlvbkNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgcHJlc2VydmVGb2xsb3dPcGFjaXR5OiAoX2MgPSAoX2IgPSBub2RlLm9wdGlvbnMuaW5pdGlhbFByb21vdGlvbkNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIG5vZGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5pc0xlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2sgPyBzdGFjay5sZWFkID09PSB0aGlzIDogdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldExlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgbGF5b3V0SWQgPSB0aGlzLm9wdGlvbnMubGF5b3V0SWQ7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0SWQgPyAoKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVhZCkgfHwgdGhpcyA6IHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRQcmV2TGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRJZCA9IHRoaXMub3B0aW9ucy5sYXlvdXRJZDtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/IChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXZMZWFkIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0SWQgPSB0aGlzLm9wdGlvbnMubGF5b3V0SWQ7XG4gICAgICAgICAgICBpZiAobGF5b3V0SWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5zaGFyZWROb2Rlcy5nZXQobGF5b3V0SWQpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucHJvbW90ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG5lZWRzUmVzZXQgPSBfYi5uZWVkc1Jlc2V0LCB0cmFuc2l0aW9uID0gX2IudHJhbnNpdGlvbiwgcHJlc2VydmVGb2xsb3dPcGFjaXR5ID0gX2IucHJlc2VydmVGb2xsb3dPcGFjaXR5O1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgaWYgKHN0YWNrKVxuICAgICAgICAgICAgICAgIHN0YWNrLnByb21vdGUodGhpcywgcHJlc2VydmVGb2xsb3dPcGFjaXR5KTtcbiAgICAgICAgICAgIGlmIChuZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IHRyYW5zaXRpb246IHRyYW5zaXRpb24gfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZWxlZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5yZWxlZ2F0ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlc2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlzdWFsRWxlbWVudCA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZGV0ZWN0ZWQgcm90YXRpb24gdmFsdWVzLCB3ZSBjYW4gZWFybHkgcmV0dXJuIHdpdGhvdXQgYSBmb3JjZWQgcmVuZGVyLlxuICAgICAgICAgICAgdmFyIGhhc1JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gS2VlcCBhIHJlY29yZCBvZiBhbGwgdGhlIHZhbHVlcyB3ZSd2ZSByZXNldFxuICAgICAgICAgICAgdmFyIHJlc2V0VmFsdWVzID0ge307XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgcm90YXRlIHZhbHVlIG9mIGFsbCBheGVzIGFuZCByZXNldCB0byAwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybUF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHRyYW5zZm9ybUF4ZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IFwicm90YXRlXCIgKyBheGlzO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgcm90YXRpb24gZG9lc24ndCBleGlzdCBhcyBhIG1vdGlvbiB2YWx1ZSwgdGhlbiB3ZSBkb24ndFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVzZXQgaXRcbiAgICAgICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzUm90YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHJvdGF0aW9uIGFuZCB0aGVuIHRlbXBvcmFyaWx5IHNldCBpdCB0byAwXG4gICAgICAgICAgICAgICAgcmVzZXRWYWx1ZXNba2V5XSA9IHZpc3VhbEVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHJvdGF0aW9uIHZhbHVlcywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgbW9yZS5cbiAgICAgICAgICAgIGlmICghaGFzUm90YXRlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEZvcmNlIGEgcmVuZGVyIG9mIHRoaXMgZWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHdpdGggYWxsIHJvdGF0aW9uc1xuICAgICAgICAgICAgLy8gc2V0IHRvIDAuXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuc3luY1JlbmRlcigpO1xuICAgICAgICAgICAgLy8gUHV0IGJhY2sgYWxsIHRoZSB2YWx1ZXMgd2UgcmVzZXRcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiByZXNldFZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCByZXNldFZhbHVlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbmV4dCBmcmFtZS4gVGhpcyBlbnN1cmVzIHdlIHdvbid0IHZpc3VhbGx5XG4gICAgICAgICAgICAvLyBzZWUgdGhlIGVsZW1lbnQgd2l0aCB0aGUgcmVzZXQgcm90YXRlIHZhbHVlIGFwcGxpZWQuXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlUHJvcCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBpZiAoc3R5bGVQcm9wID09PSB2b2lkIDApIHsgc3R5bGVQcm9wID0ge307IH1cbiAgICAgICAgICAgIC8vIFRPRE86IFJldHVybiBsaWZlY3ljbGUtcGVyc2lzdGVudCBvYmplY3RcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSB8fCB0aGlzLmlzU1ZHKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMubmVlZHNSZXNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEgfHwgIXRoaXMubGF5b3V0IHx8ICFsZWFkLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBlbXB0eVN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMub3BhY2l0eSA9IChfYiA9IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5U3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNQcm9qZWN0ZWQgJiYgIWhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlTdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWVzVG9SZW5kZXIgPSBsZWFkLmFuaW1hdGlvblZhbHVlcyB8fCBsZWFkLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQoKTtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0odGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLnRyZWVTY2FsZSwgdmFsdWVzVG9SZW5kZXIpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlKHZhbHVlc1RvUmVuZGVyLCBzdHlsZXMudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZyA9IHRoaXMucHJvamVjdGlvbkRlbHRhLCB4ID0gX2cueCwgeSA9IF9nLnk7XG4gICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtT3JpZ2luID0gXCJcIi5jb25jYXQoeC5vcmlnaW4gKiAxMDAsIFwiJSBcIikuY29uY2F0KHkub3JpZ2luICogMTAwLCBcIiUgMFwiKTtcbiAgICAgICAgICAgIGlmIChsZWFkLmFuaW1hdGlvblZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBsZWFkIGNvbXBvbmVudCBpcyBhbmltYXRpbmcsIGFzc2lnbiB0aGlzIGVpdGhlciB0aGUgZW50ZXJpbmcvbGVhdmluZ1xuICAgICAgICAgICAgICAgICAqIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9kID0gKF9jID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByZXNlcnZlT3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBPciB3ZSdyZSBub3QgYW5pbWF0aW5nIGF0IGFsbCwgc2V0IHRoZSBsZWFkIGNvbXBvbmVudCB0byBpdHMgYWN0dWFsXG4gICAgICAgICAgICAgICAgICogb3BhY2l0eSBhbmQgb3RoZXIgY29tcG9uZW50cyB0byBoaWRkZW4uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPVxuICAgICAgICAgICAgICAgICAgICBsZWFkID09PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChfZSA9IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKF9mID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGx5IHNjYWxlIGNvcnJlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNjYWxlQ29ycmVjdG9ycykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNUb1JlbmRlcltrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBfaCA9IHNjYWxlQ29ycmVjdG9yc1trZXldLCBjb3JyZWN0ID0gX2guY29ycmVjdCwgYXBwbHlUbyA9IF9oLmFwcGx5VG87XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJlY3RlZCA9IGNvcnJlY3QodmFsdWVzVG9SZW5kZXJba2V5XSwgbGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5VG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IGFwcGx5VG8ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbYXBwbHlUb1tpXV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1trZXldID0gY29ycmVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBvbiBmb2xsb3cgY29tcG9uZW50cy4gVGhpcyBpcyB0byBlbnN1cmVcbiAgICAgICAgICAgICAqIHRoYXQgaWYgYSBmb2xsb3cgY29tcG9uZW50IGNvdmVycyBhIGxlYWQgY29tcG9uZW50IGl0IGRvZXNuJ3QgYmxvY2tcbiAgICAgICAgICAgICAqIHBvaW50ZXIgZXZlbnRzIG9uIHRoZSBsZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICBsZWFkID09PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5jbGVhclNuYXBzaG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVGcm9tID0gdGhpcy5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gT25seSBydW4gb24gcm9vdFxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVzZXRUcmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gbm9kZS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKGNsZWFyTWVhc3VyZW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zaGFyZWROb2Rlcy5jbGVhcigpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvamVjdGlvbk5vZGU7XG4gICAgfSgpKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dChub2RlKSB7XG4gICAgbm9kZS51cGRhdGVMYXlvdXQoKTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUxheW91dFVwZGF0ZShub2RlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHZhciBzbmFwc2hvdCA9IChfYiA9IChfYSA9IG5vZGUucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNuYXBzaG90KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBub2RlLnNuYXBzaG90O1xuICAgIGlmIChub2RlLmlzTGVhZCgpICYmXG4gICAgICAgIG5vZGUubGF5b3V0ICYmXG4gICAgICAgIHNuYXBzaG90ICYmXG4gICAgICAgIG5vZGUuaGFzTGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIpKSB7XG4gICAgICAgIHZhciBfZSA9IG5vZGUubGF5b3V0LCBsYXlvdXRfMSA9IF9lLmFjdHVhbCwgbWVhc3VyZWRMYXlvdXQgPSBfZS5tZWFzdXJlZDtcbiAgICAgICAgLy8gVE9ETyBNYXliZSB3ZSB3YW50IHRvIGFsc28gcmVzaXplIHRoZSBsYXlvdXQgc25hcHNob3Qgc28gd2UgZG9uJ3QgdHJpZ2dlclxuICAgICAgICAvLyBhbmltYXRpb25zIGZvciBpbnN0YW5jZSBpZiBsYXlvdXQ9XCJzaXplXCIgYW5kIGFuIGVsZW1lbnQgaGFzIG9ubHkgY2hhbmdlZCBwb3NpdGlvblxuICAgICAgICBpZiAobm9kZS5vcHRpb25zLmFuaW1hdGlvblR5cGUgPT09IFwic2l6ZVwiKSB7XG4gICAgICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzU25hcHNob3QgPSBzbmFwc2hvdC5pc1NoYXJlZFxuICAgICAgICAgICAgICAgICAgICA/IHNuYXBzaG90Lm1lYXN1cmVkW2F4aXNdXG4gICAgICAgICAgICAgICAgICAgIDogc25hcHNob3QubGF5b3V0W2F4aXNdO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBjYWxjTGVuZ3RoKGF4aXNTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1pbiA9IGxheW91dF8xW2F4aXNdLm1pbjtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUub3B0aW9ucy5hbmltYXRpb25UeXBlID09PSBcInBvc2l0aW9uXCIpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNTbmFwc2hvdCA9IHNuYXBzaG90LmlzU2hhcmVkXG4gICAgICAgICAgICAgICAgICAgID8gc25hcHNob3QubWVhc3VyZWRbYXhpc11cbiAgICAgICAgICAgICAgICAgICAgOiBzbmFwc2hvdC5sYXlvdXRbYXhpc107XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGNhbGNMZW5ndGgobGF5b3V0XzFbYXhpc10pO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheW91dERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgY2FsY0JveERlbHRhKGxheW91dERlbHRhLCBsYXlvdXRfMSwgc25hcHNob3QubGF5b3V0KTtcbiAgICAgICAgdmFyIHZpc3VhbERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgaWYgKHNuYXBzaG90LmlzU2hhcmVkKSB7XG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodmlzdWFsRGVsdGEsIG5vZGUuYXBwbHlUcmFuc2Zvcm0obWVhc3VyZWRMYXlvdXQsIHRydWUpLCBzbmFwc2hvdC5tZWFzdXJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodmlzdWFsRGVsdGEsIGxheW91dF8xLCBzbmFwc2hvdC5sYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNMYXlvdXRDaGFuZ2VkID0gIWlzRGVsdGFaZXJvKGxheW91dERlbHRhKTtcbiAgICAgICAgdmFyIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIW5vZGUucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVBhcmVudCA9IG5vZGUuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHJlbGF0aXZlUGFyZW50IGlzIGl0c2VsZiByZXN1bWluZyBmcm9tIGEgZGlmZmVyZW50IGVsZW1lbnQgdGhlblxuICAgICAgICAgICAgICogdGhlIHJlbGF0aXZlIHNuYXBzaG90IGlzIG5vdCByZWxhdmVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobm9kZS5yZWxhdGl2ZVBhcmVudCAmJiAhbm9kZS5yZWxhdGl2ZVBhcmVudC5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9mID0gbm9kZS5yZWxhdGl2ZVBhcmVudCwgcGFyZW50U25hcHNob3QgPSBfZi5zbmFwc2hvdCwgcGFyZW50TGF5b3V0ID0gX2YubGF5b3V0O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTbmFwc2hvdCAmJiBwYXJlbnRMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlU25hcHNob3QgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVTbmFwc2hvdCwgc25hcHNob3QubGF5b3V0LCBwYXJlbnRTbmFwc2hvdC5sYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIGxheW91dF8xLCBwYXJlbnRMYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib3hFcXVhbHMocmVsYXRpdmVTbmFwc2hvdCwgcmVsYXRpdmVMYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUubm90aWZ5TGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIsIHtcbiAgICAgICAgICAgIGxheW91dDogbGF5b3V0XzEsXG4gICAgICAgICAgICBzbmFwc2hvdDogc25hcHNob3QsXG4gICAgICAgICAgICBkZWx0YTogdmlzdWFsRGVsdGEsXG4gICAgICAgICAgICBsYXlvdXREZWx0YTogbGF5b3V0RGVsdGEsXG4gICAgICAgICAgICBoYXNMYXlvdXRDaGFuZ2VkOiBoYXNMYXlvdXRDaGFuZ2VkLFxuICAgICAgICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkOiBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLmlzTGVhZCgpKSB7XG4gICAgICAgIChfZCA9IChfYyA9IG5vZGUub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJpbmcgdHJhbnNpdGlvblxuICAgICAqIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIHRyYW5zaXRpb24gaXMgYmVpbmcgcGFzc2VkIGluIGFzIHt0eXBlOiBmYWxzZSB9IGZyb20gRnJhbWVyXG4gICAgICogYW5kIHdoeSB3ZSBuZWVkIGl0IGF0IGFsbFxuICAgICAqL1xuICAgIG5vZGUub3B0aW9ucy50cmFuc2l0aW9uID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY2xlYXJTbmFwc2hvdChub2RlKSB7XG4gICAgbm9kZS5jbGVhclNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBjbGVhck1lYXN1cmVtZW50cyhub2RlKSB7XG4gICAgbm9kZS5jbGVhck1lYXN1cmVtZW50cygpO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1TdHlsZShub2RlKSB7XG4gICAgdmFyIHZpc3VhbEVsZW1lbnQgPSBub2RlLm9wdGlvbnMudmlzdWFsRWxlbWVudDtcbiAgICBpZiAodmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkub25CZWZvcmVMYXlvdXRNZWFzdXJlKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5QmVmb3JlTGF5b3V0TWVhc3VyZSgpO1xuICAgIH1cbiAgICBub2RlLnJlc2V0VHJhbnNmb3JtKCk7XG59XG5mdW5jdGlvbiBmaW5pc2hBbmltYXRpb24obm9kZSkge1xuICAgIG5vZGUuZmluaXNoQW5pbWF0aW9uKCk7XG4gICAgbm9kZS50YXJnZXREZWx0YSA9IG5vZGUucmVsYXRpdmVUYXJnZXQgPSBub2RlLnRhcmdldCA9IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXREZWx0YShub2RlKSB7XG4gICAgbm9kZS5yZXNvbHZlVGFyZ2V0RGVsdGEoKTtcbn1cbmZ1bmN0aW9uIGNhbGNQcm9qZWN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmNhbGNQcm9qZWN0aW9uKCk7XG59XG5mdW5jdGlvbiByZXNldFJvdGF0aW9uKG5vZGUpIHtcbiAgICBub2RlLnJlc2V0Um90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxlYWRTbmFwc2hvdHMoc3RhY2spIHtcbiAgICBzdGFjay5yZW1vdmVMZWFkU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIG1peEF4aXNEZWx0YShvdXRwdXQsIGRlbHRhLCBwKSB7XG4gICAgb3V0cHV0LnRyYW5zbGF0ZSA9IHBvcG1vdGlvbi5taXgoZGVsdGEudHJhbnNsYXRlLCAwLCBwKTtcbiAgICBvdXRwdXQuc2NhbGUgPSBwb3Btb3Rpb24ubWl4KGRlbHRhLnNjYWxlLCAxLCBwKTtcbiAgICBvdXRwdXQub3JpZ2luID0gZGVsdGEub3JpZ2luO1xuICAgIG91dHB1dC5vcmlnaW5Qb2ludCA9IGRlbHRhLm9yaWdpblBvaW50O1xufVxuZnVuY3Rpb24gbWl4QXhpcyhvdXRwdXQsIGZyb20sIHRvLCBwKSB7XG4gICAgb3V0cHV0Lm1pbiA9IHBvcG1vdGlvbi5taXgoZnJvbS5taW4sIHRvLm1pbiwgcCk7XG4gICAgb3V0cHV0Lm1heCA9IHBvcG1vdGlvbi5taXgoZnJvbS5tYXgsIHRvLm1heCwgcCk7XG59XG5mdW5jdGlvbiBtaXhCb3gob3V0cHV0LCBmcm9tLCB0bywgcCkge1xuICAgIG1peEF4aXMob3V0cHV0LngsIGZyb20ueCwgdG8ueCwgcCk7XG4gICAgbWl4QXhpcyhvdXRwdXQueSwgZnJvbS55LCB0by55LCBwKTtcbn1cbmZ1bmN0aW9uIGhhc09wYWNpdHlDcm9zc2ZhZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5hbmltYXRpb25WYWx1ZXMgJiYgbm9kZS5hbmltYXRpb25WYWx1ZXMub3BhY2l0eUV4aXQgIT09IHVuZGVmaW5lZCk7XG59XG52YXIgZGVmYXVsdExheW91dFRyYW5zaXRpb24gPSB7XG4gICAgZHVyYXRpb246IDAuNDUsXG4gICAgZWFzZTogWzAuNCwgMCwgMC4xLCAxXSxcbn07XG5mdW5jdGlvbiBtb3VudE5vZGVFYXJseShub2RlLCBpZCkge1xuICAgIC8qKlxuICAgICAqIFJhdGhlciB0aGFuIHNlYXJjaGluZyB0aGUgRE9NIGZyb20gZG9jdW1lbnQgd2UgY2FuIHNlYXJjaCB0aGVcbiAgICAgKiBwYXRoIGZvciB0aGUgZGVlcGVzdCBtb3VudGVkIGFuY2VzdG9yIGFuZCBzZWFyY2ggZnJvbSB0aGVyZVxuICAgICAqL1xuICAgIHZhciBzZWFyY2hOb2RlID0gbm9kZS5yb290O1xuICAgIGZvciAodmFyIGkgPSBub2RlLnBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKEJvb2xlYW4obm9kZS5wYXRoW2ldLmluc3RhbmNlKSkge1xuICAgICAgICAgICAgc2VhcmNoTm9kZSA9IG5vZGUucGF0aFtpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzZWFyY2hFbGVtZW50ID0gc2VhcmNoTm9kZSAmJiBzZWFyY2hOb2RlICE9PSBub2RlLnJvb3QgPyBzZWFyY2hOb2RlLmluc3RhbmNlIDogZG9jdW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSBzZWFyY2hFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wcm9qZWN0aW9uLWlkPVxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIl1cIikpO1xuICAgIGlmIChlbGVtZW50KVxuICAgICAgICBub2RlLm1vdW50KGVsZW1lbnQsIHRydWUpO1xufVxuZnVuY3Rpb24gcm91bmRBeGlzKGF4aXMpIHtcbiAgICBheGlzLm1pbiA9IE1hdGgucm91bmQoYXhpcy5taW4pO1xuICAgIGF4aXMubWF4ID0gTWF0aC5yb3VuZChheGlzLm1heCk7XG59XG5mdW5jdGlvbiByb3VuZEJveChib3gpIHtcbiAgICByb3VuZEF4aXMoYm94LngpO1xuICAgIHJvdW5kQXhpcyhib3gueSk7XG59XG5cbnZhciBEb2N1bWVudFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyOiBmdW5jdGlvbiAocmVmLCBub3RpZnkpIHsgcmV0dXJuIGFkZERvbUV2ZW50KHJlZiwgXCJyZXNpemVcIiwgbm90aWZ5KTsgfSxcbiAgICBtZWFzdXJlU2Nyb2xsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICB4OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgfSk7IH0sXG4gICAgY2hlY2tJc1Njcm9sbFJvb3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG59KTtcblxudmFyIHJvb3RQcm9qZWN0aW9uTm9kZSA9IHtcbiAgICBjdXJyZW50OiB1bmRlZmluZWQsXG59O1xudmFyIEhUTUxQcm9qZWN0aW9uTm9kZSA9IGNyZWF0ZVByb2plY3Rpb25Ob2RlKHtcbiAgICBtZWFzdXJlU2Nyb2xsOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuICh7XG4gICAgICAgIHg6IGluc3RhbmNlLnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGluc3RhbmNlLnNjcm9sbFRvcCxcbiAgICB9KTsgfSxcbiAgICBkZWZhdWx0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBkb2N1bWVudE5vZGUgPSBuZXcgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSgwLCB7fSk7XG4gICAgICAgICAgICBkb2N1bWVudE5vZGUubW91bnQod2luZG93KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5zZXRPcHRpb25zKHsgbGF5b3V0U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQgPSBkb2N1bWVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgIH0sXG4gICAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmFsdWUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogXCJub25lXCI7XG4gICAgfSxcbiAgICBjaGVja0lzU2Nyb2xsUm9vdDogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGluc3RhbmNlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKTtcbiAgICB9LFxufSk7XG5cbnZhciBmZWF0dXJlQnVuZGxlID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGFuaW1hdGlvbnMpLCBnZXN0dXJlQW5pbWF0aW9ucyksIGRyYWcpLCBsYXlvdXRGZWF0dXJlcyk7XG4vKipcbiAqIEhUTUwgJiBTVkcgY29tcG9uZW50cywgb3B0aW1pc2VkIGZvciB1c2Ugd2l0aCBnZXN0dXJlcyBhbmQgYW5pbWF0aW9uLiBUaGVzZSBjYW4gYmUgdXNlZCBhc1xuICogZHJvcC1pbiByZXBsYWNlbWVudHMgZm9yIGFueSBIVE1MICYgU1ZHIGNvbXBvbmVudCwgYWxsIENTUyAmIFNWRyBwcm9wZXJ0aWVzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgbW90aW9uID0gLypAX19QVVJFX18qLyBjcmVhdGVNb3Rpb25Qcm94eShmdW5jdGlvbiAoQ29tcG9uZW50LCBjb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlRG9tTW90aW9uQ29uZmlnKENvbXBvbmVudCwgY29uZmlnLCBmZWF0dXJlQnVuZGxlLCBjcmVhdGVEb21WaXN1YWxFbGVtZW50LCBIVE1MUHJvamVjdGlvbk5vZGUpO1xufSk7XG4vKipcbiAqIENyZWF0ZSBhIERPTSBgbW90aW9uYCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgc3RyaW5nLiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZFxuICogYXMgYSBmdWxsIGFsdGVybmF0aXZlIHRvIGBtb3Rpb25gIGZvciBjb25zdW1lcnMgd2hvIGhhdmUgdG8gc3VwcG9ydCBlbnZpcm9ubWVudHMgdGhhdCBkb24ndFxuICogc3VwcG9ydCBgUHJveHlgLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBjb25zdCBtb3Rpb24gPSB7XG4gKiAgIGRpdjogY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50KCdkaXYnKVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVEb21Nb3Rpb25Db21wb25lbnQoa2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjcmVhdGVEb21Nb3Rpb25Db25maWcoa2V5LCB7IGZvcndhcmRNb3Rpb25Qcm9wczogZmFsc2UgfSwgZmVhdHVyZUJ1bmRsZSwgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCwgSFRNTFByb2plY3Rpb25Ob2RlKSk7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG52YXIgbSA9IGNyZWF0ZU1vdGlvblByb3h5KGNyZWF0ZURvbU1vdGlvbkNvbmZpZyk7XG5cbmZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGlzTW91bnRlZDtcbn1cblxuZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICAgIHZhciBfYSA9IHRzbGliLl9fcmVhZChSZWFjdC51c2VTdGF0ZSgwKSwgMiksIGZvcmNlZFJlbmRlckNvdW50ID0gX2FbMF0sIHNldEZvcmNlZFJlbmRlckNvdW50ID0gX2FbMV07XG4gICAgdmFyIGZvcmNlUmVuZGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCAmJiBzZXRGb3JjZWRSZW5kZXJDb3VudChmb3JjZWRSZW5kZXJDb3VudCArIDEpO1xuICAgIH0sIFtmb3JjZWRSZW5kZXJDb3VudF0pO1xuICAgIC8qKlxuICAgICAqIERlZmVyIHRoaXMgdG8gdGhlIGVuZCBvZiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUgaW4gY2FzZSB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICAgKiBzeW5jaHJvbm91cyBjYWxscy5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXJyZWRGb3JjZVJlbmRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bmNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnBvc3RSZW5kZXIoZm9yY2VSZW5kZXIpOyB9LCBbZm9yY2VSZW5kZXJdKTtcbiAgICByZXR1cm4gW2RlZmVycmVkRm9yY2VSZW5kZXIsIGZvcmNlZFJlbmRlckNvdW50XTtcbn1cblxudmFyIFByZXNlbmNlQ2hpbGQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaW5pdGlhbCA9IF9hLmluaXRpYWwsIGlzUHJlc2VudCA9IF9hLmlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUgPSBfYS5vbkV4aXRDb21wbGV0ZSwgY3VzdG9tID0gX2EuY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSBfYS5wcmVzZW5jZUFmZmVjdHNMYXlvdXQ7XG4gICAgdmFyIHByZXNlbmNlQ2hpbGRyZW4gPSB1c2VDb25zdGFudChuZXdDaGlsZHJlbk1hcCk7XG4gICAgdmFyIGlkID0gdXNlSWQoKTtcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBpbml0aWFsOiBpbml0aWFsLFxuICAgICAgICBpc1ByZXNlbnQ6IGlzUHJlc2VudCxcbiAgICAgICAgY3VzdG9tOiBjdXN0b20sXG4gICAgICAgIG9uRXhpdENvbXBsZXRlOiBmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLnNldChjaGlsZElkLCB0cnVlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSB0c2xpYi5fX3ZhbHVlcyhwcmVzZW5jZUNoaWxkcmVuLnZhbHVlcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNhbiBzdG9wIHNlYXJjaGluZyB3aGVuIGFueSBpcyBpbmNvbXBsZXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgPT09IG51bGwgfHwgb25FeGl0Q29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByZXNlbmNlQ2hpbGRyZW4uZGVsZXRlKGNoaWxkSWQpOyB9O1xuICAgICAgICB9LFxuICAgIH0pOyB9LCBcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcHJlc2VuY2Ugb2YgYSBjaGlsZCBhZmZlY3RzIHRoZSBsYXlvdXQgb2YgdGhlIGNvbXBvbmVudHMgYXJvdW5kIGl0LFxuICAgICAqIHdlIHdhbnQgdG8gbWFrZSBhIG5ldyBjb250ZXh0IHZhbHVlIHRvIGVuc3VyZSB0aGV5IGdldCByZS1yZW5kZXJlZFxuICAgICAqIHNvIHRoZXkgY2FuIGRldGVjdCB0aGF0IGxheW91dCBjaGFuZ2UuXG4gICAgICovXG4gICAgcHJlc2VuY2VBZmZlY3RzTGF5b3V0ID8gdW5kZWZpbmVkIDogW2lzUHJlc2VudF0pO1xuICAgIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4gcHJlc2VuY2VDaGlsZHJlbi5zZXQoa2V5LCBmYWxzZSk7IH0pO1xuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIG5vIGBtb3Rpb25gIGNvbXBvbmVudHMgdG8gZmlyZSBleGl0IGFuaW1hdGlvbnMsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoaXNcbiAgICAgKiBjb21wb25lbnQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAhaXNQcmVzZW50ICYmICFwcmVzZW5jZUNoaWxkcmVuLnNpemUgJiYgKG9uRXhpdENvbXBsZXRlID09PSBudWxsIHx8IG9uRXhpdENvbXBsZXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkV4aXRDb21wbGV0ZSgpKTtcbiAgICB9LCBbaXNQcmVzZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNoaWxkcmVuKSk7XG59O1xuZnVuY3Rpb24gbmV3Q2hpbGRyZW5NYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcbn1cblxudmFyIGdldENoaWxkS2V5ID0gZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5rZXkgfHwgXCJcIjsgfTtcbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkTG9va3VwKGNoaWxkcmVuLCBhbGxDaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBrZXkgPSBnZXRDaGlsZEtleShjaGlsZCk7XG4gICAgICAgIGFsbENoaWxkcmVuLnNldChrZXksIGNoaWxkKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9ubHlFbGVtZW50cyhjaGlsZHJlbikge1xuICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xuICAgIC8vIFdlIHVzZSBmb3JFYWNoIGhlcmUgaW5zdGVhZCBvZiBtYXAgYXMgbWFwIG11dGF0ZXMgdGhlIGNvbXBvbmVudCBrZXkgYnkgcHJlcHJlbmRpbmcgYC4kYFxuICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaChjaGlsZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuLyoqXG4gKiBgQW5pbWF0ZVByZXNlbmNlYCBlbmFibGVzIHRoZSBhbmltYXRpb24gb2YgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyZWUuXG4gKlxuICogV2hlbiBhZGRpbmcvcmVtb3ZpbmcgbW9yZSB0aGFuIGEgc2luZ2xlIGNoaWxkLCBldmVyeSBjaGlsZCAqKm11c3QqKiBiZSBnaXZlbiBhIHVuaXF1ZSBga2V5YCBwcm9wLlxuICpcbiAqIEFueSBgbW90aW9uYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXG4gKiB0aGUgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgY29uc3QgSXRlbXMgPSAoeyBpdGVtcyB9KSA9PiAoXG4gKiAgIDxBbmltYXRlUHJlc2VuY2U+XG4gKiAgICAge2l0ZW1zLm1hcChpdGVtID0+IChcbiAqICAgICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICAgIGtleT17aXRlbS5pZH1cbiAqICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gKiAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICogICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgIC8+XG4gKiAgICAgKSl9XG4gKiAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICogKVxuICogYGBgXG4gKlxuICogWW91IGNhbiBzZXF1ZW5jZSBleGl0IGFuaW1hdGlvbnMgdGhyb3VnaG91dCBhIHRyZWUgdXNpbmcgdmFyaWFudHMuXG4gKlxuICogSWYgYSBjaGlsZCBjb250YWlucyBtdWx0aXBsZSBgbW90aW9uYCBjb21wb25lbnRzIHdpdGggYGV4aXRgIHByb3BzLCBpdCB3aWxsIG9ubHkgdW5tb3VudCB0aGUgY2hpbGRcbiAqIG9uY2UgYWxsIGBtb3Rpb25gIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LiBMaWtld2lzZSwgYW55IGNvbXBvbmVudHMgdXNpbmdcbiAqIGB1c2VQcmVzZW5jZWAgYWxsIG5lZWQgdG8gY2FsbCBgc2FmZVRvUmVtb3ZlYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBBbmltYXRlUHJlc2VuY2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY3VzdG9tID0gX2EuY3VzdG9tLCBfYiA9IF9hLmluaXRpYWwsIGluaXRpYWwgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBvbkV4aXRDb21wbGV0ZSA9IF9hLm9uRXhpdENvbXBsZXRlLCBleGl0QmVmb3JlRW50ZXIgPSBfYS5leGl0QmVmb3JlRW50ZXIsIF9jID0gX2EucHJlc2VuY2VBZmZlY3RzTGF5b3V0LCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jO1xuICAgIC8vIFdlIHdhbnQgdG8gZm9yY2UgYSByZS1yZW5kZXIgb25jZSBhbGwgZXhpdGluZyBhbmltYXRpb25zIGhhdmUgZmluaXNoZWQuIFdlXG4gICAgLy8gZWl0aGVyIHVzZSBhIGxvY2FsIGZvcmNlUmVuZGVyIGZ1bmN0aW9uLCBvciBvbmUgZnJvbSBhIHBhcmVudCBjb250ZXh0IGlmIGl0IGV4aXN0cy5cbiAgICB2YXIgX2QgPSB0c2xpYi5fX3JlYWQodXNlRm9yY2VVcGRhdGUoKSwgMSksIGZvcmNlUmVuZGVyID0gX2RbMF07XG4gICAgdmFyIGZvcmNlUmVuZGVyTGF5b3V0R3JvdXAgPSBSZWFjdC51c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCkuZm9yY2VSZW5kZXI7XG4gICAgaWYgKGZvcmNlUmVuZGVyTGF5b3V0R3JvdXApXG4gICAgICAgIGZvcmNlUmVuZGVyID0gZm9yY2VSZW5kZXJMYXlvdXRHcm91cDtcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgY2hpbGRyZW4gdGhhdCBhcmVuJ3QgUmVhY3RFbGVtZW50cy4gV2UgY2FuIG9ubHkgdHJhY2sgUmVhY3RFbGVtZW50cyB3aXRoIGEgcHJvcHMua2V5XG4gICAgdmFyIGZpbHRlcmVkQ2hpbGRyZW4gPSBvbmx5RWxlbWVudHMoY2hpbGRyZW4pO1xuICAgIHZhciBjaGlsZHJlblRvUmVuZGVyID0gZmlsdGVyZWRDaGlsZHJlbjtcbiAgICB2YXIgZXhpdGluZyA9IG5ldyBTZXQoKTtcbiAgICAvLyBLZWVwIGEgbGl2aW5nIHJlY29yZCBvZiB0aGUgY2hpbGRyZW4gd2UncmUgYWN0dWFsbHkgcmVuZGVyaW5nIHNvIHdlXG4gICAgLy8gY2FuIGRpZmYgdG8gZmlndXJlIG91dCB3aGljaCBhcmUgZW50ZXJpbmcgYW5kIGV4aXRpbmdcbiAgICB2YXIgcHJlc2VudENoaWxkcmVuID0gUmVhY3QudXNlUmVmKGNoaWxkcmVuVG9SZW5kZXIpO1xuICAgIC8vIEEgbG9va3VwIHRhYmxlIHRvIHF1aWNrbHkgcmVmZXJlbmNlIGNvbXBvbmVudHMgYnkga2V5XG4gICAgdmFyIGFsbENoaWxkcmVuID0gUmVhY3QudXNlUmVmKG5ldyBNYXAoKSkuY3VycmVudDtcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBpbml0aWFsIGNvbXBvbmVudCByZW5kZXIsIGp1c3QgZGVhbCB3aXRoIGxvZ2ljIHN1cnJvdW5kaW5nIHdoZXRoZXJcbiAgICAvLyB3ZSBwbGF5IG9uTW91bnQgYW5pbWF0aW9ucyBvciBub3QuXG4gICAgdmFyIGlzSW5pdGlhbFJlbmRlciA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgdXBkYXRlQ2hpbGRMb29rdXAoZmlsdGVyZWRDaGlsZHJlbiwgYWxsQ2hpbGRyZW4pO1xuICAgICAgICBwcmVzZW50Q2hpbGRyZW4uY3VycmVudCA9IGNoaWxkcmVuVG9SZW5kZXI7XG4gICAgfSk7XG4gICAgdXNlVW5tb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgYWxsQ2hpbGRyZW4uY2xlYXIoKTtcbiAgICAgICAgZXhpdGluZy5jbGVhcigpO1xuICAgIH0pO1xuICAgIGlmIChpc0luaXRpYWxSZW5kZXIuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCBjaGlsZHJlblRvUmVuZGVyLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiB0cnVlLCBpbml0aWFsOiBpbml0aWFsID8gdW5kZWZpbmVkIDogZmFsc2UsIHByZXNlbmNlQWZmZWN0c0xheW91dDogcHJlc2VuY2VBZmZlY3RzTGF5b3V0IH0sIGNoaWxkKSk7IH0pKSk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYSBzdWJzZXF1ZW50IHJlbmRlciwgZGVhbCB3aXRoIGVudGVyaW5nIGFuZCBleGl0aW5nIGNoaWxkcmVuXG4gICAgY2hpbGRyZW5Ub1JlbmRlciA9IHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHRzbGliLl9fcmVhZChjaGlsZHJlblRvUmVuZGVyKSwgZmFsc2UpO1xuICAgIC8vIERpZmYgdGhlIGtleXMgb2YgdGhlIGN1cnJlbnRseS1wcmVzZW50IGFuZCB0YXJnZXQgY2hpbGRyZW4gdG8gdXBkYXRlIG91clxuICAgIC8vIGV4aXRpbmcgbGlzdC5cbiAgICB2YXIgcHJlc2VudEtleXMgPSBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5tYXAoZ2V0Q2hpbGRLZXkpO1xuICAgIHZhciB0YXJnZXRLZXlzID0gZmlsdGVyZWRDaGlsZHJlbi5tYXAoZ2V0Q2hpbGRLZXkpO1xuICAgIC8vIERpZmYgdGhlIHByZXNlbnQgY2hpbGRyZW4gd2l0aCBvdXIgdGFyZ2V0IGNoaWxkcmVuIGFuZCBtYXJrIHRob3NlIHRoYXQgYXJlIGV4aXRpbmdcbiAgICB2YXIgbnVtUHJlc2VudCA9IHByZXNlbnRLZXlzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVByZXNlbnQ7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gcHJlc2VudEtleXNbaV07XG4gICAgICAgIGlmICh0YXJnZXRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4aXRpbmcuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgY3VycmVudGx5IGhhdmUgZXhpdGluZyBjaGlsZHJlbiwgYW5kIHdlJ3JlIGRlZmVycmluZyByZW5kZXJpbmcgaW5jb21pbmcgY2hpbGRyZW5cbiAgICAvLyB1bnRpbCBhZnRlciBhbGwgY3VycmVudCBjaGlsZHJlbiBoYXZlIGV4aXRpbmcsIGVtcHR5IHRoZSBjaGlsZHJlblRvUmVuZGVyIGFycmF5XG4gICAgaWYgKGV4aXRCZWZvcmVFbnRlciAmJiBleGl0aW5nLnNpemUpIHtcbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlciA9IFtdO1xuICAgIH1cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIGN1cnJlbnRseSBleGl0aW5nIGNvbXBvbmVudHMgYW5kIGNsb25lIHRoZW0gdG8gb3ZlcndyaXRlIGBhbmltYXRlYFxuICAgIC8vIHdpdGggYW55IGBleGl0YCBwcm9wIHRoZXkgbWlnaHQgaGF2ZSBkZWZpbmVkLlxuICAgIGV4aXRpbmcuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGlzIGFjdHVhbGx5IGVudGVyaW5nIGFnYWluLCBlYXJseSByZXR1cm5cbiAgICAgICAgaWYgKHRhcmdldEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNoaWxkID0gYWxsQ2hpbGRyZW4uZ2V0KGtleSk7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHByZXNlbnRLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgdmFyIG9uRXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFsbENoaWxkcmVuLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgZXhpdGluZy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGNoaWxkIGZyb20gdGhlIHByZXNlbnQgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciByZW1vdmVJbmRleCA9IHByZXNlbnRDaGlsZHJlbi5jdXJyZW50LmZpbmRJbmRleChmdW5jdGlvbiAocHJlc2VudENoaWxkKSB7IHJldHVybiBwcmVzZW50Q2hpbGQua2V5ID09PSBrZXk7IH0pO1xuICAgICAgICAgICAgcHJlc2VudENoaWxkcmVuLmN1cnJlbnQuc3BsaWNlKHJlbW92ZUluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vIERlZmVyIHJlLXJlbmRlcmluZyB1bnRpbCBhbGwgZXhpdGluZyBjaGlsZHJlbiBoYXZlIGluZGVlZCBsZWZ0XG4gICAgICAgICAgICBpZiAoIWV4aXRpbmcuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHByZXNlbnRDaGlsZHJlbi5jdXJyZW50ID0gZmlsdGVyZWRDaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFByZXNlbmNlQ2hpbGQsIHsga2V5OiBnZXRDaGlsZEtleShjaGlsZCksIGlzUHJlc2VudDogZmFsc2UsIG9uRXhpdENvbXBsZXRlOiBvbkV4aXQsIGN1c3RvbTogY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQ6IHByZXNlbmNlQWZmZWN0c0xheW91dCB9LCBjaGlsZCkpO1xuICAgIH0pO1xuICAgIC8vIEFkZCBgTW90aW9uQ29udGV4dGAgZXZlbiB0byBjaGlsZHJlbiB0aGF0IGRvbid0IG5lZWQgaXQgdG8gZW5zdXJlIHdlJ3JlIHJlbmRlcmluZ1xuICAgIC8vIHRoZSBzYW1lIHRyZWUgYmV0d2VlbiByZW5kZXJzXG4gICAgY2hpbGRyZW5Ub1JlbmRlciA9IGNoaWxkcmVuVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICByZXR1cm4gZXhpdGluZy5oYXMoa2V5KSA/IChjaGlsZCkgOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFByZXNlbmNlQ2hpbGQsIHsga2V5OiBnZXRDaGlsZEtleShjaGlsZCksIGlzUHJlc2VudDogdHJ1ZSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0OiBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgfSwgY2hpbGQpKTtcbiAgICB9KTtcbiAgICBpZiAoZW52ICE9PSBcInByb2R1Y3Rpb25cIiAmJlxuICAgICAgICBleGl0QmVmb3JlRW50ZXIgJiZcbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIllvdSdyZSBhdHRlbXB0aW5nIHRvIGFuaW1hdGUgbXVsdGlwbGUgY2hpbGRyZW4gd2l0aGluIEFuaW1hdGVQcmVzZW5jZSwgYnV0IGl0cyBleGl0QmVmb3JlRW50ZXIgcHJvcCBpcyBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIGxlYWQgdG8gb2RkIHZpc3VhbCBiZWhhdmlvdXIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCBleGl0aW5nLnNpemVcbiAgICAgICAgPyBjaGlsZHJlblRvUmVuZGVyXG4gICAgICAgIDogY2hpbGRyZW5Ub1JlbmRlci5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQpOyB9KSkpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBub3RpZnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiAhbm9kZS5pc0xheW91dERpcnR5ICYmIG5vZGUud2lsbFVwZGF0ZShmYWxzZSk7XG59O1xuZnVuY3Rpb24gbm9kZUdyb3VwKCkge1xuICAgIHZhciBub2RlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIGRpcnR5QWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZXMuZm9yRWFjaChub3RpZnkpOyB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc2V0KG5vZGUsIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIndpbGxVcGRhdGVcIiwgZGlydHlBbGwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgKF9hID0gc3Vic2NyaXB0aW9ucy5nZXQobm9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICBkaXJ0eUFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXJ0eTogZGlydHlBbGwsXG4gICAgfTtcbn1cblxudmFyIHNob3VsZEluaGVyaXRHcm91cCA9IGZ1bmN0aW9uIChpbmhlcml0KSB7IHJldHVybiBpbmhlcml0ID09PSB0cnVlOyB9O1xudmFyIHNob3VsZEluaGVyaXRJZCA9IGZ1bmN0aW9uIChpbmhlcml0KSB7XG4gICAgcmV0dXJuIHNob3VsZEluaGVyaXRHcm91cChpbmhlcml0ID09PSB0cnVlKSB8fCBpbmhlcml0ID09PSBcImlkXCI7XG59O1xudmFyIExheW91dEdyb3VwID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iLCBfYztcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaWQgPSBfYS5pZCwgaW5oZXJpdElkID0gX2EuaW5oZXJpdElkLCBfZCA9IF9hLmluaGVyaXQsIGluaGVyaXQgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kO1xuICAgIC8vIE1haW50YWluIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggaW5oZXJpdElkIHVudGlsIDcuMFxuICAgIGlmIChpbmhlcml0SWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgaW5oZXJpdCA9IGluaGVyaXRJZDtcbiAgICB2YXIgbGF5b3V0R3JvdXBDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIHZhciBkZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICB2YXIgX2UgPSB0c2xpYi5fX3JlYWQodXNlRm9yY2VVcGRhdGUoKSwgMiksIGZvcmNlUmVuZGVyID0gX2VbMF0sIGtleSA9IF9lWzFdO1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciB1cHN0cmVhbUlkID0gKF9iID0gbGF5b3V0R3JvdXBDb250ZXh0LmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0O1xuICAgIGlmIChjb250ZXh0LmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZEluaGVyaXRJZChpbmhlcml0KSAmJiB1cHN0cmVhbUlkKSB7XG4gICAgICAgICAgICBpZCA9IGlkID8gdXBzdHJlYW1JZCArIFwiLVwiICsgaWQgOiB1cHN0cmVhbUlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY3VycmVudCA9IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGdyb3VwOiBzaG91bGRJbmhlcml0R3JvdXAoaW5oZXJpdClcbiAgICAgICAgICAgICAgICA/IChfYyA9IGxheW91dEdyb3VwQ29udGV4dCA9PT0gbnVsbCB8fCBsYXlvdXRHcm91cENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dEdyb3VwQ29udGV4dC5ncm91cCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbm9kZUdyb3VwKClcbiAgICAgICAgICAgICAgICA6IG5vZGVHcm91cCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgbWVtb2l6ZWRDb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQuY3VycmVudCksIHsgZm9yY2VSZW5kZXI6IGZvcmNlUmVuZGVyIH0pKTsgfSwgW2tleV0pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExheW91dEdyb3VwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbWVtb2l6ZWRDb250ZXh0IH0sIGNoaWxkcmVuKSk7XG59O1xuXG52YXIgaWQgPSAwO1xudmFyIEFuaW1hdGVTaGFyZWRMYXlvdXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhleUxpc3Rlbi53YXJuaW5nKGZhbHNlLCBcIkFuaW1hdGVTaGFyZWRMYXlvdXQgaXMgZGVwcmVjYXRlZDogaHR0cHM6Ly93d3cuZnJhbWVyLmNvbS9kb2NzL2d1aWRlLXVwZ3JhZGUvIyNzaGFyZWQtbGF5b3V0LWFuaW1hdGlvbnNcIik7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExheW91dEdyb3VwLCB7IGlkOiB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBcImFzbC1cIi5jb25jYXQoaWQrKyk7IH0pIH0sIGNoaWxkcmVuKSk7XG59O1xuXG4vKipcbiAqIGBNb3Rpb25Db25maWdgIGlzIHVzZWQgdG8gc2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYWxsIGNoaWxkcmVuIGBtb3Rpb25gIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyBtb3Rpb24sIE1vdGlvbkNvbmZpZyB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxNb3Rpb25Db25maWcgdHJhbnNpdGlvbj17eyB0eXBlOiBcInNwcmluZ1wiIH19PlxuICogICAgICAgPG1vdGlvbi5kaXYgYW5pbWF0ZT17eyB4OiAxMDAgfX0gLz5cbiAqICAgICA8L01vdGlvbkNvbmZpZz5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBNb3Rpb25Db25maWcoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaXNWYWxpZFByb3AgPSBfYS5pc1ZhbGlkUHJvcCwgY29uZmlnID0gdHNsaWIuX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImlzVmFsaWRQcm9wXCJdKTtcbiAgICBpc1ZhbGlkUHJvcCAmJiBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChpc1ZhbGlkUHJvcCk7XG4gICAgLyoqXG4gICAgICogSW5oZXJpdCBwcm9wcyBmcm9tIGFueSBwYXJlbnQgTW90aW9uQ29uZmlnIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBjb25maWcgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KSksIGNvbmZpZyk7XG4gICAgLyoqXG4gICAgICogRG9uJ3QgYWxsb3cgaXNTdGF0aWMgdG8gY2hhbmdlIGJldHdlZW4gcmVuZGVycyBhcyBpdCBhZmZlY3RzIGhvdyBtYW55IGhvb2tzXG4gICAgICogbW90aW9uIGNvbXBvbmVudHMgZmlyZS5cbiAgICAgKi9cbiAgICBjb25maWcuaXNTdGF0aWMgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWcuaXNTdGF0aWM7IH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0aW5nIGEgbmV3IGNvbmZpZyBjb250ZXh0IG9iamVjdCB3aWxsIHJlLXJlbmRlciBldmVyeSBgbW90aW9uYCBjb21wb25lbnRcbiAgICAgKiBldmVyeSB0aW1lIGl0IHJlbmRlcnMuIFNvIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgYSBuZXcgb25lIHNwYXJpbmdseS5cbiAgICAgKi9cbiAgICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9LCBbSlNPTi5zdHJpbmdpZnkoY29uZmlnLnRyYW5zaXRpb24pLCBjb25maWcudHJhbnNmb3JtUGFnZVBvaW50LCBjb25maWcucmVkdWNlZE1vdGlvbl0pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE1vdGlvbkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgY2hpbGRyZW4pKTtcbn1cblxuLyoqXG4gKiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBtYCBjb21wb25lbnQgdG8gcmVkdWNlIGJ1bmRsZSBzaXplLlxuICpcbiAqIGBtYCBpcyBhIHZlcnNpb24gb2YgdGhlIGBtb3Rpb25gIGNvbXBvbmVudCB0aGF0IG9ubHkgbG9hZHMgZnVuY3Rpb25hbGl0eVxuICogY3JpdGljYWwgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAqXG4gKiBgTGF6eU1vdGlvbmAgY2FuIHRoZW4gYmUgdXNlZCB0byBlaXRoZXIgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseVxuICogbG9hZCBhbmltYXRpb24gYW5kIGdlc3R1cmUgc3VwcG9ydC5cbiAqXG4gKiBgYGBqc3hcbiAqIC8vIFN5bmNocm9ub3VzIGxvYWRpbmdcbiAqIGltcG9ydCB7IExhenlNb3Rpb24sIG0sIGRvbUFuaW1hdGlvbnMgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxMYXp5TW90aW9uIGZlYXR1cmVzPXtkb21BbmltYXRpb25zfT5cbiAqICAgICAgIDxtLmRpdiBhbmltYXRlPXt7IHNjYWxlOiAyIH19IC8+XG4gKiAgICAgPC9MYXp5TW90aW9uPlxuICogICApXG4gKiB9XG4gKlxuICogLy8gQXN5bmNocm9ub3VzIGxvYWRpbmdcbiAqIGltcG9ydCB7IExhenlNb3Rpb24sIG0gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxMYXp5TW90aW9uIGZlYXR1cmVzPXsoKSA9PiBpbXBvcnQoJy4vcGF0aC90by9kb21BbmltYXRpb25zJyl9PlxuICogICAgICAgPG0uZGl2IGFuaW1hdGU9e3sgc2NhbGU6IDIgfX0gLz5cbiAqICAgICA8L0xhenlNb3Rpb24+XG4gKiAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gTGF6eU1vdGlvbihfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBmZWF0dXJlcyA9IF9hLmZlYXR1cmVzLCBfYiA9IF9hLnN0cmljdCwgc3RyaWN0ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgdmFyIF9jID0gdHNsaWIuX19yZWFkKFJlYWN0LnVzZVN0YXRlKCFpc0xhenlCdW5kbGUoZmVhdHVyZXMpKSwgMiksIHNldElzTG9hZGVkID0gX2NbMV07XG4gICAgdmFyIGxvYWRlZFJlbmRlcmVyID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpcyBhIHN5bmNocm9ub3VzIGxvYWQsIGxvYWQgZmVhdHVyZXMgaW1tZWRpYXRlbHlcbiAgICAgKi9cbiAgICBpZiAoIWlzTGF6eUJ1bmRsZShmZWF0dXJlcykpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZmVhdHVyZXMucmVuZGVyZXIsIGxvYWRlZEZlYXR1cmVzID0gdHNsaWIuX19yZXN0KGZlYXR1cmVzLCBbXCJyZW5kZXJlclwiXSk7XG4gICAgICAgIGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQgPSByZW5kZXJlcjtcbiAgICAgICAgbG9hZEZlYXR1cmVzKGxvYWRlZEZlYXR1cmVzKTtcbiAgICB9XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTGF6eUJ1bmRsZShmZWF0dXJlcykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzKCkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBfYS5yZW5kZXJlciwgbG9hZGVkRmVhdHVyZXMgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInJlbmRlcmVyXCJdKTtcbiAgICAgICAgICAgICAgICBsb2FkRmVhdHVyZXMobG9hZGVkRmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgIGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQgPSByZW5kZXJlcjtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRlZCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KExhenlDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IHJlbmRlcmVyOiBsb2FkZWRSZW5kZXJlci5jdXJyZW50LCBzdHJpY3Q6IHN0cmljdCB9IH0sIGNoaWxkcmVuKSk7XG59XG5mdW5jdGlvbiBpc0xhenlCdW5kbGUoZmVhdHVyZXMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGZlYXR1cmVzID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBSZW9yZGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIGNoZWNrUmVvcmRlcihvcmRlciwgdmFsdWUsIG9mZnNldCwgdmVsb2NpdHkpIHtcbiAgICBpZiAoIXZlbG9jaXR5KVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgdmFyIGluZGV4ID0gb3JkZXIuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZhbHVlID09PSB2YWx1ZTsgfSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIHZhciBuZXh0T2Zmc2V0ID0gdmVsb2NpdHkgPiAwID8gMSA6IC0xO1xuICAgIHZhciBuZXh0SXRlbSA9IG9yZGVyW2luZGV4ICsgbmV4dE9mZnNldF07XG4gICAgaWYgKCFuZXh0SXRlbSlcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIHZhciBpdGVtID0gb3JkZXJbaW5kZXhdO1xuICAgIHZhciBuZXh0TGF5b3V0ID0gbmV4dEl0ZW0ubGF5b3V0O1xuICAgIHZhciBuZXh0SXRlbUNlbnRlciA9IHBvcG1vdGlvbi5taXgobmV4dExheW91dC5taW4sIG5leHRMYXlvdXQubWF4LCAwLjUpO1xuICAgIGlmICgobmV4dE9mZnNldCA9PT0gMSAmJiBpdGVtLmxheW91dC5tYXggKyBvZmZzZXQgPiBuZXh0SXRlbUNlbnRlcikgfHxcbiAgICAgICAgKG5leHRPZmZzZXQgPT09IC0xICYmIGl0ZW0ubGF5b3V0Lm1pbiArIG9mZnNldCA8IG5leHRJdGVtQ2VudGVyKSkge1xuICAgICAgICByZXR1cm4gbW92ZUl0ZW0ob3JkZXIsIGluZGV4LCBpbmRleCArIG5leHRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXI7XG59XG5cbmZ1bmN0aW9uIFJlb3JkZXJHcm91cChfYSwgZXh0ZXJuYWxSZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgX2IgPSBfYS5hcywgYXMgPSBfYiA9PT0gdm9pZCAwID8gXCJ1bFwiIDogX2IsIF9jID0gX2EuYXhpcywgYXhpcyA9IF9jID09PSB2b2lkIDAgPyBcInlcIiA6IF9jLCBvblJlb3JkZXIgPSBfYS5vblJlb3JkZXIsIHZhbHVlcyA9IF9hLnZhbHVlcywgcHJvcHMgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiYXNcIiwgXCJheGlzXCIsIFwib25SZW9yZGVyXCIsIFwidmFsdWVzXCJdKTtcbiAgICB2YXIgQ29tcG9uZW50ID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbW90aW9uKGFzKTsgfSk7XG4gICAgdmFyIG9yZGVyID0gW107XG4gICAgdmFyIGlzUmVvcmRlcmluZyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgaGV5TGlzdGVuLmludmFyaWFudChCb29sZWFuKHZhbHVlcyksIFwiUmVvcmRlci5Hcm91cCBtdXN0IGJlIHByb3ZpZGVkIGEgdmFsdWVzIHByb3BcIik7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIGF4aXM6IGF4aXMsXG4gICAgICAgIHJlZ2lzdGVySXRlbTogZnVuY3Rpb24gKHZhbHVlLCBsYXlvdXQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5zdXJlIGVudHJpZXMgY2FuJ3QgYWRkIHRoZW1zZWx2ZXMgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGxheW91dCAmJlxuICAgICAgICAgICAgICAgIG9yZGVyLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHZhbHVlID09PSBlbnRyeS52YWx1ZTsgfSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaCh7IHZhbHVlOiB2YWx1ZSwgbGF5b3V0OiBsYXlvdXRbYXhpc10gfSk7XG4gICAgICAgICAgICAgICAgb3JkZXIuc29ydChjb21wYXJlTWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlT3JkZXI6IGZ1bmN0aW9uIChpZCwgb2Zmc2V0LCB2ZWxvY2l0eSkge1xuICAgICAgICAgICAgaWYgKGlzUmVvcmRlcmluZy5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuZXdPcmRlciA9IGNoZWNrUmVvcmRlcihvcmRlciwgaWQsIG9mZnNldCwgdmVsb2NpdHkpO1xuICAgICAgICAgICAgaWYgKG9yZGVyICE9PSBuZXdPcmRlcikge1xuICAgICAgICAgICAgICAgIGlzUmVvcmRlcmluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvblJlb3JkZXIobmV3T3JkZXJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChnZXRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzUmVvcmRlcmluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB0c2xpYi5fX2Fzc2lnbih7fSwgcHJvcHMsIHsgcmVmOiBleHRlcm5hbFJlZiB9KSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlb3JkZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNoaWxkcmVuKSkpO1xufVxudmFyIEdyb3VwID0gUmVhY3QuZm9yd2FyZFJlZihSZW9yZGVyR3JvdXApO1xuZnVuY3Rpb24gZ2V0VmFsdWUoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xufVxuZnVuY3Rpb24gY29tcGFyZU1pbihhLCBiKSB7XG4gICAgcmV0dXJuIGEubGF5b3V0Lm1pbiAtIGIubGF5b3V0Lm1pbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0byB0cmFjayB0aGUgc3RhdGUgYW5kIHZlbG9jaXR5IG9mIGEgdmFsdWUuXG4gKlxuICogVXN1YWxseSwgdGhlc2UgYXJlIGNyZWF0ZWQgYXV0b21hdGljYWxseS4gRm9yIGFkdmFuY2VkIHVzZS1jYXNlcywgbGlrZSB1c2Ugd2l0aCBgdXNlVHJhbnNmb3JtYCwgeW91IGNhbiBjcmVhdGUgYE1vdGlvblZhbHVlYHMgZXh0ZXJuYWxseSBhbmQgcGFzcyB0aGVtIGludG8gdGhlIGFuaW1hdGVkIGNvbXBvbmVudCB2aWEgdGhlIGBzdHlsZWAgcHJvcC5cbiAqXG4gKiBgYGBqc3hcbiAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3Qgc2NhbGUgPSB1c2VNb3Rpb25WYWx1ZSgxKVxuICpcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IHNjYWxlIH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaW5pdGlhbCAtIFRoZSBpbml0aWFsIHN0YXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlTW90aW9uVmFsdWUoaW5pdGlhbCkge1xuICAgIHZhciB2YWx1ZSA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvblZhbHVlKGluaXRpYWwpOyB9KTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG1vdGlvbiB2YWx1ZSBpcyBiZWluZyB1c2VkIGluIHN0YXRpYyBtb2RlLCBsaWtlIG9uXG4gICAgICogdGhlIEZyYW1lciBjYW52YXMsIGZvcmNlIGNvbXBvbmVudHMgdG8gcmVyZW5kZXIgd2hlbiB0aGUgbW90aW9uXG4gICAgICogdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICB2YXIgaXNTdGF0aWMgPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLmlzU3RhdGljO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICB2YXIgX2EgPSB0c2xpYi5fX3JlYWQoUmVhY3QudXNlU3RhdGUoaW5pdGlhbCksIDIpLCBzZXRMYXRlc3RfMSA9IF9hWzFdO1xuICAgICAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUub25DaGFuZ2Uoc2V0TGF0ZXN0XzEpOyB9LCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGlzQ3VzdG9tVmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXg7XG59O1xudmFyIGdldE1peGVyID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChpc0N1c3RvbVZhbHVlVHlwZSh2KSA/IHYubWl4IDogdW5kZWZpbmVkKTsgfTtcbmZ1bmN0aW9uIHRyYW5zZm9ybSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHVzZUltbWVkaWF0ZSA9ICFBcnJheS5pc0FycmF5KGFyZ3NbMF0pO1xuICAgIHZhciBhcmdPZmZzZXQgPSB1c2VJbW1lZGlhdGUgPyAwIDogLTE7XG4gICAgdmFyIGlucHV0VmFsdWUgPSBhcmdzWzAgKyBhcmdPZmZzZXRdO1xuICAgIHZhciBpbnB1dFJhbmdlID0gYXJnc1sxICsgYXJnT2Zmc2V0XTtcbiAgICB2YXIgb3V0cHV0UmFuZ2UgPSBhcmdzWzIgKyBhcmdPZmZzZXRdO1xuICAgIHZhciBvcHRpb25zID0gYXJnc1szICsgYXJnT2Zmc2V0XTtcbiAgICB2YXIgaW50ZXJwb2xhdG9yID0gcG9wbW90aW9uLmludGVycG9sYXRlKGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCB0c2xpYi5fX2Fzc2lnbih7IG1peGVyOiBnZXRNaXhlcihvdXRwdXRSYW5nZVswXSkgfSwgb3B0aW9ucykpO1xuICAgIHJldHVybiB1c2VJbW1lZGlhdGUgPyBpbnRlcnBvbGF0b3IoaW5wdXRWYWx1ZSkgOiBpbnRlcnBvbGF0b3I7XG59XG5cbmZ1bmN0aW9uIHVzZU9uQ2hhbmdlKHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUub25DaGFuZ2UoY2FsbGJhY2spO1xuICAgIH0sIFtjYWxsYmFja10pO1xufVxuZnVuY3Rpb24gdXNlTXVsdGlPbkNoYW5nZSh2YWx1ZXMsIGhhbmRsZXIpIHtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUub25DaGFuZ2UoaGFuZGxlcik7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh1bnN1YnNjcmliZSkgeyByZXR1cm4gdW5zdWJzY3JpYmUoKTsgfSk7IH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXModmFsdWVzLCBjb21iaW5lVmFsdWVzKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB0aGUgcmV0dXJuZWQgbW90aW9uIHZhbHVlLiBUaGlzIHJlbWFpbnMgdGhlIHNhbWUgYmV0d2VlbiByZW5kZXJzLlxuICAgICAqL1xuICAgIHZhciB2YWx1ZSA9IHVzZU1vdGlvblZhbHVlKGNvbWJpbmVWYWx1ZXMoKSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHVwZGF0ZSB0aGUgdGVtcGxhdGUgbW90aW9uIHZhbHVlIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMuXG4gICAgICogVGhpcyBpcyBwcmUtYm91bmQgc28gd2hlbmV2ZXIgYSBtb3Rpb24gdmFsdWUgdXBkYXRlcyBpdCBjYW4gc2NoZWR1bGUgaXRzXG4gICAgICogZXhlY3V0aW9uIGluIEZyYW1lc3luYy4gSWYgaXQncyBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIGl0IHdvbid0IGJlIGZpcmVkIHR3aWNlXG4gICAgICogaW4gYSBzaW5nbGUgZnJhbWUuXG4gICAgICovXG4gICAgdmFyIHVwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuc2V0KGNvbWJpbmVWYWx1ZXMoKSk7IH07XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHdpdGhpbiBhIFJlYWN0IHJlbmRlciwgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBET00gYXJlIHVwLXRvLWRhdGUuXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWUoKTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYWxsIG1vdGlvbiB2YWx1ZXMgZm91bmQgd2l0aGluIHRoZSB0ZW1wbGF0ZS4gV2hlbmV2ZXIgYW55IG9mIHRoZW0gY2hhbmdlLFxuICAgICAqIHNjaGVkdWxlIGFuIHVwZGF0ZS5cbiAgICAgKi9cbiAgICB1c2VNdWx0aU9uQ2hhbmdlKHZhbHVlcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0udXBkYXRlKHVwZGF0ZVZhbHVlLCBmYWxzZSwgdHJ1ZSk7IH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNmb3JtKGlucHV0LCBpbnB1dFJhbmdlT3JUcmFuc2Zvcm1lciwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhbnNmb3JtZXIgPSB0eXBlb2YgaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyXG4gICAgICAgIDogdHJhbnNmb3JtKGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpXG4gICAgICAgID8gdXNlTGlzdFRyYW5zZm9ybShpbnB1dCwgdHJhbnNmb3JtZXIpXG4gICAgICAgIDogdXNlTGlzdFRyYW5zZm9ybShbaW5wdXRdLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHRzbGliLl9fcmVhZChfYSwgMSksIGxhdGVzdCA9IF9iWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gdXNlTGlzdFRyYW5zZm9ybSh2YWx1ZXMsIHRyYW5zZm9ybWVyKSB7XG4gICAgdmFyIGxhdGVzdCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9KTtcbiAgICByZXR1cm4gdXNlQ29tYmluZU1vdGlvblZhbHVlcyh2YWx1ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGF0ZXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHZhciBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBsYXRlc3RbaV0gPSB2YWx1ZXNbaV0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmF1bHRNb3Rpb25WYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRWYWx1ZSA9IDA7IH1cbiAgICByZXR1cm4gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVzZU1vdGlvblZhbHVlKGRlZmF1bHRWYWx1ZSk7XG59XG5mdW5jdGlvbiBSZW9yZGVySXRlbShfYSwgZXh0ZXJuYWxSZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgc3R5bGUgPSBfYS5zdHlsZSwgdmFsdWUgPSBfYS52YWx1ZSwgX2IgPSBfYS5hcywgYXMgPSBfYiA9PT0gdm9pZCAwID8gXCJsaVwiIDogX2IsIG9uRHJhZyA9IF9hLm9uRHJhZywgX2MgPSBfYS5sYXlvdXQsIGxheW91dCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIHByb3BzID0gdHNsaWIuX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcInN0eWxlXCIsIFwidmFsdWVcIiwgXCJhc1wiLCBcIm9uRHJhZ1wiLCBcImxheW91dFwiXSk7XG4gICAgdmFyIENvbXBvbmVudCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvbihhcyk7IH0pO1xuICAgIHZhciBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChSZW9yZGVyQ29udGV4dCk7XG4gICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiB1c2VEZWZhdWx0TW90aW9uVmFsdWUoc3R5bGUgPT09IG51bGwgfHwgc3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlLngpLFxuICAgICAgICB5OiB1c2VEZWZhdWx0TW90aW9uVmFsdWUoc3R5bGUgPT09IG51bGwgfHwgc3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlLnkpLFxuICAgIH07XG4gICAgdmFyIHpJbmRleCA9IHVzZVRyYW5zZm9ybShbcG9pbnQueCwgcG9pbnQueV0sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSB0c2xpYi5fX3JlYWQoX2EsIDIpLCBsYXRlc3RYID0gX2JbMF0sIGxhdGVzdFkgPSBfYlsxXTtcbiAgICAgICAgcmV0dXJuIGxhdGVzdFggfHwgbGF0ZXN0WSA/IDEgOiBcInVuc2V0XCI7XG4gICAgfSk7XG4gICAgdmFyIG1lYXN1cmVkTGF5b3V0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoQm9vbGVhbihjb250ZXh0KSwgXCJSZW9yZGVyLkl0ZW0gbXVzdCBiZSBhIGNoaWxkIG9mIFJlb3JkZXIuR3JvdXBcIik7XG4gICAgdmFyIF9kID0gY29udGV4dCwgYXhpcyA9IF9kLmF4aXMsIHJlZ2lzdGVySXRlbSA9IF9kLnJlZ2lzdGVySXRlbSwgdXBkYXRlT3JkZXIgPSBfZC51cGRhdGVPcmRlcjtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWdpc3Rlckl0ZW0odmFsdWUsIG1lYXN1cmVkTGF5b3V0LmN1cnJlbnQpO1xuICAgIH0sIFtjb250ZXh0XSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB0c2xpYi5fX2Fzc2lnbih7IGRyYWc6IGF4aXMgfSwgcHJvcHMsIHsgZHJhZ1NuYXBUb09yaWdpbjogdHJ1ZSwgc3R5bGU6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzdHlsZSksIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSwgekluZGV4OiB6SW5kZXggfSksIGxheW91dDogbGF5b3V0LCBvbkRyYWc6IGZ1bmN0aW9uIChldmVudCwgZ2VzdHVyZVBvaW50KSB7XG4gICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBnZXN0dXJlUG9pbnQudmVsb2NpdHk7XG4gICAgICAgICAgICB2ZWxvY2l0eVtheGlzXSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZU9yZGVyKHZhbHVlLCBwb2ludFtheGlzXS5nZXQoKSwgdmVsb2NpdHlbYXhpc10pO1xuICAgICAgICAgICAgb25EcmFnID09PSBudWxsIHx8IG9uRHJhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25EcmFnKGV2ZW50LCBnZXN0dXJlUG9pbnQpO1xuICAgICAgICB9LCBvbkxheW91dE1lYXN1cmU6IGZ1bmN0aW9uIChtZWFzdXJlZCkge1xuICAgICAgICAgICAgbWVhc3VyZWRMYXlvdXQuY3VycmVudCA9IG1lYXN1cmVkO1xuICAgICAgICB9LCByZWY6IGV4dGVybmFsUmVmIH0pLCBjaGlsZHJlbikpO1xufVxudmFyIEl0ZW0gPSBSZWFjdC5mb3J3YXJkUmVmKFJlb3JkZXJJdGVtKTtcblxudmFyIFJlb3JkZXIgPSB7XG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIEl0ZW06IEl0ZW0sXG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGRvbUFuaW1hdGlvbiA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgcmVuZGVyZXI6IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgfSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbnZhciBkb21NYXggPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZG9tQW5pbWF0aW9uKSwgZHJhZyksIGxheW91dEZlYXR1cmVzKSwgeyBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yOiBIVE1MUHJvamVjdGlvbk5vZGUgfSk7XG5cbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBtb3Rpb24gdmFsdWVzIGludG8gYSBuZXcgb25lIHVzaW5nIGEgc3RyaW5nIHRlbXBsYXRlIGxpdGVyYWwuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQge1xuICogICBtb3Rpb24sXG4gKiAgIHVzZVNwcmluZyxcbiAqICAgdXNlTW90aW9uVmFsdWUsXG4gKiAgIHVzZU1vdGlvblRlbXBsYXRlXG4gKiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNoYWRvd1ggPSB1c2VTcHJpbmcoMClcbiAqICAgY29uc3Qgc2hhZG93WSA9IHVzZU1vdGlvblZhbHVlKDApXG4gKiAgIGNvbnN0IHNoYWRvdyA9IHVzZU1vdGlvblRlbXBsYXRlYGRyb3Atc2hhZG93KCR7c2hhZG93WH1weCAke3NoYWRvd1l9cHggMjBweCByZ2JhKDAsMCwwLDAuMykpYFxuICpcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IGZpbHRlcjogc2hhZG93IH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblRlbXBsYXRlKGZyYWdtZW50cykge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBidWlsZCBhIHN0cmluZyBmcm9tIHRoZSBsYXRlc3QgbW90aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbnVtRnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBidWlsZFZhbHVlKCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdmFsdWVzW2ldLmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcywgYnVpbGRWYWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdGhhdCwgd2hlbiBgc2V0YCwgd2lsbCB1c2UgYSBzcHJpbmcgYW5pbWF0aW9uIHRvIGFuaW1hdGUgdG8gaXRzIG5ldyBzdGF0ZS5cbiAqXG4gKiBJdCBjYW4gZWl0aGVyIHdvcmsgYXMgYSBzdGFuZC1hbG9uZSBgTW90aW9uVmFsdWVgIGJ5IGluaXRpYWxpc2luZyBpdCB3aXRoIGEgdmFsdWUsIG9yIGFzIGEgc3Vic2NyaWJlclxuICogdG8gYW5vdGhlciBgTW90aW9uVmFsdWVgLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogYGBganN4XG4gKiBjb25zdCB4ID0gdXNlU3ByaW5nKDAsIHsgc3RpZmZuZXNzOiAzMDAgfSlcbiAqIGNvbnN0IHkgPSB1c2VTcHJpbmcoeCwgeyBkYW1waW5nOiAxMCB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGlucHV0VmFsdWUgLSBgTW90aW9uVmFsdWVgIG9yIG51bWJlci4gSWYgcHJvdmlkZWQgYSBgTW90aW9uVmFsdWVgLCB3aGVuIHRoZSBpbnB1dCBgTW90aW9uVmFsdWVgIGNoYW5nZXMsIHRoZSBjcmVhdGVkIGBNb3Rpb25WYWx1ZWAgd2lsbCBzcHJpbmcgdG93YXJkcyB0aGF0IHZhbHVlLlxuICogQHBhcmFtIHNwcmluZ0NvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHNwcmluZy5cbiAqIEByZXR1cm5zIGBNb3Rpb25WYWx1ZWBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVNwcmluZyhzb3VyY2UsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgIHZhciBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkuaXNTdGF0aWM7XG4gICAgdmFyIGFjdGl2ZVNwcmluZ0FuaW1hdGlvbiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgdmFsdWUgPSB1c2VNb3Rpb25WYWx1ZShpc01vdGlvblZhbHVlKHNvdXJjZSkgPyBzb3VyY2UuZ2V0KCkgOiBzb3VyY2UpO1xuICAgIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuYXR0YWNoKGZ1bmN0aW9uICh2LCBzZXQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBtb3JlIGhvbGxpc3RpYyBhcHByb2FjaCB0byB0aGlzIG1pZ2h0IGJlIHRvIHVzZSBpc1N0YXRpYyB0byBmaXggVmlzdWFsRWxlbWVudCBhbmltYXRpb25zXG4gICAgICAgICAgICAgKiBhdCB0aGF0IGxldmVsLCBidXQgdGhpcyB3aWxsIHdvcmsgZm9yIG5vd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNTdGF0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldCh2KTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50ID0gcG9wbW90aW9uLmFuaW1hdGUodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyBmcm9tOiB2YWx1ZS5nZXQoKSwgdG86IHYsIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpIH0sIGNvbmZpZyksIHsgb25VcGRhdGU6IHNldCB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0KCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeShjb25maWcpXSk7XG4gICAgdXNlT25DaGFuZ2Uoc291cmNlLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWUuc2V0KHBhcnNlRmxvYXQodikpOyB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdGhhdCB1cGRhdGVzIHdoZW4gdGhlIHZlbG9jaXR5IG9mIHRoZSBwcm92aWRlZCBgTW90aW9uVmFsdWVgIGNoYW5nZXMuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gKiBjb25zdCB4VmVsb2NpdHkgPSB1c2VWZWxvY2l0eSh4KVxuICogY29uc3QgeEFjY2VsZXJhdGlvbiA9IHVzZVZlbG9jaXR5KHhWZWxvY2l0eSlcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlVmVsb2NpdHkodmFsdWUpIHtcbiAgICB2YXIgdmVsb2NpdHkgPSB1c2VNb3Rpb25WYWx1ZSh2YWx1ZS5nZXRWZWxvY2l0eSgpKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5hZGQoZnVuY3Rpb24gKG5ld1ZlbG9jaXR5KSB7XG4gICAgICAgICAgICB2ZWxvY2l0eS5zZXQobmV3VmVsb2NpdHkpO1xuICAgICAgICB9KTtcbiAgICB9LCBbdmFsdWVdKTtcbiAgICByZXR1cm4gdmVsb2NpdHk7XG59XG5cbnZhciBjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHNjcm9sbFg6IG1vdGlvblZhbHVlKDApLFxuICAgIHNjcm9sbFk6IG1vdGlvblZhbHVlKDApLFxuICAgIHNjcm9sbFhQcm9ncmVzczogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWVByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbn0pOyB9O1xuZnVuY3Rpb24gdXNlU2Nyb2xsKF9hKSB7XG4gICAgaWYgKF9hID09PSB2b2lkIDApIHsgX2EgPSB7fTsgfVxuICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsIHRhcmdldCA9IF9hLnRhcmdldCwgb3B0aW9ucyA9IHRzbGliLl9fcmVzdChfYSwgW1wiY29udGFpbmVyXCIsIFwidGFyZ2V0XCJdKTtcbiAgICB2YXIgdmFsdWVzID0gdXNlQ29uc3RhbnQoY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvbS5zY3JvbGwoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFguc2V0KHguY3VycmVudCk7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWFByb2dyZXNzLnNldCh4LnByb2dyZXNzKTtcbiAgICAgICAgICAgIHZhbHVlcy5zY3JvbGxZLnNldCh5LmN1cnJlbnQpO1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFlQcm9ncmVzcy5zZXQoeS5wcm9ncmVzcyk7XG4gICAgICAgIH0sIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBjb250YWluZXI6IChjb250YWluZXIgPT09IG51bGwgfHwgY29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250YWluZXIuY3VycmVudCkgfHwgdW5kZWZpbmVkLCB0YXJnZXQ6ICh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuY3VycmVudCkgfHwgdW5kZWZpbmVkIH0pKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudFNjcm9sbChyZWYpIHtcbiAgICB3YXJuT25jZShmYWxzZSwgXCJ1c2VFbGVtZW50U2Nyb2xsIGlzIGRlcHJlY2F0ZWQuIENvbnZlcnQgdG8gdXNlU2Nyb2xsKHsgY29udGFpbmVyOiByZWYgfSkuXCIpO1xuICAgIHJldHVybiB1c2VTY3JvbGwoeyBjb250YWluZXI6IHJlZiB9KTtcbn1cblxuZnVuY3Rpb24gdXNlVmlld3BvcnRTY3JvbGwoKSB7XG4gICAgd2Fybk9uY2UoZmFsc2UsIFwidXNlVmlld3BvcnRTY3JvbGwgaXMgZGVwcmVjYXRlZC4gQ29udmVydCB0byB1c2VTY3JvbGwoKS5cIik7XG4gICAgcmV0dXJuIHVzZVNjcm9sbCgpO1xufVxuXG52YXIgZ2V0Q3VycmVudFRpbWUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpOyB9XG4gICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBEYXRlLm5vdygpOyB9O1xuZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgICB2YXIgaW5pdGlhbFRpbWVzdGFtcCA9IHVzZUNvbnN0YW50KGdldEN1cnJlbnRUaW1lKTtcbiAgICB2YXIgaXNTdGF0aWMgPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLmlzU3RhdGljO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHByb3ZpZGVUaW1lU2luY2VTdGFydCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRpbWVzdGFtcCAtIGluaXRpYWxUaW1lc3RhbXApO1xuICAgICAgICB9O1xuICAgICAgICBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS51cGRhdGUocHJvdmlkZVRpbWVTaW5jZVN0YXJ0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bmMuY2FuY2VsU3luYy51cGRhdGUocHJvdmlkZVRpbWVTaW5jZVN0YXJ0KTsgfTtcbiAgICB9LCBbY2FsbGJhY2tdKTtcbn1cblxuZnVuY3Rpb24gdXNlVGltZSgpIHtcbiAgICB2YXIgdGltZSA9IHVzZU1vdGlvblZhbHVlKDApO1xuICAgIHVzZUFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aW1lLnNldCh0KTsgfSk7XG4gICAgcmV0dXJuIHRpbWU7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBhbmltYXRpb25Db250cm9scygpIHtcbiAgICAvKipcbiAgICAgKiBUcmFjayB3aGV0aGVyIHRoZSBob3N0IGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICAgKi9cbiAgICB2YXIgaGFzTW91bnRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFBlbmRpbmcgYW5pbWF0aW9ucyB0aGF0IGFyZSBzdGFydGVkIGJlZm9yZSBhIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIFRPRE86IFJlbW92ZSB0aGlzIGFzIGFuaW1hdGlvbnMgc2hvdWxkIG9ubHkgcnVuIGluIGVmZmVjdHNcbiAgICAgKi9cbiAgICB2YXIgcGVuZGluZ0FuaW1hdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgbGlua2VkIGNvbXBvbmVudCBhbmltYXRpb24gY29udHJvbHMuXG4gICAgICovXG4gICAgdmFyIHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAgIHZhciBjb250cm9scyA9IHtcbiAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuYWRkKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgc3Vic2NyaWJlcnMuZGVsZXRlKHZpc3VhbEVsZW1lbnQpOyB9O1xuICAgICAgICB9LFxuICAgICAgICBzdGFydDogZnVuY3Rpb24gKGRlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPOiBXZSBvbmx5IHBlcmZvcm0gdGhpcyBoYXNNb3VudGVkIGNoZWNrIGJlY2F1c2UgaW4gRnJhbWVyIHdlIHVzZWQgdG9cbiAgICAgICAgICAgICAqIGVuY291cmFnZSB0aGUgYWJpbGl0eSB0byBzdGFydCBhbiBhbmltYXRpb24gd2l0aGluIHRoZSByZW5kZXIgcGhhc2UuIFRoaXNcbiAgICAgICAgICAgICAqIGlzbid0IGJlaGF2aW91ciBjb25jdXJyZW50LXNhZmUgc28gd2hlbiB3ZSBtYWtlIEZyYW1lciBjb25jdXJyZW50LXNhZmVcbiAgICAgICAgICAgICAqIHdlIGNhbiBkaXRjaCB0aGlzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaGFzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25zXzEgPSBbXTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNfMS5wdXNoKGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25PdmVycmlkZTogdHJhbnNpdGlvbk92ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0FuaW1hdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IFtkZWZpbml0aW9uLCB0cmFuc2l0aW9uT3ZlcnJpZGVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoaGFzTW91bnRlZCwgXCJjb250cm9scy5zZXQoKSBzaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQgaGFzIG1vdW50ZWQuIENvbnNpZGVyIGNhbGxpbmcgd2l0aGluIGEgdXNlRWZmZWN0IGhvb2suXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZXModmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHN0b3BBbmltYXRpb24odmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGVuZGluZ0FuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX2EuYW5pbWF0aW9uLCByZXNvbHZlID0gX2EucmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBjb250cm9scy5zdGFydC5hcHBseShjb250cm9scywgdHNsaWIuX19zcHJlYWRBcnJheShbXSwgdHNsaWIuX19yZWFkKGFuaW1hdGlvbiksIGZhbHNlKSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBoYXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udHJvbHMuc3RvcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBjb250cm9scztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGBBbmltYXRpb25Db250cm9sc2AsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IHN0YXJ0LCBzdG9wXG4gKiBhbmQgc2VxdWVuY2UgYW5pbWF0aW9ucyBvbiBvbmUgb3IgbW9yZSBjb21wb25lbnRzLlxuICpcbiAqIFRoZSByZXR1cm5lZCBgQW5pbWF0aW9uQ29udHJvbHNgIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGBhbmltYXRlYCBwcm9wZXJ0eVxuICogb2YgdGhlIGNvbXBvbmVudHMgeW91IHdhbnQgdG8gYW5pbWF0ZS5cbiAqXG4gKiBUaGVzZSBjb21wb25lbnRzIGNhbiB0aGVuIGJlIGFuaW1hdGVkIHdpdGggdGhlIGBzdGFydGAgbWV0aG9kLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyBtb3Rpb24sIHVzZUFuaW1hdGlvbiB9IGZyb20gJ2ZyYW1lci1tb3Rpb24nXG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIE15Q29tcG9uZW50KHByb3BzKSB7XG4gKiAgICBjb25zdCBjb250cm9scyA9IHVzZUFuaW1hdGlvbigpXG4gKlxuICogICAgY29udHJvbHMuc3RhcnQoe1xuICogICAgICAgIHg6IDEwMCxcbiAqICAgICAgICB0cmFuc2l0aW9uOiB7IGR1cmF0aW9uOiAwLjUgfSxcbiAqICAgIH0pXG4gKlxuICogICAgcmV0dXJuIDxtb3Rpb24uZGl2IGFuaW1hdGU9e2NvbnRyb2xzfSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybnMgQW5pbWF0aW9uIGNvbnRyb2xsZXIgd2l0aCBgc3RhcnRgIGFuZCBgc3RvcGAgbWV0aG9kc1xuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlQW5pbWF0aW9uQ29udHJvbHMoKSB7XG4gICAgdmFyIGNvbnRyb2xzID0gdXNlQ29uc3RhbnQoYW5pbWF0aW9uQ29udHJvbHMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChjb250cm9scy5tb3VudCwgW10pO1xuICAgIHJldHVybiBjb250cm9scztcbn1cbnZhciB1c2VBbmltYXRpb24gPSB1c2VBbmltYXRpb25Db250cm9scztcblxuLyoqXG4gKiBDeWNsZXMgdGhyb3VnaCBhIHNlcmllcyBvZiB2aXN1YWwgcHJvcGVydGllcy4gQ2FuIGJlIHVzZWQgdG8gdG9nZ2xlIGJldHdlZW4gb3IgY3ljbGUgdGhyb3VnaCBhbmltYXRpb25zLiBJdCB3b3JrcyBzaW1pbGFyIHRvIGB1c2VTdGF0ZWAgaW4gUmVhY3QuIEl0IGlzIHByb3ZpZGVkIGFuIGluaXRpYWwgYXJyYXkgb2YgcG9zc2libGUgc3RhdGVzLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0d28gYXJndW1lbnRzLlxuICpcbiAqIEFuIGluZGV4IHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGBjeWNsZWAgZnVuY3Rpb24gdG8gY3ljbGUgdG8gYSBzcGVjaWZpYyBpbmRleC5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG4gKiBpbXBvcnQgeyBtb3Rpb24sIHVzZUN5Y2xlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW3gsIGN5Y2xlWF0gPSB1c2VDeWNsZSgwLCA1MCwgMTAwKVxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8bW90aW9uLmRpdlxuICogICAgICAgYW5pbWF0ZT17eyB4OiB4IH19XG4gKiAgICAgICBvblRhcD17KCkgPT4gY3ljbGVYKCl9XG4gKiAgICAgIC8+XG4gKiAgICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaXRlbXMgLSBpdGVtcyB0byBjeWNsZSB0aHJvdWdoXG4gKiBAcmV0dXJucyBbY3VycmVudFN0YXRlLCBjeWNsZVN0YXRlXVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlQ3ljbGUoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHZhciBfYSA9IHRzbGliLl9fcmVhZChSZWFjdC51c2VTdGF0ZShpdGVtc1tpbmRleC5jdXJyZW50XSksIDIpLCBpdGVtID0gX2FbMF0sIHNldEl0ZW0gPSBfYVsxXTtcbiAgICB2YXIgcnVuQ3ljbGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBpbmRleC5jdXJyZW50ID1cbiAgICAgICAgICAgIHR5cGVvZiBuZXh0ICE9PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgPyBwb3Btb3Rpb24ud3JhcCgwLCBpdGVtcy5sZW5ndGgsIGluZGV4LmN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICAgIDogbmV4dDtcbiAgICAgICAgc2V0SXRlbShpdGVtc1tpbmRleC5jdXJyZW50XSk7XG4gICAgfSwgdHNsaWIuX19zcHJlYWRBcnJheShbaXRlbXMubGVuZ3RoXSwgdHNsaWIuX19yZWFkKGl0ZW1zKSwgZmFsc2UpKTtcbiAgICByZXR1cm4gW2l0ZW0sIHJ1bkN5Y2xlXTtcbn1cblxuZnVuY3Rpb24gdXNlSW5WaWV3KHJlZiwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgcm9vdCA9IF9iLnJvb3QsIG1hcmdpbiA9IF9iLm1hcmdpbiwgYW1vdW50ID0gX2IuYW1vdW50LCBfYyA9IF9iLm9uY2UsIG9uY2UgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYztcbiAgICB2YXIgX2QgPSB0c2xpYi5fX3JlYWQoUmVhY3QudXNlU3RhdGUoZmFsc2UpLCAyKSwgaXNJblZpZXcgPSBfZFswXSwgc2V0SW5WaWV3ID0gX2RbMV07XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlZi5jdXJyZW50IHx8IChvbmNlICYmIGlzSW5WaWV3KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9uRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRJblZpZXcodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gb25jZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldEluVmlldyhmYWxzZSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgcm9vdDogKF9hID0gcm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LmN1cnJlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQgPT09IFwic29tZVwiID8gXCJhbnlcIiA6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRvbS5pblZpZXcocmVmLmN1cnJlbnQsIG9uRW50ZXIsIG9wdGlvbnMpO1xuICAgIH0sIFtyb290LCByZWYsIG1hcmdpbiwgb25jZV0pO1xuICAgIHJldHVybiBpc0luVmlldztcbn1cblxuLyoqXG4gKiBDYW4gbWFudWFsbHkgdHJpZ2dlciBhIGRyYWcgZ2VzdHVyZSBvbiBvbmUgb3IgbW9yZSBgZHJhZ2AtZW5hYmxlZCBgbW90aW9uYCBjb21wb25lbnRzLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgZHJhZ0NvbnRyb2xzID0gdXNlRHJhZ0NvbnRyb2xzKClcbiAqXG4gKiBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAqICAgZHJhZ0NvbnRyb2xzLnN0YXJ0KGV2ZW50LCB7IHNuYXBUb0N1cnNvcjogdHJ1ZSB9KVxuICogfVxuICpcbiAqIHJldHVybiAoXG4gKiAgIDw+XG4gKiAgICAgPGRpdiBvblBvaW50ZXJEb3duPXtzdGFydERyYWd9IC8+XG4gKiAgICAgPG1vdGlvbi5kaXYgZHJhZz1cInhcIiBkcmFnQ29udHJvbHM9e2RyYWdDb250cm9sc30gLz5cbiAqICAgPC8+XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBEcmFnQ29udHJvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJhZ0NvbnRyb2xzKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRyb2xzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgYSBjb21wb25lbnQncyBpbnRlcm5hbCBgVmlzdWFsRWxlbWVudERyYWdDb250cm9sc2AgdG8gdGhlIHVzZXItZmFjaW5nIEFQSS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERyYWdDb250cm9scy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMuYWRkKGNvbnRyb2xzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbXBvbmVudENvbnRyb2xzLmRlbGV0ZShjb250cm9scyk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGRyYWcgZ2VzdHVyZSBvbiBldmVyeSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBoYXMgdGhpcyBzZXQgb2YgZHJhZyBjb250cm9sc1xuICAgICAqIHBhc3NlZCBpbnRvIGl0IHZpYSB0aGUgYGRyYWdDb250cm9sc2AgcHJvcC5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGRyYWdDb250cm9scy5zdGFydChlLCB7XG4gICAgICogICBzbmFwVG9DdXJzb3I6IHRydWVcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gUG9pbnRlckV2ZW50XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgRHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gICAgICAgICAgICBjb250cm9scy5zdGFydChldmVudC5uYXRpdmVFdmVudCB8fCBldmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERyYWdDb250cm9scztcbn0oKSk7XG52YXIgY3JlYXRlRHJhZ0NvbnRyb2xzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERyYWdDb250cm9scygpOyB9O1xuLyoqXG4gKiBVc3VhbGx5LCBkcmFnZ2luZyBpcyBpbml0aWF0ZWQgYnkgcHJlc3NpbmcgZG93biBvbiBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoIGEgYGRyYWdgIHByb3BcbiAqIGFuZCBtb3ZpbmcgaXQuIEZvciBzb21lIHVzZS1jYXNlcywgZm9yIGluc3RhbmNlIGNsaWNraW5nIGF0IGFuIGFyYml0cmFyeSBwb2ludCBvbiBhIHZpZGVvIHNjcnViYmVyLCB3ZVxuICogbWlnaHQgd2FudCB0byBpbml0aWF0ZSB0aGF0IGRyYWdnaW5nIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IHRoYW4gdGhlIGRyYWdnYWJsZSBvbmUuXG4gKlxuICogQnkgY3JlYXRpbmcgYSBgZHJhZ0NvbnRyb2xzYCB1c2luZyB0aGUgYHVzZURyYWdDb250cm9sc2AgaG9vaywgd2UgY2FuIHBhc3MgdGhpcyBpbnRvXG4gKiB0aGUgZHJhZ2dhYmxlIGNvbXBvbmVudCdzIGBkcmFnQ29udHJvbHNgIHByb3AuIEl0IGV4cG9zZXMgYSBgc3RhcnRgIG1ldGhvZFxuICogdGhhdCBjYW4gc3RhcnQgZHJhZ2dpbmcgZnJvbSBwb2ludGVyIGV2ZW50cyBvbiBvdGhlciBjb21wb25lbnRzLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgZHJhZ0NvbnRyb2xzID0gdXNlRHJhZ0NvbnRyb2xzKClcbiAqXG4gKiBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAqICAgZHJhZ0NvbnRyb2xzLnN0YXJ0KGV2ZW50LCB7IHNuYXBUb0N1cnNvcjogdHJ1ZSB9KVxuICogfVxuICpcbiAqIHJldHVybiAoXG4gKiAgIDw+XG4gKiAgICAgPGRpdiBvblBvaW50ZXJEb3duPXtzdGFydERyYWd9IC8+XG4gKiAgICAgPG1vdGlvbi5kaXYgZHJhZz1cInhcIiBkcmFnQ29udHJvbHM9e2RyYWdDb250cm9sc30gLz5cbiAqICAgPC8+XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZURyYWdDb250cm9scygpIHtcbiAgICByZXR1cm4gdXNlQ29uc3RhbnQoY3JlYXRlRHJhZ0NvbnRyb2xzKTtcbn1cblxuZnVuY3Rpb24gdXNlSW5zdGFudExheW91dFRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHN0YXJ0VHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihjYikge1xuICAgIGlmICghcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudC5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQuYmxvY2tVcGRhdGUoKTtcbiAgICBjYiA9PT0gbnVsbCB8fCBjYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2IoKTtcbn1cblxuZnVuY3Rpb24gdXNlSW5zdGFudFRyYW5zaXRpb24oKSB7XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKHVzZUZvcmNlVXBkYXRlKCksIDIpLCBmb3JjZVVwZGF0ZSA9IF9hWzBdLCBmb3JjZWRSZW5kZXJDb3VudCA9IF9hWzFdO1xuICAgIHZhciBzdGFydEluc3RhbnRMYXlvdXRUcmFuc2l0aW9uID0gdXNlSW5zdGFudExheW91dFRyYW5zaXRpb24oKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5ibG9jayBhZnRlciB0d28gYW5pbWF0aW9uIGZyYW1lcywgb3RoZXJ3aXNlIHRoaXMgd2lsbCB1bmJsb2NrIHRvbyBzb29uLlxuICAgICAgICAgKi9cbiAgICAgICAgc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucG9zdFJlbmRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0ucG9zdFJlbmRlcihmdW5jdGlvbiAoKSB7IHJldHVybiAoaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQgPSBmYWxzZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbZm9yY2VkUmVuZGVyQ291bnRdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHN0YXJ0SW5zdGFudExheW91dFRyYW5zaXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlc2V0UHJvamVjdGlvbigpIHtcbiAgICB2YXIgcmVzZXQgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSByb290UHJvamVjdGlvbk5vZGUuY3VycmVudDtcbiAgICAgICAgaWYgKCFyb290KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByb290LnJlc2V0VHJlZSgpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVzZXQ7XG59XG5cbnZhciBjcmVhdGVPYmplY3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe30pOyB9O1xudmFyIHN0YXRlVmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQoe1xuICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgbWVhc3VyZVZpZXdwb3J0Qm94OiBjcmVhdGVCb3gsXG4gICAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHsgfSxcbiAgICByZXN0b3JlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IGNyZWF0ZU9iamVjdCxcbiAgICByZWFkVmFsdWVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChfc3RhdGUsIGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsU3RhdGVba2V5XSB8fCAwO1xuICAgIH0sXG4gICAgbWFrZVRhcmdldEFuaW1hdGFibGU6IGZ1bmN0aW9uIChlbGVtZW50LCBfYSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IF9hLnRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQgPSBfYS50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24gfHwge30sIGVsZW1lbnQpO1xuICAgICAgICBjaGVja1RhcmdldEZvck5ld1ZhbHVlcyhlbGVtZW50LCB0YXJnZXQsIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IHRyYW5zaXRpb246IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfSwgdGFyZ2V0KTtcbiAgICB9LFxufSk7XG52YXIgdXNlVmlzdWFsU3RhdGUgPSBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogY3JlYXRlT2JqZWN0LFxuICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVPYmplY3QsXG59KTtcbi8qKlxuICogVGhpcyBpcyBub3QgYW4gb2ZmaWNpYWxseSBzdXBwb3J0ZWQgQVBJIGFuZCBtYXkgYmUgcmVtb3ZlZFxuICogb24gYW55IHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIHVzZUFuaW1hdGVkU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgdmFyIF9hID0gdHNsaWIuX19yZWFkKFJlYWN0LnVzZVN0YXRlKGluaXRpYWxTdGF0ZSksIDIpLCBhbmltYXRpb25TdGF0ZSA9IF9hWzBdLCBzZXRBbmltYXRpb25TdGF0ZSA9IF9hWzFdO1xuICAgIHZhciB2aXN1YWxTdGF0ZSA9IHVzZVZpc3VhbFN0YXRlKHt9LCBmYWxzZSk7XG4gICAgdmFyIGVsZW1lbnQgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVZpc3VhbEVsZW1lbnQoeyBwcm9wczoge30sIHZpc3VhbFN0YXRlOiB2aXN1YWxTdGF0ZSB9LCB7IGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlIH0pO1xuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsZW1lbnQubW91bnQoe30pO1xuICAgICAgICByZXR1cm4gZWxlbWVudC51bm1vdW50O1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5zZXRQcm9wcyh7XG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBzZXRBbmltYXRpb25TdGF0ZSh0c2xpYi5fX2Fzc2lnbih7fSwgdikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW3NldEFuaW1hdGlvblN0YXRlLCBlbGVtZW50XSk7XG4gICAgdmFyIHN0YXJ0QW5pbWF0aW9uID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGVWaXN1YWxFbGVtZW50KGVsZW1lbnQsIGFuaW1hdGlvbkRlZmluaXRpb24pO1xuICAgIH07IH0pO1xuICAgIHJldHVybiBbYW5pbWF0aW9uU3RhdGUsIHN0YXJ0QW5pbWF0aW9uXTtcbn1cblxuLy8gS2VlcCB0aGluZ3MgcmVhc29uYWJsZSBhbmQgYXZvaWQgc2NhbGU6IEluZmluaXR5LiBJbiBwcmFjdGlzZSB3ZSBtaWdodCBuZWVkXG4vLyB0byBhZGQgYW5vdGhlciB2YWx1ZSwgb3BhY2l0eSwgdGhhdCBjb3VsZCBpbnRlcnBvbGF0ZSBzY2FsZVgvWSBbMCwwLjAxXSA9PiBbMCwxXVxuLy8gdG8gc2ltcGx5IGhpZGUgY29udGVudCBhdCB1bnJlYXNvbmFibGUgc2NhbGVzLlxudmFyIG1heFNjYWxlID0gMTAwMDAwO1xudmFyIGludmVydFNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlID4gMC4wMDEgPyAxIC8gc2NhbGUgOiBtYXhTY2FsZTtcbn07XG52YXIgaGFzV2FybmVkID0gZmFsc2U7XG4vKipcbiAqIFJldHVybnMgYSBgTW90aW9uVmFsdWVgIGVhY2ggZm9yIGBzY2FsZVhgIGFuZCBgc2NhbGVZYCB0aGF0IHVwZGF0ZSB3aXRoIHRoZSBpbnZlcnNlXG4gKiBvZiB0aGVpciByZXNwZWN0aXZlIHBhcmVudCBzY2FsZXMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHVuZG9pbmcgdGhlIGRpc3RvcnRpb24gb2YgY29udGVudCB3aGVuIHNjYWxpbmcgYSBwYXJlbnQgY29tcG9uZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIGB1c2VJbnZlcnRlZFNjYWxlYCB3aWxsIGF1dG9tYXRpY2FsbHkgZmV0Y2ggYHNjYWxlWGAgYW5kIGBzY2FsZVlgIGZyb20gdGhlIG5lYXJlc3QgcGFyZW50LlxuICogQnkgcGFzc2luZyBvdGhlciBgTW90aW9uVmFsdWVgcyBpbiBhcyBgdXNlSW52ZXJ0ZWRTY2FsZSh7IHNjYWxlWCwgc2NhbGVZIH0pYCwgaXQgd2lsbCBpbnZlcnQgdGhlIG91dHB1dFxuICogb2YgdGhvc2UgaW5zdGVhZC5cbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB1c2VJbnZlcnRlZFNjYWxlKClcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IHNjYWxlWCwgc2NhbGVZIH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiB1c2VJbnZlcnRlZFNjYWxlKHNjYWxlKSB7XG4gICAgdmFyIHBhcmVudFNjYWxlWCA9IHVzZU1vdGlvblZhbHVlKDEpO1xuICAgIHZhciBwYXJlbnRTY2FsZVkgPSB1c2VNb3Rpb25WYWx1ZSgxKTtcbiAgICB2YXIgdmlzdWFsRWxlbWVudCA9IHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCk7XG4gICAgaGV5TGlzdGVuLmludmFyaWFudCghIShzY2FsZSB8fCB2aXN1YWxFbGVtZW50KSwgXCJJZiBubyBzY2FsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCB1c2VJbnZlcnRlZFNjYWxlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBjaGlsZCBvZiBhbm90aGVyIG1vdGlvbiBjb21wb25lbnQuXCIpO1xuICAgIGhleUxpc3Rlbi53YXJuaW5nKGhhc1dhcm5lZCwgXCJ1c2VJbnZlcnRlZFNjYWxlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuIFVzZSB0aGUgbGF5b3V0IHByb3AgaW5zdGVhZC5cIik7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgcGFyZW50U2NhbGVYID0gc2NhbGUuc2NhbGVYIHx8IHBhcmVudFNjYWxlWDtcbiAgICAgICAgcGFyZW50U2NhbGVZID0gc2NhbGUuc2NhbGVZIHx8IHBhcmVudFNjYWxlWTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICBwYXJlbnRTY2FsZVggPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKFwic2NhbGVYXCIsIDEpO1xuICAgICAgICBwYXJlbnRTY2FsZVkgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKFwic2NhbGVZXCIsIDEpO1xuICAgIH1cbiAgICB2YXIgc2NhbGVYID0gdXNlVHJhbnNmb3JtKHBhcmVudFNjYWxlWCwgaW52ZXJ0U2NhbGUpO1xuICAgIHZhciBzY2FsZVkgPSB1c2VUcmFuc2Zvcm0ocGFyZW50U2NhbGVZLCBpbnZlcnRTY2FsZSk7XG4gICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG59XG5cbmV4cG9ydHMuQW5pbWF0ZVByZXNlbmNlID0gQW5pbWF0ZVByZXNlbmNlO1xuZXhwb3J0cy5BbmltYXRlU2hhcmVkTGF5b3V0ID0gQW5pbWF0ZVNoYXJlZExheW91dDtcbmV4cG9ydHMuRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCA9IERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQ7XG5leHBvcnRzLkRyYWdDb250cm9scyA9IERyYWdDb250cm9scztcbmV4cG9ydHMuRmxhdFRyZWUgPSBGbGF0VHJlZTtcbmV4cG9ydHMuTGF5b3V0R3JvdXAgPSBMYXlvdXRHcm91cDtcbmV4cG9ydHMuTGF5b3V0R3JvdXBDb250ZXh0ID0gTGF5b3V0R3JvdXBDb250ZXh0O1xuZXhwb3J0cy5MYXp5TW90aW9uID0gTGF6eU1vdGlvbjtcbmV4cG9ydHMuTW90aW9uQ29uZmlnID0gTW90aW9uQ29uZmlnO1xuZXhwb3J0cy5Nb3Rpb25Db25maWdDb250ZXh0ID0gTW90aW9uQ29uZmlnQ29udGV4dDtcbmV4cG9ydHMuTW90aW9uQ29udGV4dCA9IE1vdGlvbkNvbnRleHQ7XG5leHBvcnRzLk1vdGlvblZhbHVlID0gTW90aW9uVmFsdWU7XG5leHBvcnRzLlByZXNlbmNlQ29udGV4dCA9IFByZXNlbmNlQ29udGV4dDtcbmV4cG9ydHMuUmVvcmRlciA9IFJlb3JkZXI7XG5leHBvcnRzLlN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9IFN3aXRjaExheW91dEdyb3VwQ29udGV4dDtcbmV4cG9ydHMuYWRkUG9pbnRlckV2ZW50ID0gYWRkUG9pbnRlckV2ZW50O1xuZXhwb3J0cy5hZGRTY2FsZUNvcnJlY3RvciA9IGFkZFNjYWxlQ29ycmVjdG9yO1xuZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbmV4cG9ydHMuYW5pbWF0ZVZpc3VhbEVsZW1lbnQgPSBhbmltYXRlVmlzdWFsRWxlbWVudDtcbmV4cG9ydHMuYW5pbWF0aW9uQ29udHJvbHMgPSBhbmltYXRpb25Db250cm9scztcbmV4cG9ydHMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5leHBvcnRzLmNhbGNMZW5ndGggPSBjYWxjTGVuZ3RoO1xuZXhwb3J0cy5jaGVja1RhcmdldEZvck5ld1ZhbHVlcyA9IGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzO1xuZXhwb3J0cy5jcmVhdGVCb3ggPSBjcmVhdGVCb3g7XG5leHBvcnRzLmNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCA9IGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudDtcbmV4cG9ydHMuY3JlYXRlTW90aW9uQ29tcG9uZW50ID0gY3JlYXRlTW90aW9uQ29tcG9uZW50O1xuZXhwb3J0cy5kb21BbmltYXRpb24gPSBkb21BbmltYXRpb247XG5leHBvcnRzLmRvbU1heCA9IGRvbU1heDtcbmV4cG9ydHMuZmlsdGVyUHJvcHMgPSBmaWx0ZXJQcm9wcztcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xuZXhwb3J0cy5pc0RyYWdBY3RpdmUgPSBpc0RyYWdBY3RpdmU7XG5leHBvcnRzLmlzTW90aW9uVmFsdWUgPSBpc01vdGlvblZhbHVlO1xuZXhwb3J0cy5pc1ZhbGlkTW90aW9uUHJvcCA9IGlzVmFsaWRNb3Rpb25Qcm9wO1xuZXhwb3J0cy5tID0gbTtcbmV4cG9ydHMubWFrZVVzZVZpc3VhbFN0YXRlID0gbWFrZVVzZVZpc3VhbFN0YXRlO1xuZXhwb3J0cy5tb3Rpb24gPSBtb3Rpb247XG5leHBvcnRzLm1vdGlvblZhbHVlID0gbW90aW9uVmFsdWU7XG5leHBvcnRzLnJlc29sdmVNb3Rpb25WYWx1ZSA9IHJlc29sdmVNb3Rpb25WYWx1ZTtcbmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZXhwb3J0cy51c2VBbmltYXRpb24gPSB1c2VBbmltYXRpb247XG5leHBvcnRzLnVzZUFuaW1hdGlvbkNvbnRyb2xzID0gdXNlQW5pbWF0aW9uQ29udHJvbHM7XG5leHBvcnRzLnVzZUFuaW1hdGlvbkZyYW1lID0gdXNlQW5pbWF0aW9uRnJhbWU7XG5leHBvcnRzLnVzZUN5Y2xlID0gdXNlQ3ljbGU7XG5leHBvcnRzLnVzZURlcHJlY2F0ZWRBbmltYXRlZFN0YXRlID0gdXNlQW5pbWF0ZWRTdGF0ZTtcbmV4cG9ydHMudXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUgPSB1c2VJbnZlcnRlZFNjYWxlO1xuZXhwb3J0cy51c2VEb21FdmVudCA9IHVzZURvbUV2ZW50O1xuZXhwb3J0cy51c2VEcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHM7XG5leHBvcnRzLnVzZUVsZW1lbnRTY3JvbGwgPSB1c2VFbGVtZW50U2Nyb2xsO1xuZXhwb3J0cy51c2VGb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlO1xuZXhwb3J0cy51c2VJblZpZXcgPSB1c2VJblZpZXc7XG5leHBvcnRzLnVzZUluc3RhbnRMYXlvdXRUcmFuc2l0aW9uID0gdXNlSW5zdGFudExheW91dFRyYW5zaXRpb247XG5leHBvcnRzLnVzZUluc3RhbnRUcmFuc2l0aW9uID0gdXNlSW5zdGFudFRyYW5zaXRpb247XG5leHBvcnRzLnVzZUlzUHJlc2VudCA9IHVzZUlzUHJlc2VudDtcbmV4cG9ydHMudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1vdGlvblRlbXBsYXRlID0gdXNlTW90aW9uVGVtcGxhdGU7XG5leHBvcnRzLnVzZU1vdGlvblZhbHVlID0gdXNlTW90aW9uVmFsdWU7XG5leHBvcnRzLnVzZVByZXNlbmNlID0gdXNlUHJlc2VuY2U7XG5leHBvcnRzLnVzZVJlZHVjZWRNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uO1xuZXhwb3J0cy51c2VSZWR1Y2VkTW90aW9uQ29uZmlnID0gdXNlUmVkdWNlZE1vdGlvbkNvbmZpZztcbmV4cG9ydHMudXNlUmVzZXRQcm9qZWN0aW9uID0gdXNlUmVzZXRQcm9qZWN0aW9uO1xuZXhwb3J0cy51c2VTY3JvbGwgPSB1c2VTY3JvbGw7XG5leHBvcnRzLnVzZVNwcmluZyA9IHVzZVNwcmluZztcbmV4cG9ydHMudXNlVGltZSA9IHVzZVRpbWU7XG5leHBvcnRzLnVzZVRyYW5zZm9ybSA9IHVzZVRyYW5zZm9ybTtcbmV4cG9ydHMudXNlVW5tb3VudEVmZmVjdCA9IHVzZVVubW91bnRFZmZlY3Q7XG5leHBvcnRzLnVzZVZlbG9jaXR5ID0gdXNlVmVsb2NpdHk7XG5leHBvcnRzLnVzZVZpZXdwb3J0U2Nyb2xsID0gdXNlVmlld3BvcnRTY3JvbGw7XG5leHBvcnRzLnVzZVZpc3VhbEVsZW1lbnRDb250ZXh0ID0gdXNlVmlzdWFsRWxlbWVudENvbnRleHQ7XG5leHBvcnRzLnZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50O1xuZXhwb3J0cy53cmFwSGFuZGxlciA9IHdyYXBIYW5kbGVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWIiLCJyZXF1aXJlIiwiUmVhY3QiLCJoZXlMaXN0ZW4iLCJzdHlsZVZhbHVlVHlwZXMiLCJwb3Btb3Rpb24iLCJzeW5jIiwiZG9tIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiX19lc01vZHVsZSIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsIlJlYWN0X19uYW1lc3BhY2UiLCJSZWFjdF9fZGVmYXVsdCIsInN5bmNfX2RlZmF1bHQiLCJkZWZhdWx0RW52aXJvbm1lbnQiLCJlbnYiLCJwcm9jZXNzIiwidW5kZWZpbmVkIiwiY3JlYXRlRGVmaW5pdGlvbiIsInByb3BOYW1lcyIsImlzRW5hYmxlZCIsInByb3BzIiwic29tZSIsIm5hbWUiLCJmZWF0dXJlRGVmaW5pdGlvbnMiLCJtZWFzdXJlTGF5b3V0IiwiYW5pbWF0aW9uIiwiZXhpdCIsImRyYWciLCJmb2N1cyIsImhvdmVyIiwidGFwIiwicGFuIiwiaW5WaWV3IiwibG9hZEZlYXR1cmVzIiwiZmVhdHVyZXMiLCJrZXkiLCJwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yIiwiQ29tcG9uZW50IiwiTGF6eUNvbnRleHQiLCJjcmVhdGVDb250ZXh0Iiwic3RyaWN0IiwiZmVhdHVyZU5hbWVzIiwibnVtRmVhdHVyZXMiLCJsZW5ndGgiLCJ1c2VGZWF0dXJlcyIsInZpc3VhbEVsZW1lbnQiLCJwcmVsb2FkZWRGZWF0dXJlcyIsImxhenlDb250ZXh0IiwidXNlQ29udGV4dCIsImludmFyaWFudCIsImkiLCJuYW1lXzEiLCJfYSIsInB1c2giLCJjcmVhdGVFbGVtZW50IiwiX19hc3NpZ24iLCJNb3Rpb25Db25maWdDb250ZXh0IiwidHJhbnNmb3JtUGFnZVBvaW50IiwicCIsImlzU3RhdGljIiwicmVkdWNlZE1vdGlvbiIsIk1vdGlvbkNvbnRleHQiLCJ1c2VWaXN1YWxFbGVtZW50Q29udGV4dCIsIlByZXNlbmNlQ29udGV4dCIsImlzQnJvd3NlciIsImRvY3VtZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwiY3VycmVudCIsImhhc0RldGVjdGVkIiwiaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIm1vdGlvbk1lZGlhUXVlcnlfMSIsInNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyIsIm1hdGNoZXMiLCJhZGRMaXN0ZW5lciIsInVzZVJlZHVjZWRNb3Rpb24iLCJfX3JlYWQiLCJ1c2VTdGF0ZSIsInNob3VsZFJlZHVjZU1vdGlvbiIsInVzZVJlZHVjZWRNb3Rpb25Db25maWciLCJyZWR1Y2VkTW90aW9uUHJlZmVyZW5jZSIsInVzZVZpc3VhbEVsZW1lbnQiLCJ2aXN1YWxTdGF0ZSIsImNyZWF0ZVZpc3VhbEVsZW1lbnQiLCJwYXJlbnQiLCJwcmVzZW5jZUNvbnRleHQiLCJ2aXN1YWxFbGVtZW50UmVmIiwidXNlUmVmIiwicmVuZGVyZXIiLCJwcmVzZW5jZUlkIiwiaWQiLCJibG9ja0luaXRpYWxBbmltYXRpb24iLCJpbml0aWFsIiwic3luY1JlbmRlciIsImFuaW1hdGlvblN0YXRlIiwiYW5pbWF0ZUNoYW5nZXMiLCJub3RpZnlVbm1vdW50IiwiaXNSZWZPYmplY3QiLCJyZWYiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ1c2VNb3Rpb25SZWYiLCJleHRlcm5hbFJlZiIsInVzZUNhbGxiYWNrIiwiaW5zdGFuY2UiLCJtb3VudCIsInVubW91bnQiLCJpc1ZhcmlhbnRMYWJlbHMiLCJ2IiwiQXJyYXkiLCJpc0FycmF5IiwiaXNWYXJpYW50TGFiZWwiLCJnZXRDdXJyZW50IiwiZm9yRWFjaFZhbHVlIiwiZ2V0VmVsb2NpdHkkMSIsInZlbG9jaXR5IiwiZ2V0VmVsb2NpdHkiLCJyZXNvbHZlVmFyaWFudEZyb21Qcm9wcyIsImRlZmluaXRpb24iLCJjdXN0b20iLCJjdXJyZW50VmFsdWVzIiwiY3VycmVudFZlbG9jaXR5IiwidmFyaWFudHMiLCJyZXNvbHZlVmFyaWFudCIsImdldFByb3BzIiwiY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMiLCJhbmltYXRlIiwic3RhcnQiLCJ3aGlsZUhvdmVyIiwid2hpbGVEcmFnIiwid2hpbGVUYXAiLCJ3aGlsZUZvY3VzIiwiY2hlY2tJZlZhcmlhbnROb2RlIiwiQm9vbGVhbiIsImdldEN1cnJlbnRUcmVlVmFyaWFudHMiLCJjb250ZXh0IiwiaW5oZXJpdCIsInVzZUNyZWF0ZU1vdGlvbkNvbnRleHQiLCJ1c2VNZW1vIiwidmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeSIsInByb3AiLCJqb2luIiwidXNlQ29uc3RhbnQiLCJpbml0IiwiZ2xvYmFsUHJvamVjdGlvblN0YXRlIiwiaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSIsImhhc0V2ZXJVcGRhdGVkIiwiaWQkMSIsInVzZVByb2plY3Rpb25JZCIsIkxheW91dEdyb3VwQ29udGV4dCIsIlN3aXRjaExheW91dEdyb3VwQ29udGV4dCIsInVzZVByb2plY3Rpb24iLCJwcm9qZWN0aW9uSWQiLCJQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yIiwiX2IiLCJsYXlvdXRJZCIsImxheW91dCIsImRyYWdDb25zdHJhaW50cyIsImxheW91dFNjcm9sbCIsImluaXRpYWxQcm9tb3Rpb25Db25maWciLCJwcm9qZWN0aW9uIiwiZ2V0TGF0ZXN0VmFsdWVzIiwic2V0T3B0aW9ucyIsImFsd2F5c01lYXN1cmVMYXlvdXQiLCJzY2hlZHVsZVJlbmRlciIsImFuaW1hdGlvblR5cGUiLCJWaXN1YWxFbGVtZW50SGFuZGxlciIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsImFwcGx5IiwiYXJndW1lbnRzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJ1cGRhdGVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInNldFByb3BzIiwicmVuZGVyIiwiY2hpbGRyZW4iLCJjcmVhdGVNb3Rpb25Db21wb25lbnQiLCJ1c2VSZW5kZXIiLCJ1c2VWaXN1YWxTdGF0ZSIsIk1vdGlvbkNvbXBvbmVudCIsInVzZUxheW91dElkIiwiY29uZmlnIiwiUHJvdmlkZXIiLCJmb3J3YXJkUmVmIiwibGF5b3V0R3JvdXBJZCIsImNyZWF0ZU1vdGlvblByb3h5IiwiY3JlYXRlQ29uZmlnIiwiY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnIiwiUHJveHkiLCJjb21wb25lbnRDYWNoZSIsIk1hcCIsIl90YXJnZXQiLCJoYXMiLCJzZXQiLCJsb3dlcmNhc2VTVkdFbGVtZW50cyIsImlzU1ZHQ29tcG9uZW50IiwiaW5jbHVkZXMiLCJpbmRleE9mIiwidGVzdCIsInNjYWxlQ29ycmVjdG9ycyIsImFkZFNjYWxlQ29ycmVjdG9yIiwiY29ycmVjdG9ycyIsImFzc2lnbiIsInRyYW5zZm9ybUF4ZXMiLCJvcmRlciIsInRyYW5zZm9ybVByb3BzIiwib3BlcmF0aW9uS2V5IiwiYXhlc0tleSIsInNvcnRUcmFuc2Zvcm1Qcm9wcyIsImEiLCJiIiwidHJhbnNmb3JtUHJvcFNldCIsIlNldCIsImlzVHJhbnNmb3JtUHJvcCIsInRyYW5zZm9ybU9yaWdpblByb3BzIiwiaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wIiwiaXNGb3JjZWRNb3Rpb25WYWx1ZSIsImlzTW90aW9uVmFsdWUiLCJ0cmFuc2xhdGVBbGlhcyIsIngiLCJ5IiwieiIsInRyYW5zZm9ybVBlcnNwZWN0aXZlIiwiYnVpbGRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Jc0RlZmF1bHQiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybUtleXMiLCJfYyIsImVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uIiwiX2QiLCJhbGxvd1RyYW5zZm9ybU5vbmUiLCJ0cmFuc2Zvcm1TdHJpbmciLCJzb3J0IiwidHJhbnNmb3JtSGFzWiIsIm51bVRyYW5zZm9ybUtleXMiLCJjb25jYXQiLCJ0cmltIiwiYnVpbGRUcmFuc2Zvcm1PcmlnaW4iLCJvcmlnaW5YIiwib3JpZ2luWSIsIm9yaWdpbloiLCJpc0NTU1ZhcmlhYmxlJDEiLCJzdGFydHNXaXRoIiwiZ2V0VmFsdWVBc1R5cGUiLCJ0eXBlIiwiaW50IiwibnVtYmVyIiwiTWF0aCIsInJvdW5kIiwibnVtYmVyVmFsdWVUeXBlcyIsImJvcmRlcldpZHRoIiwicHgiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIiwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsIndpZHRoIiwibWF4V2lkdGgiLCJoZWlnaHQiLCJtYXhIZWlnaHQiLCJzaXplIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwicGFkZGluZyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJtYXJnaW4iLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJyb3RhdGUiLCJkZWdyZWVzIiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwic2NhbGUiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJza2V3Iiwic2tld1giLCJza2V3WSIsImRpc3RhbmNlIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ0cmFuc2xhdGVaIiwicGVyc3BlY3RpdmUiLCJvcGFjaXR5IiwiYWxwaGEiLCJwcm9ncmVzc1BlcmNlbnRhZ2UiLCJ6SW5kZXgiLCJmaWxsT3BhY2l0eSIsInN0cm9rZU9wYWNpdHkiLCJudW1PY3RhdmVzIiwiYnVpbGRIVE1MU3R5bGVzIiwic3RhdGUiLCJsYXRlc3RWYWx1ZXMiLCJvcHRpb25zIiwic3R5bGUiLCJ2YXJzIiwidHJhbnNmb3JtT3JpZ2luIiwiaGFzVHJhbnNmb3JtIiwiaGFzVHJhbnNmb3JtT3JpZ2luIiwidHJhbnNmb3JtSXNOb25lIiwidmFsdWVUeXBlIiwidmFsdWVBc1R5cGUiLCJkZWZhdWx0IiwiY3JlYXRlSHRtbFJlbmRlclN0YXRlIiwiY29weVJhd1ZhbHVlc09ubHkiLCJ0YXJnZXQiLCJzb3VyY2UiLCJ1c2VJbml0aWFsTW90aW9uVmFsdWVzIiwidXNlU3R5bGUiLCJzdHlsZVByb3AiLCJ0cmFuc2Zvcm1WYWx1ZXMiLCJ1c2VIVE1MUHJvcHMiLCJodG1sUHJvcHMiLCJkcmFnTGlzdGVuZXIiLCJkcmFnZ2FibGUiLCJ1c2VyU2VsZWN0IiwiV2Via2l0VXNlclNlbGVjdCIsIldlYmtpdFRvdWNoQ2FsbG91dCIsInRvdWNoQWN0aW9uIiwidmFsaWRNb3Rpb25Qcm9wcyIsImlzVmFsaWRNb3Rpb25Qcm9wIiwic2hvdWxkRm9yd2FyZCIsImxvYWRFeHRlcm5hbElzVmFsaWRQcm9wIiwiaXNWYWxpZFByb3AiLCJmaWx0ZXJQcm9wcyIsImlzRG9tIiwiZm9yd2FyZE1vdGlvblByb3BzIiwiZmlsdGVyZWRQcm9wcyIsImNhbGNPcmlnaW4kMSIsIm9yaWdpbiIsIm9mZnNldCIsImNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4iLCJkaW1lbnNpb25zIiwicHhPcmlnaW5YIiwicHhPcmlnaW5ZIiwiZGFzaEtleXMiLCJhcnJheSIsImNhbWVsS2V5cyIsImJ1aWxkU1ZHUGF0aCIsImF0dHJzIiwic3BhY2luZyIsInVzZURhc2hDYXNlIiwicGF0aExlbmd0aCIsInBhdGhTcGFjaW5nIiwiYnVpbGRTVkdBdHRycyIsImF0dHJYIiwiYXR0clkiLCJwYXRoT2Zmc2V0IiwibGF0ZXN0IiwiX19yZXN0IiwiY3JlYXRlU3ZnUmVuZGVyU3RhdGUiLCJ1c2VTVkdQcm9wcyIsInZpc3VhbFByb3BzIiwicmF3U3R5bGVzIiwiY3JlYXRlVXNlUmVuZGVyIiwidXNlVmlzdWFsUHJvcHMiLCJlbGVtZW50UHJvcHMiLCJDQU1FTF9DQVNFX1BBVFRFUk4iLCJSRVBMQUNFX1RFTVBMQVRFIiwiY2FtZWxUb0Rhc2giLCJzdHIiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJyZW5kZXJIVE1MIiwiZWxlbWVudCIsImdldFByb2plY3Rpb25TdHlsZXMiLCJzZXRQcm9wZXJ0eSIsImNhbWVsQ2FzZUF0dHJpYnV0ZXMiLCJyZW5kZXJTVkciLCJyZW5kZXJTdGF0ZSIsIl9zdHlsZVByb3AiLCJzZXRBdHRyaWJ1dGUiLCJzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMSIsIm5ld1ZhbHVlcyIsInNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyIsInRhcmdldEtleSIsInRvVXBwZXJDYXNlIiwiaXNBbmltYXRpb25Db250cm9scyIsImlzS2V5ZnJhbWVzVGFyZ2V0IiwiaXNDdXN0b21WYWx1ZSIsIm1peCIsInRvVmFsdWUiLCJyZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzIiwicmVzb2x2ZU1vdGlvblZhbHVlIiwidW53cmFwcGVkVmFsdWUiLCJtYWtlU3RhdGUiLCJjcmVhdGVSZW5kZXJTdGF0ZSIsIm9uTW91bnQiLCJtYWtlTGF0ZXN0VmFsdWVzIiwibWFrZVVzZVZpc3VhbFN0YXRlIiwic2NyYXBlTW90aW9uVmFsdWVzIiwidmFsdWVzIiwibW90aW9uVmFsdWVzIiwiaXNDb250cm9sbGluZ1ZhcmlhbnRzIiwiaXNWYXJpYW50Tm9kZSIsImluaXRpYWxBbmltYXRpb25Jc0Jsb2NrZWQiLCJ2YXJpYW50VG9TZXQiLCJsaXN0IiwicmVzb2x2ZWQiLCJ0cmFuc2l0aW9uRW5kIiwidHJhbnNpdGlvbiIsInZhbHVlVGFyZ2V0IiwiaW5kZXgiLCJzdmdNb3Rpb25Db25maWciLCJnZXRCQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaHRtbE1vdGlvbkNvbmZpZyIsImNyZWF0ZURvbU1vdGlvbkNvbmZpZyIsImJhc2VDb25maWciLCJBbmltYXRpb25UeXBlIiwiYWRkRG9tRXZlbnQiLCJldmVudE5hbWUiLCJoYW5kbGVyIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXNlRG9tRXZlbnQiLCJ1c2VGb2N1c0dlc3R1cmUiLCJvbkZvY3VzIiwic2V0QWN0aXZlIiwiRm9jdXMiLCJvbkJsdXIiLCJpc01vdXNlRXZlbnQiLCJldmVudCIsIlBvaW50ZXJFdmVudCIsInBvaW50ZXJUeXBlIiwiTW91c2VFdmVudCIsImlzVG91Y2hFdmVudCIsImhhc1RvdWNoZXMiLCJ0b3VjaGVzIiwiZmlsdGVyUHJpbWFyeVBvaW50ZXIiLCJldmVudEhhbmRsZXIiLCJpc1ByaW1hcnlQb2ludGVyIiwiYnV0dG9uIiwiZGVmYXVsdFBhZ2VQb2ludCIsInBhZ2VYIiwicGFnZVkiLCJwb2ludEZyb21Ub3VjaCIsInBvaW50VHlwZSIsInByaW1hcnlUb3VjaCIsImNoYW5nZWRUb3VjaGVzIiwicG9pbnQiLCJwb2ludEZyb21Nb3VzZSIsImV4dHJhY3RFdmVudEluZm8iLCJ3cmFwSGFuZGxlciIsInNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyIiwibGlzdGVuZXIiLCJzdXBwb3J0c1BvaW50ZXJFdmVudHMiLCJvbnBvaW50ZXJkb3duIiwic3VwcG9ydHNUb3VjaEV2ZW50cyIsIm9udG91Y2hzdGFydCIsInN1cHBvcnRzTW91c2VFdmVudHMiLCJvbm1vdXNlZG93biIsIm1vdXNlRXZlbnROYW1lcyIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVyY2FuY2VsIiwicG9pbnRlcm92ZXIiLCJwb2ludGVyb3V0IiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwidG91Y2hFdmVudE5hbWVzIiwiZ2V0UG9pbnRlckV2ZW50TmFtZSIsImFkZFBvaW50ZXJFdmVudCIsInVzZVBvaW50ZXJFdmVudCIsImNyZWF0ZUxvY2siLCJsb2NrIiwib3BlbkxvY2siLCJnbG9iYWxIb3Jpem9udGFsTG9jayIsImdsb2JhbFZlcnRpY2FsTG9jayIsImdldEdsb2JhbExvY2siLCJvcGVuSG9yaXpvbnRhbF8xIiwib3BlblZlcnRpY2FsXzEiLCJpc0RyYWdBY3RpdmUiLCJvcGVuR2VzdHVyZUxvY2siLCJjcmVhdGVIb3ZlckV2ZW50IiwiaXNBY3RpdmUiLCJjYWxsYmFjayIsImluZm8iLCJIb3ZlciIsInVzZUhvdmVyR2VzdHVyZSIsIm9uSG92ZXJTdGFydCIsIm9uSG92ZXJFbmQiLCJpc05vZGVPckNoaWxkIiwiY2hpbGQiLCJwYXJlbnRFbGVtZW50IiwidXNlVW5tb3VudEVmZmVjdCIsInVzZVRhcEdlc3R1cmUiLCJvblRhcCIsIm9uVGFwU3RhcnQiLCJvblRhcENhbmNlbCIsImhhc1ByZXNzTGlzdGVuZXJzIiwiaXNQcmVzc2luZyIsImNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMiLCJldmVudE9wdGlvbnMiLCJvblBvaW50ZXJEb3duIiwicmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyIiwiY2hlY2tQb2ludGVyRW5kIiwiVGFwIiwib25Qb2ludGVyVXAiLCJnZXRJbnN0YW5jZSIsIm9uUG9pbnRlckNhbmNlbCIsInBpcGUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImFkZCIsIm9ic2VydmVyQ2FsbGJhY2tzIiwiV2Vha01hcCIsIm9ic2VydmVycyIsImZpcmVPYnNlcnZlckNhbGxiYWNrIiwiZW50cnkiLCJmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MiLCJlbnRyaWVzIiwiaW5pdEludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdCIsImxvb2t1cFJvb3QiLCJyb290T2JzZXJ2ZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZUludGVyc2VjdGlvbiIsInJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiZGVsZXRlIiwidW5vYnNlcnZlIiwidXNlVmlld3BvcnQiLCJ3aGlsZUluVmlldyIsIm9uVmlld3BvcnRFbnRlciIsIm9uVmlld3BvcnRMZWF2ZSIsInZpZXdwb3J0IiwiaGFzRW50ZXJlZFZpZXciLCJpc0luVmlldyIsInNob3VsZE9ic2VydmUiLCJvbmNlIiwidXNlT2JzZXJ2ZXIiLCJ1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJ1c2VJbnRlcnNlY3Rpb25PYnNlcnZlciIsInRocmVzaG9sZE5hbWVzIiwiYWxsIiwicm9vdE1hcmdpbiIsImFtb3VudCIsInRocmVzaG9sZCIsImludGVyc2VjdGlvbkNhbGxiYWNrIiwiaXNJbnRlcnNlY3RpbmciLCJJblZpZXciLCJmYWxsYmFjayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1ha2VSZW5kZXJsZXNzQ29tcG9uZW50IiwiaG9vayIsImdlc3R1cmVBbmltYXRpb25zIiwiY291bnRlciIsImluY3JlbWVudElkIiwidXNlSWQiLCJ1c2VQcmVzZW5jZSIsImlzUHJlc2VudCIsIm9uRXhpdENvbXBsZXRlIiwicmVnaXN0ZXIiLCJzYWZlVG9SZW1vdmUiLCJ1c2VJc1ByZXNlbnQiLCJzaGFsbG93Q29tcGFyZSIsIm5leHQiLCJwcmV2IiwicHJldkxlbmd0aCIsInNlY29uZHNUb01pbGxpc2Vjb25kcyIsInNlY29uZHMiLCJlYXNpbmdMb29rdXAiLCJsaW5lYXIiLCJlYXNlSW4iLCJlYXNlSW5PdXQiLCJlYXNlT3V0IiwiY2lyY0luIiwiY2lyY0luT3V0IiwiY2lyY091dCIsImJhY2tJbiIsImJhY2tJbk91dCIsImJhY2tPdXQiLCJhbnRpY2lwYXRlIiwiYm91bmNlSW4iLCJib3VuY2VJbk91dCIsImJvdW5jZU91dCIsImVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uIiwieDEiLCJ5MSIsIngyIiwieTIiLCJjdWJpY0JlemllciIsImlzRWFzaW5nQXJyYXkiLCJlYXNlIiwiaXNBbmltYXRhYmxlIiwiY29tcGxleCIsInVuZGVyRGFtcGVkU3ByaW5nIiwic3RpZmZuZXNzIiwiZGFtcGluZyIsInJlc3RTcGVlZCIsImNyaXRpY2FsbHlEYW1wZWRTcHJpbmciLCJ0byIsInNxcnQiLCJsaW5lYXJUd2VlbiIsImR1cmF0aW9uIiwia2V5ZnJhbWVzIiwiZGVmYXVsdFRyYW5zaXRpb25zIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJnZXREZWZhdWx0VHJhbnNpdGlvbiIsInZhbHVlS2V5IiwidHJhbnNpdGlvbkZhY3RvcnkiLCJkZWZhdWx0VmFsdWVUeXBlcyIsIm91dGxpbmVDb2xvciIsImZpbGwiLCJzdHJva2UiLCJib3JkZXJDb2xvciIsImJvcmRlclRvcENvbG9yIiwiYm9yZGVyUmlnaHRDb2xvciIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdENvbG9yIiwiZmlsdGVyIiwiV2Via2l0RmlsdGVyIiwiZ2V0RGVmYXVsdFZhbHVlVHlwZSIsImdldEFuaW1hdGFibGVOb25lIiwiZGVmYXVsdFZhbHVlVHlwZSIsImluc3RhbnRBbmltYXRpb25TdGF0ZSIsImlzVHJhbnNpdGlvbkRlZmluZWQiLCJ3aGVuIiwiZGVsYXkiLCJkZWxheUNoaWxkcmVuIiwic3RhZ2dlckNoaWxkcmVuIiwic3RhZ2dlckRpcmVjdGlvbiIsInJlcGVhdCIsInJlcGVhdFR5cGUiLCJyZXBlYXREZWxheSIsImZyb20iLCJsZWdhY3lSZXBlYXRXYXJuaW5nIiwiY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnMiLCJ0aW1lcyIsInlveW8iLCJmbGlwIiwibG9vcCIsIm1hcCIsIndhcm5pbmciLCJnZXREZWxheUZyb21UcmFuc2l0aW9uIiwidmFsdWVUcmFuc2l0aW9uIiwiZ2V0VmFsdWVUcmFuc2l0aW9uIiwiaHlkcmF0ZUtleWZyYW1lcyIsIl9fc3ByZWFkQXJyYXkiLCJnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zIiwiZ2V0QW5pbWF0aW9uIiwib25Db21wbGV0ZSIsImlzVGFyZ2V0QW5pbWF0YWJsZSIsImlzWmVybyIsImdldFplcm9Vbml0IiwiaXNPcmlnaW5BbmltYXRhYmxlIiwib25VcGRhdGUiLCJpbmVydGlhIiwiZmluYWxUYXJnZXQiLCJzdG9wIiwicGFyc2VGbG9hdCIsInBvdGVudGlhbFVuaXRUeXBlIiwic3RhcnRBbmltYXRpb24iLCJkZWxheVRpbWVyIiwiY29udHJvbHMiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaXNOdW1lcmljYWxTdHJpbmciLCJpc1plcm9WYWx1ZVN0cmluZyIsImFkZFVuaXF1ZUl0ZW0iLCJhcnIiLCJpdGVtIiwicmVtb3ZlSXRlbSIsInNwbGljZSIsIm1vdmVJdGVtIiwiZnJvbUluZGV4IiwidG9JbmRleCIsInNsaWNlIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiU3Vic2NyaXB0aW9uTWFuYWdlciIsInN1YnNjcmlwdGlvbnMiLCJfdGhpcyIsIm5vdGlmeSIsImMiLCJudW1TdWJzY3JpcHRpb25zIiwiZ2V0U2l6ZSIsImNsZWFyIiwiaXNGbG9hdCIsImlzTmFOIiwiTW90aW9uVmFsdWUiLCJ2ZXJzaW9uIiwidGltZURlbHRhIiwibGFzdFVwZGF0ZWQiLCJ1cGRhdGVTdWJzY3JpYmVycyIsInZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMiLCJyZW5kZXJTdWJzY3JpYmVycyIsImNhblRyYWNrVmVsb2NpdHkiLCJ1cGRhdGVBbmROb3RpZnkiLCJnZXRGcmFtZURhdGEiLCJkZWx0YSIsInRpbWVzdGFtcCIsInBvc3RSZW5kZXIiLCJzY2hlZHVsZVZlbG9jaXR5Q2hlY2siLCJ2ZWxvY2l0eUNoZWNrIiwiaGFzQW5pbWF0ZWQiLCJvbkNoYW5nZSIsInN1YnNjcmlwdGlvbiIsImNsZWFyTGlzdGVuZXJzIiwib25SZW5kZXJSZXF1ZXN0IiwiYXR0YWNoIiwicGFzc2l2ZUVmZmVjdCIsImdldFByZXZpb3VzIiwidmVsb2NpdHlQZXJTZWNvbmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0b3BBbmltYXRpb24iLCJ0aGVuIiwiY2xlYXJBbmltYXRpb24iLCJpc0FuaW1hdGluZyIsImRlc3Ryb3kiLCJtb3Rpb25WYWx1ZSIsInRlc3RWYWx1ZVR5cGUiLCJhdXRvIiwicGFyc2UiLCJkaW1lbnNpb25WYWx1ZVR5cGVzIiwicGVyY2VudCIsInZ3IiwidmgiLCJmaW5kRGltZW5zaW9uVmFsdWVUeXBlIiwiZmluZCIsInZhbHVlVHlwZXMiLCJmaW5kVmFsdWVUeXBlIiwic2V0TW90aW9uVmFsdWUiLCJoYXNWYWx1ZSIsImdldFZhbHVlIiwiYWRkVmFsdWUiLCJzZXRUYXJnZXQiLCJtYWtlVGFyZ2V0QW5pbWF0YWJsZSIsInNldFZhcmlhbnRzIiwidmFyaWFudExhYmVscyIsInJldmVyc2VkTGFiZWxzIiwicmV2ZXJzZSIsInZhcmlhbnQiLCJnZXRWYXJpYW50IiwidmFyaWFudENoaWxkcmVuIiwic2V0VmFsdWVzIiwiY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMiLCJuZXdWYWx1ZUtleXMiLCJudW1OZXdWYWx1ZXMiLCJ0YXJnZXRWYWx1ZSIsInJlYWRWYWx1ZSIsInNldEJhc2VUYXJnZXQiLCJnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbiIsImdldE9yaWdpbiIsImFuaW1hdGVWaXN1YWxFbGVtZW50Iiwibm90aWZ5QW5pbWF0aW9uU3RhcnQiLCJhbmltYXRpb25zIiwiYW5pbWF0ZVZhcmlhbnQiLCJyZXNvbHZlZERlZmluaXRpb24iLCJhbmltYXRlVGFyZ2V0Iiwibm90aWZ5QW5pbWF0aW9uQ29tcGxldGUiLCJ0cmFuc2l0aW9uT3ZlcnJpZGUiLCJnZXRDaGlsZEFuaW1hdGlvbnMiLCJmb3J3YXJkRGVsYXkiLCJhbmltYXRlQ2hpbGRyZW4iLCJmaXJzdCIsImxhc3QiLCJfZSIsIl9mIiwiYW5pbWF0aW9uVHlwZVN0YXRlIiwiZ2V0U3RhdGUiLCJzaG91bGRCbG9ja0FuaW1hdGlvbiIsIm1heFN0YWdnZXJEdXJhdGlvbiIsImdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uIiwic29ydEJ5VHJlZU9yZGVyIiwic29ydE5vZGVQb3NpdGlvbiIsInByb3RlY3RlZEtleXMiLCJuZWVkc0FuaW1hdGluZyIsInNob3VsZEJsb2NrIiwidmFyaWFudFByaW9yaXR5T3JkZXIiLCJBbmltYXRlIiwiRHJhZyIsIkV4aXQiLCJyZXZlcnNlUHJpb3JpdHlPcmRlciIsIm51bUFuaW1hdGlvblR5cGVzIiwiYW5pbWF0ZUxpc3QiLCJjcmVhdGVBbmltYXRpb25TdGF0ZSIsImNyZWF0ZVN0YXRlIiwiYWxsQW5pbWF0ZWRLZXlzIiwiaXNJbml0aWFsUmVuZGVyIiwiYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMiLCJhY2MiLCJpc0FuaW1hdGVkIiwic2V0QW5pbWF0ZUZ1bmN0aW9uIiwibWFrZUFuaW1hdG9yIiwiY2hhbmdlZEFjdGl2ZVR5cGUiLCJnZXRWYXJpYW50Q29udGV4dCIsInJlbW92ZWRLZXlzIiwiZW5jb3VudGVyZWRLZXlzIiwicmVtb3ZlZFZhcmlhbnRJbmRleCIsIkluZmluaXR5IiwiX2xvb3BfMSIsInR5cGVTdGF0ZSIsInByb3BJc1ZhcmlhbnQiLCJhY3RpdmVEZWx0YSIsImlzSW5oZXJpdGVkIiwibWFudWFsbHlBbmltYXRlT25Nb3VudCIsInByZXZQcm9wIiwidmFyaWFudERpZENoYW5nZSIsImNoZWNrVmFyaWFudHNEaWRDaGFuZ2UiLCJzaG91bGRBbmltYXRlVHlwZSIsImRlZmluaXRpb25MaXN0IiwicmVzb2x2ZWRWYWx1ZXMiLCJyZWR1Y2UiLCJwcmV2UmVzb2x2ZWRWYWx1ZXMiLCJhbGxLZXlzIiwibWFya1RvQW5pbWF0ZSIsImZhbGxiYWNrQW5pbWF0aW9uXzEiLCJmYWxsYmFja1RhcmdldCIsImdldEJhc2VUYXJnZXQiLCJzaG91bGRBbmltYXRlIiwiY3JlYXRlVHlwZVN0YXRlIiwic3Vic2NyaWJlIiwiUGFuU2Vzc2lvbiIsImhhbmRsZXJzIiwic3RhcnRFdmVudCIsImxhc3RNb3ZlRXZlbnQiLCJsYXN0TW92ZUV2ZW50SW5mbyIsInVwZGF0ZVBvaW50IiwiZ2V0UGFuSW5mbyIsImhpc3RvcnkiLCJpc1BhblN0YXJ0ZWQiLCJpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCIsIm9uU3RhcnQiLCJvbk1vdmUiLCJoYW5kbGVQb2ludGVyTW92ZSIsInRyYW5zZm9ybVBvaW50IiwiYnV0dG9ucyIsImhhbmRsZVBvaW50ZXJVcCIsInVwZGF0ZSIsImVuZCIsIm9uRW5kIiwib25TZXNzaW9uRW5kIiwicGFuSW5mbyIsImluaXRpYWxJbmZvIiwib25TZXNzaW9uU3RhcnQiLCJyZW1vdmVMaXN0ZW5lcnMiLCJ1cGRhdGVIYW5kbGVycyIsImNhbmNlbFN5bmMiLCJzdWJ0cmFjdFBvaW50IiwibGFzdERldmljZVBvaW50Iiwic3RhcnREZXZpY2VQb2ludCIsInRpbWVzdGFtcGVkUG9pbnQiLCJsYXN0UG9pbnQiLCJ0aW1lIiwiY2FsY0xlbmd0aCIsImF4aXMiLCJtYXgiLCJtaW4iLCJpc05lYXIiLCJtYXhEaXN0YW5jZSIsImNhbGNBeGlzRGVsdGEiLCJvcmlnaW5Qb2ludCIsInRyYW5zbGF0ZSIsImNhbGNCb3hEZWx0YSIsImNhbGNSZWxhdGl2ZUF4aXMiLCJyZWxhdGl2ZSIsImNhbGNSZWxhdGl2ZUJveCIsImNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbiIsImNhbGNSZWxhdGl2ZVBvc2l0aW9uIiwiYXBwbHlDb25zdHJhaW50cyIsImVsYXN0aWMiLCJjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMiLCJjYWxjUmVsYXRpdmVDb25zdHJhaW50cyIsImxheW91dEJveCIsImNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyIsImxheW91dEF4aXMiLCJjb25zdHJhaW50c0F4aXMiLCJjYWxjVmlld3BvcnRDb25zdHJhaW50cyIsImNvbnN0cmFpbnRzQm94IiwiY2FsY09yaWdpbiIsInNvdXJjZUxlbmd0aCIsInRhcmdldExlbmd0aCIsInByb2dyZXNzIiwiY2xhbXAiLCJyZWJhc2VBeGlzQ29uc3RyYWludHMiLCJjb25zdHJhaW50cyIsInJlbGF0aXZlQ29uc3RyYWludHMiLCJkZWZhdWx0RWxhc3RpYyIsInJlc29sdmVEcmFnRWxhc3RpYyIsImRyYWdFbGFzdGljIiwicmVzb2x2ZUF4aXNFbGFzdGljIiwibWluTGFiZWwiLCJtYXhMYWJlbCIsInJlc29sdmVQb2ludEVsYXN0aWMiLCJsYWJlbCIsImNyZWF0ZUF4aXNEZWx0YSIsImNyZWF0ZURlbHRhIiwiY3JlYXRlQXhpcyIsImNyZWF0ZUJveCIsImVhY2hBeGlzIiwiY29udmVydEJvdW5kaW5nQm94VG9Cb3giLCJjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCIsInRyYW5zZm9ybUJveFBvaW50cyIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImlzSWRlbnRpdHlTY2FsZSIsImhhc1NjYWxlIiwiaGFzVHJhbnNsYXRlIiwic2NhbGVQb2ludCIsImRpc3RhbmNlRnJvbU9yaWdpbiIsInNjYWxlZCIsImFwcGx5UG9pbnREZWx0YSIsImJveFNjYWxlIiwiYXBwbHlBeGlzRGVsdGEiLCJhcHBseUJveERlbHRhIiwiYm94IiwiYXBwbHlUcmVlRGVsdGFzIiwidHJlZVNjYWxlIiwidHJlZVBhdGgiLCJpc1NoYXJlZFRyYW5zaXRpb24iLCJ0cmVlTGVuZ3RoIiwibm9kZSIsInByb2plY3Rpb25EZWx0YSIsImRpc3BsYXkiLCJzY3JvbGwiLCJ0cmFuc2Zvcm1Cb3giLCJ0cmFuc2xhdGVBeGlzIiwidHJhbnNmb3JtQXhpcyIsInRyYW5zZm9ybXMiLCJzY2FsZUtleSIsIm9yaWdpbktleSIsImF4aXNPcmlnaW4iLCJ4S2V5cyQxIiwieUtleXMkMSIsIm1lYXN1cmVWaWV3cG9ydEJveCIsIm1lYXN1cmVQYWdlQm94Iiwicm9vdFByb2plY3Rpb25Ob2RlIiwidmlld3BvcnRCb3giLCJlbGVtZW50RHJhZ0NvbnRyb2xzIiwiVmlzdWFsRWxlbWVudERyYWdDb250cm9scyIsIm9wZW5HbG9iYWxMb2NrIiwiaXNEcmFnZ2luZyIsImN1cnJlbnREaXJlY3Rpb24iLCJoYXNNdXRhdGVkQ29uc3RyYWludHMiLCJvcmlnaW5FdmVudCIsInNuYXBUb0N1cnNvciIsImRyYWdQcm9wYWdhdGlvbiIsIm9uRHJhZ1N0YXJ0IiwicmVzb2x2ZUNvbnN0cmFpbnRzIiwiaXNBbmltYXRpb25CbG9ja2VkIiwiZ2V0QXhpc01vdGlvblZhbHVlIiwibWVhc3VyZWRBeGlzIiwiYWN0dWFsIiwibGVuZ3RoXzEiLCJkcmFnRGlyZWN0aW9uTG9jayIsIm9uRGlyZWN0aW9uTG9jayIsIm9uRHJhZyIsImdldEN1cnJlbnREaXJlY3Rpb24iLCJ1cGRhdGVBeGlzIiwicGFuU2Vzc2lvbiIsImdldFRyYW5zZm9ybVBhZ2VQb2ludCIsImNhbmNlbCIsIm9uRHJhZ0VuZCIsIl9wb2ludCIsInNob3VsZERyYWciLCJheGlzVmFsdWUiLCJwcmV2Q29uc3RyYWludHMiLCJyZXNvbHZlUmVmQ29uc3RyYWludHMiLCJvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMiLCJjb25zdHJhaW50c0VsZW1lbnQiLCJtZWFzdXJlZENvbnN0cmFpbnRzIiwidXNlckNvbnN0cmFpbnRzIiwiZHJhZ01vbWVudHVtIiwiZHJhZ1RyYW5zaXRpb24iLCJkcmFnU25hcFRvT3JpZ2luIiwib25EcmFnVHJhbnNpdGlvbkVuZCIsIm1vbWVudHVtQW5pbWF0aW9ucyIsImJvdW5jZVN0aWZmbmVzcyIsImJvdW5jZURhbXBpbmciLCJ0aW1lQ29uc3RhbnQiLCJyZXN0RGVsdGEiLCJzdGFydEF4aXNWYWx1ZUFuaW1hdGlvbiIsImRyYWdLZXkiLCJleHRlcm5hbE1vdGlvblZhbHVlIiwic2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzIiwiYm94UHJvZ3Jlc3MiLCJ1cGRhdGVTY3JvbGwiLCJ1cGRhdGVMYXlvdXQiLCJhZGRMaXN0ZW5lcnMiLCJzdG9wUG9pbnRlckxpc3RlbmVyIiwibWVhc3VyZURyYWdDb25zdHJhaW50cyIsInN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIiLCJzdG9wUmVzaXplTGlzdGVuZXIiLCJoYXNMYXlvdXRDaGFuZ2VkIiwiZGlyZWN0aW9uIiwibG9ja1RocmVzaG9sZCIsImFicyIsInVzZURyYWciLCJncm91cERyYWdDb250cm9scyIsImRyYWdDb250cm9scyIsInVzZVBhbkdlc3R1cmUiLCJvblBhbiIsIm9uUGFuU3RhcnQiLCJvblBhbkVuZCIsIm9uUGFuU2Vzc2lvblN0YXJ0IiwiaGFzUGFuRXZlbnRzIiwibmFtZXMiLCJjcmVhdGVMaWZlY3ljbGVzIiwibWFuYWdlcnMiLCJwcm9wU3Vic2NyaXB0aW9ucyIsImxpZmVjeWNsZXMiLCJjbGVhckFsbExpc3RlbmVycyIsIm1hbmFnZXIiLCJ1cGRhdGVQcm9wTGlzdGVuZXJzIiwib24iLCJwcm9wTGlzdGVuZXIiLCJhcmdzIiwiX2kiLCJ1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMiLCJuZXh0VmFsdWUiLCJwcmV2VmFsdWUiLCJleGlzdGluZ1ZhbHVlIiwiZ2V0U3RhdGljVmFsdWUiLCJyZW1vdmVWYWx1ZSIsInRyZWVUeXBlIiwiYnVpbGQiLCJyZW5kZXJJbnN0YW5jZSIsInJlYWRWYWx1ZUZyb21JbnN0YW5jZSIsInJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlIiwiaXNNb3VudGVkIiwidmFsdWVTdWJzY3JpcHRpb25zIiwicHJldk1vdGlvblZhbHVlcyIsImJhc2VUYXJnZXQiLCJyZW1vdmVGcm9tVmFyaWFudFRyZWUiLCJ0cmlnZ2VyQnVpbGQiLCJub3RpZnlVcGRhdGUiLCJiaW5kVG9Nb3Rpb25WYWx1ZSIsInJlbW92ZU9uQ2hhbmdlIiwibGF0ZXN0VmFsdWUiLCJyZW1vdmVPblJlbmRlclJlcXVlc3QiLCJpbml0aWFsTW90aW9uVmFsdWVzIiwiZGVwdGgiLCJpc1Zpc2libGUiLCJuZXdJbnN0YW5jZSIsImFkZFZhcmlhbnRDaGlsZCIsInJlbW92ZSIsImNsb3Nlc3RWYXJpYW50Tm9kZSIsImdldENsb3Nlc3RWYXJpYW50Tm9kZSIsIm90aGVyIiwiZ2V0TGF5b3V0SWQiLCJzZXRTdGF0aWNWYWx1ZSIsInNldFZpc2liaWxpdHkiLCJ2aXNpYmlsaXR5IiwiY2FuTXV0YXRlIiwiZGVmYXVsdFZhbHVlIiwibmV3UHJvcHMiLCJzdGFydEF0UGFyZW50IiwiY29udGV4dF8xIiwibnVtVmFyaWFudFByb3BzIiwidmFyaWFudFByb3BzIiwiaXNDU1NWYXJpYWJsZSIsImNzc1ZhcmlhYmxlUmVnZXgiLCJwYXJzZUNTU1ZhcmlhYmxlIiwibWF0Y2giLCJleGVjIiwidG9rZW4iLCJtYXhEZXB0aCIsImdldFZhcmlhYmxlVmFsdWUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInJlc29sdmVDU1NWYXJpYWJsZXMiLCJFbGVtZW50IiwicG9zaXRpb25hbEtleXMiLCJpc1Bvc2l0aW9uYWxLZXkiLCJoYXNQb3NpdGlvbmFsS2V5Iiwic2V0QW5kUmVzZXRWZWxvY2l0eSIsImlzTnVtT3JQeFR5cGUiLCJCb3VuZGluZ0JveERpbWVuc2lvbiIsImdldFBvc0Zyb21NYXRyaXgiLCJtYXRyaXgiLCJwb3MiLCJzcGxpdCIsImdldFRyYW5zbGF0ZUZyb21NYXRyaXgiLCJwb3MyIiwicG9zMyIsIl9iYm94IiwibWF0cml4M2QiLCJub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyIsInJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0iLCJyZW1vdmVkVHJhbnNmb3JtcyIsInBvc2l0aW9uYWxWYWx1ZXMiLCJjb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXMiLCJjaGFuZ2VkS2V5cyIsIm9yaWdpbkJib3giLCJlbGVtZW50Q29tcHV0ZWRTdHlsZSIsInRhcmdldEJib3giLCJjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyIsInRhcmdldFBvc2l0aW9uYWxLZXlzIiwicmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyIsImhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzIiwiY2hhbmdlZFZhbHVlVHlwZUtleXMiLCJmcm9tVHlwZSIsInRvVHlwZSIsIm51bUtleWZyYW1lcyIsInNjcm9sbFlfMSIsInBhZ2VZT2Zmc2V0IiwiY29udmVydGVkVGFyZ2V0Iiwic2Nyb2xsVG8iLCJ1bml0Q29udmVyc2lvbiIsInBhcnNlRG9tVmFyaWFudCIsImdldENvbXB1dGVkU3R5bGUkMSIsImh0bWxDb25maWciLCJkb21FbGVtZW50IiwiZGVmYXVsdFR5cGUiLCJjb21wdXRlZFN0eWxlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJyZXNldFRyYW5zZm9ybSIsInJlc3RvcmVUcmFuc2Zvcm0iLCJtdXRhYmxlU3RhdGUiLCJwYXJzZWQiLCJodG1sVmlzdWFsRWxlbWVudCIsInN2Z1Zpc3VhbEVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJfZWxlbWVudCIsImNyZWF0ZURvbVZpc3VhbEVsZW1lbnQiLCJwaXhlbHNUb1BlcmNlbnQiLCJwaXhlbHMiLCJjb3JyZWN0Qm9yZGVyUmFkaXVzIiwiY29ycmVjdCIsInZhclRva2VuIiwiY29ycmVjdEJveFNoYWRvdyIsIm9yaWdpbmFsIiwiY29udGFpbnNDU1NWYXJpYWJsZXMiLCJjc3NWYXJpYWJsZXMiLCJzaGFkb3ciLCJ0ZW1wbGF0ZSIsImNyZWF0ZVRyYW5zZm9ybWVyIiwieFNjYWxlIiwieVNjYWxlIiwiYXZlcmFnZVNjYWxlIiwib3V0cHV0IiwiaV8xIiwiY3NzVmFyaWFibGUiLCJNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQiLCJjb21wb25lbnREaWRNb3VudCIsImxheW91dEdyb3VwIiwic3dpdGNoTGF5b3V0R3JvdXAiLCJkZWZhdWx0U2NhbGVDb3JyZWN0b3JzIiwiZ3JvdXAiLCJkaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJsYXlvdXREZXBlbmRlbmN5Iiwid2lsbFVwZGF0ZSIsInByb21vdGUiLCJyZWxlZ2F0ZSIsImdldFN0YWNrIiwibWVtYmVycyIsImN1cnJlbnRBbmltYXRpb24iLCJpc0xlYWQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInByb21vdGVDb250ZXh0Iiwic2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCIsImRlcmVnaXN0ZXIiLCJNZWFzdXJlTGF5b3V0IiwiYXBwbHlUbyIsImJveFNoYWRvdyIsImxheW91dEZlYXR1cmVzIiwiYm9yZGVycyIsIm51bUJvcmRlcnMiLCJhc051bWJlciIsImlzUHgiLCJtaXhWYWx1ZXMiLCJmb2xsb3ciLCJsZWFkIiwic2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSIsImlzT25seU1lbWJlciIsImVhc2VDcm9zc2ZhZGVJbiIsIm9wYWNpdHlFeGl0IiwiZWFzZUNyb3NzZmFkZU91dCIsImJvcmRlckxhYmVsIiwiZm9sbG93UmFkaXVzIiwiZ2V0UmFkaXVzIiwibGVhZFJhZGl1cyIsImNhbk1peCIsInJhZGl1c05hbWUiLCJjb21wcmVzcyIsImVhc2luZyIsImNvcHlBeGlzSW50byIsIm9yaWdpbkF4aXMiLCJjb3B5Qm94SW50byIsIm9yaWdpbkJveCIsInJlbW92ZVBvaW50RGVsdGEiLCJyZW1vdmVBeGlzRGVsdGEiLCJzb3VyY2VBeGlzIiwicmVsYXRpdmVQcm9ncmVzcyIsInJlbW92ZUF4aXNUcmFuc2Zvcm1zIiwieEtleXMiLCJ5S2V5cyIsInJlbW92ZUJveFRyYW5zZm9ybXMiLCJzb3VyY2VCb3giLCJpc0F4aXNEZWx0YVplcm8iLCJpc0RlbHRhWmVybyIsImJveEVxdWFscyIsIk5vZGVTdGFjayIsInByZXZMZWFkIiwiaW5kZXhPZk5vZGUiLCJmaW5kSW5kZXgiLCJtZW1iZXIiLCJwcmVzZXJ2ZUZvbGxvd09wYWNpdHkiLCJzaG93IiwicmVzdW1lRnJvbSIsInByZXNlcnZlT3BhY2l0eSIsInNuYXBzaG90IiwiYW5pbWF0aW9uVmFsdWVzIiwiaXNTaGFyZWQiLCJpc1VwZGF0aW5nIiwiaXNMYXlvdXREaXJ0eSIsImNyb3NzZmFkZSIsImhpZGUiLCJleGl0QW5pbWF0aW9uQ29tcGxldGUiLCJyZXN1bWluZ0Zyb20iLCJyZW1vdmVMZWFkU25hcHNob3QiLCJpZGVudGl0eVByb2plY3Rpb24iLCJidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0iLCJsYXRlc3RUcmFuc2Zvcm0iLCJ4VHJhbnNsYXRlIiwieVRyYW5zbGF0ZSIsImVsZW1lbnRTY2FsZVgiLCJlbGVtZW50U2NhbGVZIiwiY29tcGFyZUJ5RGVwdGgiLCJGbGF0VHJlZSIsImlzRGlydHkiLCJhbmltYXRpb25UYXJnZXQiLCJjcmVhdGVQcm9qZWN0aW9uTm9kZSIsImF0dGFjaFJlc2l6ZUxpc3RlbmVyIiwiZGVmYXVsdFBhcmVudCIsIm1lYXN1cmVTY3JvbGwiLCJjaGVja0lzU2Nyb2xsUm9vdCIsIlByb2plY3Rpb25Ob2RlIiwiaXNUcmVlQW5pbWF0aW5nIiwidXBkYXRlTWFudWFsbHlCbG9ja2VkIiwidXBkYXRlQmxvY2tlZEJ5UmVzaXplIiwiaXNTVkciLCJuZWVkc1Jlc2V0Iiwic2hvdWxkUmVzZXRUcmFuc2Zvcm0iLCJldmVudEhhbmRsZXJzIiwicG90ZW50aWFsTm9kZXMiLCJjaGVja1VwZGF0ZUZhaWxlZCIsImNsZWFyQWxsU25hcHNob3RzIiwidXBkYXRlUHJvamVjdGlvbiIsIm5vZGVzIiwicmVzb2x2ZVRhcmdldERlbHRhIiwiY2FsY1Byb2plY3Rpb24iLCJoYXNQcm9qZWN0ZWQiLCJhbmltYXRpb25Qcm9ncmVzcyIsInNoYXJlZE5vZGVzIiwicGF0aCIsInJlZ2lzdGVyUG90ZW50aWFsTm9kZSIsIm5vdGlmeUxpc3RlbmVycyIsInN1YnNjcmlwdGlvbk1hbmFnZXIiLCJoYXNMaXN0ZW5lcnMiLCJTVkdFbGVtZW50IiwidGFnTmFtZSIsInVuYmxvY2tUaW1lb3V0XzEiLCJyZXNpemVVbmJsb2NrVXBkYXRlXzEiLCJmaW5pc2hBbmltYXRpb24iLCJyZWdpc3RlclNoYXJlZE5vZGUiLCJoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQiLCJuZXdMYXlvdXQiLCJpc1RyZWVBbmltYXRpb25CbG9ja2VkIiwicmVsYXRpdmVUYXJnZXQiLCJsYXlvdXRUcmFuc2l0aW9uIiwiZGVmYXVsdExheW91dFRyYW5zaXRpb24iLCJfZyIsIm9uTGF5b3V0QW5pbWF0aW9uU3RhcnQiLCJvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlIiwidGFyZ2V0Q2hhbmdlZCIsInRhcmdldExheW91dCIsImhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQiLCJzZXRBbmltYXRpb25PcmlnaW4iLCJhbmltYXRpb25PcHRpb25zIiwib25QbGF5IiwicHJlUmVuZGVyIiwiYmxvY2tVcGRhdGUiLCJ1bmJsb2NrVXBkYXRlIiwiaXNVcGRhdGVCbG9ja2VkIiwic3RhcnRVcGRhdGUiLCJyZXNldFJvdGF0aW9uIiwic2hvdWxkTm90aWZ5TGlzdGVuZXJzIiwicHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUiLCJ1cGRhdGVTbmFwc2hvdCIsInVwZGF0ZVdhc0Jsb2NrZWQiLCJjbGVhck1lYXN1cmVtZW50cyIsIm1vdW50Tm9kZUVhcmx5IiwicmVzZXRUcmFuc2Zvcm1TdHlsZSIsIm5vdGlmeUxheW91dFVwZGF0ZSIsImZsdXNoU3luYyIsImNsZWFyU25hcHNob3QiLCJyZW1vdmVMZWFkU25hcHNob3RzIiwic2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uIiwibWVhc3VyZWQiLCJtZWFzdXJlIiwicmVtb3ZlVHJhbnNmb3JtIiwicmVtb3ZlRWxlbWVudFNjcm9sbCIsInJvdW5kQm94IiwicHJldkxheW91dCIsImxheW91dENvcnJlY3RlZCIsIm5vdGlmeUxheW91dE1lYXN1cmUiLCJpc1Njcm9sbFJvb3QiLCJpc1Jlc2V0UmVxdWVzdGVkIiwiaGFzUHJvamVjdGlvbiIsInRyYW5zZm9ybVRlbXBsYXRlVmFsdWUiLCJ0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQiLCJib3hXaXRob3V0U2Nyb2xsIiwic2Nyb2xsXzEiLCJyb290U2Nyb2xsIiwiYXBwbHlUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Pbmx5Iiwid2l0aFRyYW5zZm9ybXMiLCJib3hXaXRob3V0VHJhbnNmb3JtIiwibm9kZUJveCIsInNldFRhcmdldERlbHRhIiwidGFyZ2V0RGVsdGEiLCJyZWxhdGl2ZVBhcmVudCIsImdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50IiwicmVsYXRpdmVUYXJnZXRPcmlnaW4iLCJ0YXJnZXRXaXRoVHJhbnNmb3JtcyIsImF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCIsInBlbmRpbmdBbmltYXRpb24iLCJnZXRMZWFkIiwicHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSIsInByZXZUcmVlU2NhbGVYIiwicHJldlRyZWVTY2FsZVkiLCJwcmV2UHJvamVjdGlvblRyYW5zZm9ybSIsInByb2plY3Rpb25UcmFuc2Zvcm0iLCJub3RpZnlBbGwiLCJzbmFwc2hvdExhdGVzdFZhbHVlcyIsIm1peGVkVmFsdWVzIiwicmVsYXRpdmVMYXlvdXQiLCJpc1NoYXJlZExheW91dEFuaW1hdGlvbiIsImhhc09wYWNpdHlDcm9zc2ZhZGUiLCJtaXhUYXJnZXREZWx0YSIsIm1peEF4aXNEZWx0YSIsIm1peEJveCIsImNvbXBsZXRlQW5pbWF0aW9uIiwiYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQiLCJzdGFjayIsInNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eSIsImdldFByZXZMZWFkIiwiaGFzUm90YXRlIiwicmVzZXRWYWx1ZXMiLCJzdHlsZXMiLCJwb2ludGVyRXZlbnRzIiwiZW1wdHlTdHlsZXMiLCJ2YWx1ZXNUb1JlbmRlciIsIl9oIiwiY29ycmVjdGVkIiwibnVtIiwicmVzZXRUcmVlIiwibGF5b3V0XzEiLCJtZWFzdXJlZExheW91dCIsImF4aXNTbmFwc2hvdCIsImxheW91dERlbHRhIiwidmlzdWFsRGVsdGEiLCJwYXJlbnRTbmFwc2hvdCIsInBhcmVudExheW91dCIsInJlbGF0aXZlU25hcHNob3QiLCJvbkJlZm9yZUxheW91dE1lYXN1cmUiLCJub3RpZnlCZWZvcmVMYXlvdXRNZWFzdXJlIiwibWl4QXhpcyIsInNlYXJjaE5vZGUiLCJzZWFyY2hFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsInJvdW5kQXhpcyIsIkRvY3VtZW50UHJvamVjdGlvbk5vZGUiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxMZWZ0IiwiYm9keSIsInNjcm9sbFRvcCIsIkhUTUxQcm9qZWN0aW9uTm9kZSIsImRvY3VtZW50Tm9kZSIsInBvc2l0aW9uIiwiZmVhdHVyZUJ1bmRsZSIsIm1vdGlvbiIsImNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCIsIm0iLCJ1c2VJc01vdW50ZWQiLCJ1c2VGb3JjZVVwZGF0ZSIsImZvcmNlZFJlbmRlckNvdW50Iiwic2V0Rm9yY2VkUmVuZGVyQ291bnQiLCJmb3JjZVJlbmRlciIsImRlZmVycmVkRm9yY2VSZW5kZXIiLCJQcmVzZW5jZUNoaWxkIiwicHJlc2VuY2VBZmZlY3RzTGF5b3V0IiwicHJlc2VuY2VDaGlsZHJlbiIsIm5ld0NoaWxkcmVuTWFwIiwiY2hpbGRJZCIsImVfMSIsIl9fdmFsdWVzIiwiZG9uZSIsImlzQ29tcGxldGUiLCJlXzFfMSIsImVycm9yIiwicmV0dXJuIiwiXyIsImdldENoaWxkS2V5IiwidXBkYXRlQ2hpbGRMb29rdXAiLCJhbGxDaGlsZHJlbiIsIm9ubHlFbGVtZW50cyIsImZpbHRlcmVkIiwiQ2hpbGRyZW4iLCJpc1ZhbGlkRWxlbWVudCIsIkFuaW1hdGVQcmVzZW5jZSIsImV4aXRCZWZvcmVFbnRlciIsImZvcmNlUmVuZGVyTGF5b3V0R3JvdXAiLCJmaWx0ZXJlZENoaWxkcmVuIiwiY2hpbGRyZW5Ub1JlbmRlciIsImV4aXRpbmciLCJwcmVzZW50Q2hpbGRyZW4iLCJGcmFnbWVudCIsInByZXNlbnRLZXlzIiwidGFyZ2V0S2V5cyIsIm51bVByZXNlbnQiLCJpbnNlcnRpb25JbmRleCIsIm9uRXhpdCIsInJlbW92ZUluZGV4IiwicHJlc2VudENoaWxkIiwiY2xvbmVFbGVtZW50IiwiRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCIsIm5vZGVHcm91cCIsImRpcnR5QWxsIiwiZGlydHkiLCJzaG91bGRJbmhlcml0R3JvdXAiLCJzaG91bGRJbmhlcml0SWQiLCJMYXlvdXRHcm91cCIsImluaGVyaXRJZCIsImxheW91dEdyb3VwQ29udGV4dCIsImRlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQiLCJ1cHN0cmVhbUlkIiwibWVtb2l6ZWRDb250ZXh0IiwiQW5pbWF0ZVNoYXJlZExheW91dCIsIk1vdGlvbkNvbmZpZyIsIkxhenlNb3Rpb24iLCJpc0xhenlCdW5kbGUiLCJzZXRJc0xvYWRlZCIsImxvYWRlZFJlbmRlcmVyIiwibG9hZGVkRmVhdHVyZXMiLCJSZW9yZGVyQ29udGV4dCIsImNoZWNrUmVvcmRlciIsIm5leHRPZmZzZXQiLCJuZXh0SXRlbSIsIm5leHRMYXlvdXQiLCJuZXh0SXRlbUNlbnRlciIsIlJlb3JkZXJHcm91cCIsImFzIiwib25SZW9yZGVyIiwiaXNSZW9yZGVyaW5nIiwicmVnaXN0ZXJJdGVtIiwiY29tcGFyZU1pbiIsInVwZGF0ZU9yZGVyIiwibmV3T3JkZXIiLCJHcm91cCIsInVzZU1vdGlvblZhbHVlIiwic2V0TGF0ZXN0XzEiLCJpc0N1c3RvbVZhbHVlVHlwZSIsImdldE1peGVyIiwidXNlSW1tZWRpYXRlIiwiYXJnT2Zmc2V0IiwiaW5wdXRWYWx1ZSIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsImludGVycG9sYXRvciIsImludGVycG9sYXRlIiwibWl4ZXIiLCJ1c2VPbkNoYW5nZSIsInVzZU11bHRpT25DaGFuZ2UiLCJ1bnN1YnNjcmliZSIsInVzZUNvbWJpbmVNb3Rpb25WYWx1ZXMiLCJjb21iaW5lVmFsdWVzIiwidXBkYXRlVmFsdWUiLCJ1c2VUcmFuc2Zvcm0iLCJpbnB1dCIsImlucHV0UmFuZ2VPclRyYW5zZm9ybWVyIiwidHJhbnNmb3JtZXIiLCJ1c2VMaXN0VHJhbnNmb3JtIiwibnVtVmFsdWVzIiwidXNlRGVmYXVsdE1vdGlvblZhbHVlIiwiUmVvcmRlckl0ZW0iLCJsYXRlc3RYIiwibGF0ZXN0WSIsImdlc3R1cmVQb2ludCIsIm9uTGF5b3V0TWVhc3VyZSIsIkl0ZW0iLCJSZW9yZGVyIiwiZG9tQW5pbWF0aW9uIiwiZG9tTWF4IiwidXNlTW90aW9uVGVtcGxhdGUiLCJmcmFnbWVudHMiLCJudW1GcmFnbWVudHMiLCJidWlsZFZhbHVlIiwidXNlU3ByaW5nIiwiYWN0aXZlU3ByaW5nQW5pbWF0aW9uIiwidXNlVmVsb2NpdHkiLCJuZXdWZWxvY2l0eSIsImNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyIsInNjcm9sbFgiLCJzY3JvbGxZIiwic2Nyb2xsWFByb2dyZXNzIiwic2Nyb2xsWVByb2dyZXNzIiwidXNlU2Nyb2xsIiwiY29udGFpbmVyIiwidXNlRWxlbWVudFNjcm9sbCIsInVzZVZpZXdwb3J0U2Nyb2xsIiwiZ2V0Q3VycmVudFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJ1c2VBbmltYXRpb25GcmFtZSIsImluaXRpYWxUaW1lc3RhbXAiLCJwcm92aWRlVGltZVNpbmNlU3RhcnQiLCJ1c2VUaW1lIiwidCIsImFuaW1hdGlvbkNvbnRyb2xzIiwiaGFzTW91bnRlZCIsInBlbmRpbmdBbmltYXRpb25zIiwic3Vic2NyaWJlcnMiLCJhbmltYXRpb25zXzEiLCJ1c2VBbmltYXRpb25Db250cm9scyIsInVzZUFuaW1hdGlvbiIsInVzZUN5Y2xlIiwiaXRlbXMiLCJzZXRJdGVtIiwicnVuQ3ljbGUiLCJ3cmFwIiwidXNlSW5WaWV3Iiwic2V0SW5WaWV3Iiwib25FbnRlciIsIkRyYWdDb250cm9scyIsImNvbXBvbmVudENvbnRyb2xzIiwibmF0aXZlRXZlbnQiLCJjcmVhdGVEcmFnQ29udHJvbHMiLCJ1c2VEcmFnQ29udHJvbHMiLCJ1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiIsInN0YXJ0VHJhbnNpdGlvbiIsImNiIiwidXNlSW5zdGFudFRyYW5zaXRpb24iLCJmb3JjZVVwZGF0ZSIsInN0YXJ0SW5zdGFudExheW91dFRyYW5zaXRpb24iLCJ1c2VSZXNldFByb2plY3Rpb24iLCJyZXNldCIsImNyZWF0ZU9iamVjdCIsInN0YXRlVmlzdWFsRWxlbWVudCIsIl9zdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZUFuaW1hdGVkU3RhdGUiLCJzZXRBbmltYXRpb25TdGF0ZSIsImFuaW1hdGlvbkRlZmluaXRpb24iLCJtYXhTY2FsZSIsImludmVydFNjYWxlIiwiaGFzV2FybmVkIiwidXNlSW52ZXJ0ZWRTY2FsZSIsInBhcmVudFNjYWxlWCIsInBhcmVudFNjYWxlWSIsInVzZURlcHJlY2F0ZWRBbmltYXRlZFN0YXRlIiwidXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/framer-motion/dist/cjs/index.js\n");

/***/ })

};
;